{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1505209760000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1505209973000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1505209760000},{"_id":"source/.DS_Store","hash":"cb6658bfb8dae702dab932182d76cf0276c020d5","modified":1507614035000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1505209973000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1505209760000},{"_id":"themes/next/.travis.yml","hash":"c42d9608c8c7fe90de7b1581a8dc3886e90c179e","modified":1505209760000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1505209760000},{"_id":"themes/next/README.en.md","hash":"4ece25ee5f64447cd522e54cb0fffd9a375f0bd4","modified":1505209973000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1505209760000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1505209973000},{"_id":"themes/next/gulpfile.coffee","hash":"b00e93c5c8667a4fbed71046dc93ce6784bf6257","modified":1505209973000},{"_id":"themes/next/package.json","hash":"a042faed34835a52505643aa2d841cd2dcf5dff6","modified":1505209973000},{"_id":"source/_discarded/hello-world.md","hash":"d8ff2658300993d5f5a4d2d9583948d1ceab86ed","modified":1505455011000},{"_id":"source/_discarded/CSS布局之-理解BFC.md","hash":"2985861f7c27c8783196bda1ae11929453122d29","modified":1508465348000},{"_id":"source/_posts/JavaScript中常用工具函数.md","hash":"6f18d5b4d0a4f3eb07bc1f5dae02060c7c19b0ef","modified":1508120397000},{"_id":"source/_posts/Object属性特性详解.md","hash":"ace6e80f517dba5afc2123319a1b6675dce50a3c","modified":1505454853000},{"_id":"source/_posts/apply与call性能分析.md","hash":"76aaca25920596fff1c11b28b50abb67958ed0bf","modified":1508120281000},{"_id":"themes/next/_config.yml","hash":"c3dc64cbb81c2bba8c2641d8d4a5fd0ab7527055","modified":1508062324000},{"_id":"source/_posts/mysql-workbench中PK,NN,UQ,BIN,UN,ZF,AI标识简写说明.md","hash":"9f3759b5121f0213046ff498167d8e7e5a733d32","modified":1508120442000},{"_id":"source/_posts/vue服务端渲染(SSR)初探.md","hash":"213d0a20b171ef7ef77d92f20e786a584cc45c36","modified":1508120563000},{"_id":"source/_posts/vue源码解析之--核心部分core-util(二).md","hash":"95638fcfb19493a9f59c23f7b21f4dace67d2ac7","modified":1508120603000},{"_id":"source/_posts/vue源码解析之--工具函数(一).md","hash":"6762e1bcd018639024c15cd9ec8635335276fe2e","modified":1508120584000},{"_id":"source/_posts/11.md","hash":"5e4ebafd767ae87f2571d2619f24646d013d5d10","modified":1509415016000},{"_id":"source/_posts/javascript事件流、事件代理、target和currentTarget.md","hash":"77bf04b707dd054eb868b3dd341a1ddee21d7e9c","modified":1509415084000},{"_id":"source/_posts/使用Javascript做算法题（一）Maximum-Subarray.md","hash":"b9ed99727a89d9a6f11b526a91aed9f896783ed0","modified":1508120228000},{"_id":"source/_posts/使用Javascript做算法题（三）Largest-Number.md","hash":"1a53302789f89b6b8296120ca19ac8fb7f54467e","modified":1508120239000},{"_id":"source/_posts/使用Javascript做算法题（二）Unique-Paths.md","hash":"aa5cfb669ac4b8aede0b5af3da918f60833223cf","modified":1508120247000},{"_id":"source/_posts/从几个关键词来理解http缓存.md","hash":"0c45d9aeb209aee81995f78aa3093a91dc210082","modified":1508120520000},{"_id":"source/_posts/使用eslint检查JS代码.md","hash":"dccaf2e77c07d8470934e6a3833f09340d828d74","modified":1507709721000},{"_id":"source/_posts/.DS_Store","hash":"e66e6a182a28d4540ca34a259ab90825e3e3e67c","modified":1505454562000},{"_id":"source/_posts/原生JS实现图片懒加载(lazyload).md","hash":"0738650ea237247fb59d99f42252e25bcbca22e8","modified":1505454792000},{"_id":"source/tags/index.md","hash":"ec538006aeb8f6ad7dd75d445bb499f9ce8ea25e","modified":1505212450000},{"_id":"themes/next/.git/HEAD","hash":"1bcd5383a9864f5ee3432bfdb6af25b32d5d6ed5","modified":1505209973000},{"_id":"themes/next/.git/config","hash":"510faaf0899b89e8a0a0a7ebeff0d4b0aa5ad38f","modified":1505209750000},{"_id":"source/_posts/为什么parseInt(0-0000008)-===-8？.md","hash":"555c26bb8516b5d80282bb02438a01858119e3b8","modified":1505454758000},{"_id":"themes/next/.git/index","hash":"f59b3e41332a32f75ae3965a896f16704568232a","modified":1510293715000},{"_id":"source/images/avatar.jpg","hash":"6e0e61c0c775c5369832922bd7249c4998165ed6","modified":1506483606000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1505209748000},{"_id":"themes/next/.git/packed-refs","hash":"f5c4832504bc7eda7ccdbdbddf1e40dd214e857b","modified":1505209760000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1505209973000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1505209973000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1505209973000},{"_id":"source/_posts/手写JSONP-promise封装.md","hash":"ebe907484bcc380a830d4701d12e0ea1ac1fbef9","modified":1507966961000},{"_id":"themes/next/languages/en.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1505209973000},{"_id":"themes/next/languages/default.yml","hash":"95ec5cdfb563854f231b76162a3494f6ecc5bf61","modified":1505209973000},{"_id":"themes/next/languages/fr-FR.yml","hash":"e98f1558347752a20019b71f0b1f9c8be1b34f42","modified":1505209973000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1505209973000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1505209973000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1505209973000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1505209973000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1505209973000},{"_id":"themes/next/languages/ru.yml","hash":"5022885d8955e1b91d8841048db272bf99c59a76","modified":1505209973000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"40d01dc46d57f71c2ef635c45b295d4355456e90","modified":1505209973000},{"_id":"themes/next/languages/zh-hk.yml","hash":"19c23d21f262e24c06ee6ddfd51d2a6585304f88","modified":1505209973000},{"_id":"themes/next/languages/zh-tw.yml","hash":"68407799271c78ecc07f03d238257dd8c65ad42d","modified":1505209973000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1505209973000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1505209973000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1505209973000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1505209973000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1505209973000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1505209973000},{"_id":"themes/next/scripts/merge-configs.js","hash":"13c8b3a2d9fce06c2488820d9248d190c8100e0a","modified":1505209760000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1505209760000},{"_id":"themes/next/layout/_layout.swig","hash":"2c0c3547a5b470024326a33ae2779d5ee0252266","modified":1505209973000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1505209973000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1505209760000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1505209760000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1505209760000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1505209748000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1505209748000},{"_id":"source/categories/index.md","hash":"5405aa4036c7346850b594a45e5e5bc4a8994322","modified":1508062710000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1505209748000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1505209748000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1505209748000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1505209748000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1505209748000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1505209748000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1505209748000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1505209748000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1505209760000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1505209760000},{"_id":"themes/next/.git/logs/HEAD","hash":"e0d0171d043fd5bc4ff95e8196386b5f8d00313f","modified":1505209973000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1505209973000},{"_id":"themes/next/layout/_macro/post.swig","hash":"2c2efe44ea013030f3ce5da7bfdeddb74489eb6e","modified":1505209973000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1505209973000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1505209748000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1505209760000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"b57650032ed47b8bd357ec4dcc02d872fdd0e3e1","modified":1505209973000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1505209973000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1505209973000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1505209760000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1505209973000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"970aa668680896262b1056bb5787fc9ec8754495","modified":1505209973000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1505209973000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1505209760000},{"_id":"themes/next/layout/_partials/head.swig","hash":"a0eafe24d1dae30c790ae35612154b3ffbbd5cce","modified":1505209973000},{"_id":"themes/next/layout/_partials/header.swig","hash":"a1ffbb691dfad3eaf2832a11766e58a179003b8b","modified":1505209760000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1505209760000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1505209760000},{"_id":"themes/next/layout/_partials/search.swig","hash":"7b61e96508df70152b809ea5354236ab7f0d54f4","modified":1505209973000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1505209760000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1505209760000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1505209760000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"79378f3a1cd90518b07808ed09156a3ab55ffa31","modified":1505209973000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1505209973000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1505209760000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1505209760000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1505209973000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1505209760000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1505209760000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1505209760000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1505209760000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1505209760000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1505209760000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1505209760000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1505209760000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1505209760000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1505209760000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1505209760000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1505209760000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1505209760000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1505209760000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1505209973000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1505209760000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"e46900412e28f529c26e25e6bada342006435a32","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"a279e1881208aff2f669fe235e9661ab825bc540","modified":1505209973000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1505209760000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"ceb39c100c99900294ddee8b1ff81fcaf43873b5","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1505209973000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1505209760000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1505209973000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1505209760000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1505209760000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"741f09b2ba4e440011c15f5d288b109b82c87f1b","modified":1505209973000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1505209760000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1505209760000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1505209760000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1505209760000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1505209760000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1505209760000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1505209760000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"06f432f328a5b8a9ef0dbd5301b002aba600b4ce","modified":1505209973000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"e7c76d93605e2b685274400afe51c55cc651486e","modified":1505209973000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1505209973000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1505209973000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1505209760000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"54ca0acff29a414e2c1b7c1790db22f0c775604c","modified":1505209973000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1505209973000},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1505209760000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1505209760000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1505209973000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1505209760000},{"_id":"themes/next/source/js/src/post-details.js","hash":"3b2d64c2e6ae072ba2a9ebf7f09908a1543abd58","modified":1505209973000},{"_id":"themes/next/source/js/src/utils.js","hash":"9ff232a2d39a513b811814480502e3eaac429c52","modified":1505209973000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1505209760000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1505209760000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1505209760000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1505209760000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1505209973000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1505209760000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1505209760000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1505209760000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1505209760000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1505209760000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1505209760000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1505209760000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1505209760000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1505209760000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1505209760000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1505209760000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1505209760000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1505209760000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1505209760000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1505209760000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1505209973000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1505209760000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-mta.swig","hash":"a652f202bd5b30c648c228ab8f0e997eb4928e44","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/comments/livere.swig","hash":"7240f2e5ec7115f8abbbc4c9ef73d4bed180fdc7","modified":1505209973000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"af9dd8a4aed7d06cf47b363eebff48850888566c","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"59ad08bcc6fe9793594869ac2b4c525021453e78","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"ef089a407c90e58eca10c49bc47ec978f96e03ba","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1505209760000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"7804e31c44717c9a9ddf0f8482b9b9c1a0f74538","modified":1505209973000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1505209760000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1505209760000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1505209973000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1505209760000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"f15537cee1a9ef4fa1e72a1670ebce4097db8115","modified":1505209973000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"e3e23751d4ad24e8714b425d768cf68e37de7ded","modified":1505209760000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1505209760000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"79da92119bc246fe05d1626ac98426a83ec90a94","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1505209760000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1505209760000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1505209973000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1505209973000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1505209760000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1505209973000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1505209973000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1505209973000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1505209973000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"43541e777eaa86c69b5c3cec49b5acbef5998007","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"755b04edbbfbdd981a783edb09c9cc34cb79cea7","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"beccb53dcd658136fb91a0c5678dea8f37d6e0b6","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"b9a2e76f019a5941191f1263b54aef7b69c48789","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a2ec22ef4a6817bbb2abe8660fcd99fe4ca0cc5e","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"8fe1e55bc290e6aaf07cc644fe27b62107a272a8","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1505209973000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1505209760000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"173490e21bece35a34858e8e534cf86e34561350","modified":1505209973000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1505209973000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1505209973000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1505209760000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1505209973000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1505209760000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1505209760000},{"_id":"themes/next/.git/objects/pack/pack-411c3c2fbb4ea9a449779fd8cf5a8dcf0c1958fb.idx","hash":"9d6f552709bb892b65e764100d2bf88a27b35fc6","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1505209973000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1505209760000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1505209973000},{"_id":"themes/next/.git/objects/pack/pack-411c3c2fbb4ea9a449779fd8cf5a8dcf0c1958fb.pack","hash":"ca1a3c04da7c677c3cc263c6380cce53ab6d43d5","modified":1505209760000}],"Category":[{"name":"JavaScript","_id":"cj9thw9di0002e6vmv69wtdcf"},{"name":"总结","parent":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9dn0006e6vmk7fzwjzu"},{"name":"后端","_id":"cj9thw9ey000je6vm3l3oyowd"},{"name":"服务端渲染","_id":"cj9thw9f5000pe6vmhv6406v2"},{"name":"vue","parent":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9g8000ue6vm2gv8eitm"},{"name":"备忘录","parent":"cj9thw9ey000je6vm3l3oyowd","_id":"cj9thw9gg0015e6vmi3zriddi"},{"name":"leetcode算法题","_id":"cj9thw9gl001ee6vmr9kxk9eq"},{"name":"http","_id":"cj9thw9gu0021e6vmnaao5ngv"},{"name":"冷门","parent":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9gv0027e6vmh6ce7fzz"}],"Data":[],"Page":[{"title":"标签tags","type":"tags","date":"2017-09-12T10:18:37.000Z","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签tags\ntype: \"tags\"\ndate: 2017-09-12 18:18:37\n---\n","updated":"2017-09-12T10:34:10.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj9thw9ev000fe6vmmimucuz2","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"大概分类(有点乱, 将就看)","date":"2017-10-15T10:13:46.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 大概分类(有点乱, 将就看)\ndate: 2017-10-15 18:13:46\ntype: \"categories\"\n---\n","updated":"2017-10-15T10:18:30.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj9thw9qt002te6vmtdak20vz","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"javascript常用工具函数总结","author":"Token","date":"2017-09-12T08:18:00.000Z","_content":"#### 前言\n* 以下代码来自：自己写的、工作项目框架上用到的、其他框架源码上的、网上看到的。\n* 主要是作为工具函数，服务于框架业务，自身不依赖于其他框架类库，部分使用到es6/es7的语法使用时要注意转码\n* 虽然尽量在函数中做了错误情况的处理，仍有可能出现报错的情况(不定期完善)\n##### 1. 获取url上的参数\n```\n  /**\n   *获取url上的参数\n   * @return {object}\n   * @example\n   * getRequest()  getRequest().paramA\n   */\nfunction getRequest() {\n    var searchString = window.location.search.substring(1),\n        params = searchString.split(\"&\"),\n        hash = {};\n    if (searchString == \"\") return {};\n    for (var i = 0; i < params.length; i++) {\n        var pos = params[i].indexOf('=');\n        if (pos == -1) { continue; }\n        var paraName = params[i].substring(0, pos),\n            paraValue = params[i].substring(pos + 1);\n        hash[paraName] = paraValue;\n    }\n    return hash;\n}\n```\n* 返回一个对象，将url上的参数以键值对的形式存储在返回结果中，如果url上没参数，则返回空对象\n##### 2. 追加url参数\n```\n  /**\n   * 追加url参数\n   * @param {string} url url参数\n   * @param {string|object} key 名字或者对象\n   * @param {string} value 值\n   * @return {string} 返回新的url\n   * @example\n   * appendQuery('lechebang.com', 'id', 3);\n   * appendQuery('lechebang.com?key=value', { cityId: 2, cityName: '北京'});\n   */\n  function appendQuery (url, key, value) {\n    var options = key;\n    if (typeof options == 'string') {\n      options = {};\n      options[key] = value;\n    }\n    options = $.param(options);\n    if (url.includes('?')) {\n      url += '&' + options\n    } else {\n      url += '?' + options\n    }\n    return url;\n  }\n```\n* 传入一个url和需要添加的参数键值对，需添加的参数可以直接传对象格式。会判断原url上是否有参数，没有的话就加'?'，返回添加参数后的url。\n##### 3. 计算两个日期的时间差\n```\n  /**\n   * 计算两个日期时间的时间差\n   * @param {Date, Date}  date1 date2\n   * @return {object | null} \n   * @example\n   * getDiff(new Date('2017-09-08'), new Date())\n   */\nfunction getDiff(date1, date2) {\n     if (!date1.getTime || !date2.getTime) return null\n     var ms = (date1.getTime() - date2.getTime());\n     var day1 = Math.round(ms / 24 / 3600 / 1000),\n         hh1 = Math.round((ms / 3600 / 1000) % 24),\n         mm1 = Math.round((ms / 1000 / 60) % 60),\n         ss1 = Math.round((ms / 1000) % 60);\n     return {\n         day: day1,\n         hour: hh1,\n         minute: mm1,\n         second: ss1\n      };\n}\n```\n* 传入两个Date日期对象，返回一个对象，其属性值day、hour、minute、second分别表示相差天数、小时、分钟、秒。结果以Math.round()取整，如果结果为负，则表示第一个日期在第二个日期前面\n##### 4. 将canvas转化为image图片格式\n```\n  /**\n   * 将canvas转化为image格式\n   * @param {string}  cId\n   * @return {object HTMLImageElement} \n   * @example\n   * canvasToImg('canvas')  canvasToImg('#canvarsId')\n   */\nfunction canvasToImg(cId){\n    let canvas = document.querySelector(cId)\n    if (!canvas || !canvas.toDataURL) return new Image()\n    let imgData = canvas.toDataURL('image/png'),\n        imgs= new Image();\n        imgs.src=imgData;\n    return imgs\n}\n```\n* 传入一个css选择器，函数根据选择器查询canvas节点，然后返回该canvas的image格式节点，如果查找不到则返回一个空的image。原理是将canvas转化为base64编码，toDataURL方法貌似是canvas节点独有的，然后新建一个src是这个base64编码的图片。\n* ps:什么情况下需要做这种转换呢？目前我知道的一个就是canvas在移动端无法长按保存到手机。\n##### 5. 生成随机guid\n```\n  /**\n   * 生成一个唯一的guid\n   * @return {string}\n   * @example\n   * // 7f603b20-17ff-4f47-aeb9-e7996de04939\n   * util.guid();\n   * @see http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n   */\n  function guid () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    });\n  }\n```\n* 这个方法用于生成一个随机[guid](https://baike.baidu.com/item/GUID/3352285?fr=aladdin)，可以将生成的guid视为全局唯一的(生成两个相同id的情况很少)。guid似乎在前端用的比较少，目前项目用到就是在每次请求后端接口时调用此方法，生成一个guid传过去。\n##### 6. 获取一个月份的天数\n```\n  function isLeapYear (year) {\n    if (year % 100 === 0) {\n      if (year % 400 === 0) {\n        return true;\n      }\n    } else if (year % 4 === 0) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * 获取某个月份有多少天\n   * @return {number}\n   * @param {string | number}  year month\n   * @example\n   * getDaysInMonth(2017, 9)\n   */\n  function getDaysInMonth (year, month) {\n    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n  }\n```\n* 传入一个年份和月份，返回该月有多少天，其中也包含了一个isLeapYear方法来判断是否是闰年，应该在实现日历或者日期选择组件时用的到\n##### 7. 过滤对象属性\n```\n  /**\n   * 过滤选出一个对象的某些属性\n   * @param{object, array} obj key\n   * @return{object}\n   * @example\n   * pick(obj, [key1, key2])\n   */\n  function pick (obj, keys) {\n    let result = {}\n    if (!obj || !keys.forEach) {\n      return result\n    }\n    keys.forEach((item) => {\n      if (obj.hasOwnProperty(item)) {\n        result[item] = obj[item]\n      }\n    })\n    return result\n  }\n```\n* 传入一个对象和一个数组，遍历数组，如果传入对象有数组中包含的属性，则提取出来，返回一个过滤提取出来的属性组成的对象。\n* 这个方法用处挺多的，比如从一个接口拿到了结果对象，可能上面很多属性你暂时用不到的，就可以用这个方法进行过滤。比如以前我用vue写项目的时候，就经常把接口返回的一个对象作为vue的data属性去渲染页面，这个时候这个对象是动态绑定在vue实例上面的，但是其中有些属性页面渲染根本用不到，还得去监听这些属性，白白浪费性能，这种时候将接口返回的对象筛选一下再赋给vue的data就显得合理多了。\n##### 8. 判断是否是一个对象\n```\n  /**\n   * 判断传入参数是否是一个合法对象\n   * @param{object} obj \n   * @return{object}\n   * @example\n   * isObject (null) isObject (() => {} )\n   */\nfunction isObject (obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  }\n```\n* 判断传入参数是否是一个合法对象，function类型均返回true，null返回false(typeof null 返回 object)\n##### 9. 判断一个函数是否是native code\n```\n  /**\n   * 判断传入函数是否在当前环境下得到支持\n   * @param{function} Ctor \n   * @return{boolean}\n   * @example\n   * isNative (window.Symbol)  isNative (window.Promise)\n   */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n```\n* javascript原生自带的方法使用toString转成字符串时会包含‘native code’字段，比如Math.max.toString()就返回\"function max() { [native code] }\"。\n* 这个方法可以判断某些原生特性是否被当前浏览器支持。比如isNative (window.Promise)在chrome中返回true，因为chrome支持原生es6语法，放到ie里面就只能返回false了~\n##### 10. 深度克隆对象\n```\n  /**\n   * 返回传入对象的一个深度克隆的副本对象\n   * @param{object} obj \n   * @return{object}\n   * @example\n   * cloneDeep(obj)\n   */\n  function cloneDeep (obj) {\n    if (!isObject(obj)) return obj;\n    let result\n    if (Array.isArray(obj)) {\n      result = []\n      obj.forEach((item) => {\n        result.push(cloneDeep(item))\n      })\n      return result\n    }\n    result = {}\n    for (let key in obj) {\n      let item = obj[key]\n      if (_.isObject(item)) {\n        result[key] = cloneDeep(item)\n      } else {\n        result[key] = item\n      }\n    }\n\n    return result\n  }\n```\n* 首先对传入参数进行判断，不是合法对象则直接返回其本身。然后再遍历其属性，属性中包含对象的会再次递归调用cloneDeep方法，浅克隆的话可以直接用Object.assign()方法。\n##### 11. 获取两个地点的实际距离\n```\n/**\n   * 获取两个高德坐标的距离, 后一个点，不传，默认为用户坐标\n   * @return {null|number} 距离多少米，没有定位信息，返回null\n   * @example\n   * getDistance(31.282055633974, 121.379623888259)\n   */\n  function getDistance (endLat, endLon, startLat, startLon) {\n    if (!startLat) {\n      let address = Lizard.state.address\n\n      if (address && address.lat) {\n        startLat = address.lat\n        startLon = address.lon\n      }\n    }\n\n    // 没有定位\n    if (!startLat) {\n      return null\n    }\n\n    const PI = Math.PI\n    let lon1 = (PI / 180) * startLon\n    let lon2 = (PI / 180) * endLon \n    let lat1 = (PI / 180) * startLat  \n    let lat2 = (PI / 180) * endLat \n    // 地球半径  \n    let R = 6378.137;  \n\n    // 两点间距离 km，如果想要米的话，结果*1000就可以了  \n    let d = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)) * R;  \n\n    return parseInt(d * 1000, 10)\n  }\n```\n* 依次传入两个点的经纬度，然后计算得出两个点的距离，单位为km。这个方法可能实际应用的比较少，我这里还是写出来，作为一种前端计算距离的方法(在能拿得到定位的情况下)。\n##### 12. 加载图片(promise封装)\n```\n/**\n   * 传入图片url，返回一个promise对象，加载成功时resolve\n   * @return {Promise} \n   * @example\n   * loadImg(url).then(console.log('加载完成')).catch(err => {console.log(err)})\n   */\n  function loadImg (url) {\n    return new Promise((resolve, reject) => {\n      let img = new Image()\n\n      img.addEventListener('load', function() {\n        resolve([img.width, img.height])\n      }, false)\n\n      img.addEventListener('error', reject, false)\n\n      img.src = url\n    })\n  }\n ```\n* 这个函数参考自ECMAScript 6 入门，算是promise的一个很经典的应用实例，加载完成后promise对象resolve，同时返回图片的宽高，以便后面调整样式等等。加载失败则返回reject，所以再调用这个方法后需要用catch方法来捕捉异常。\n##### 13. 重复字符串n次\n```\n/**\n   * 传入字符串，和重复次数，返回结果字符串\n   * @return {string} \n   * @param{string, number} str n \n   * @example\n   * loadImg(url).then(console.log('加载完成')).catch(err => {console.log(err)})\n   */\n  const repeat = (str, n) => {\n    let res = ''\n    while (n) {\n      if (n % 2 === 1) res += str\n      if (n > 1) str += str\n      n >>= 1\n    }\n    return res\n  }\n```\n* 这个函数在vue源码里看到的，用到了位运算符，如果让我来实现的话可能就马上想到重复n次，而上面这个函数执行时的时间复杂度差不多只是n/2。\n##### 14. 变量是否以'$'或者'_'开头\n```\n/**\n   * 传入字符串，判断是否以'$'或者'_'开头\n   * @return {Boolean} \n   * @param{string} str\n   * @example\n   * isReserved (‘$’)  isReserved (‘param’)\n   */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n```\n* 同样是vue源码里的方法，判断变量是否以'$'或者'_'开头，charCodeAt(index)方法会返回字符串对应index位置的字符的Unicode编码，'$'对应的Unicode编码就是36，这里用的是十六进制表示方法就是0x24。要判断变量名以什么字符开头或结尾，将上面方法略微修改即可实现。\n* ps：vue中哪里用到这个方法了呢，我去看了下就是在初始化vue实例的data对象时会判断，如果你的vue实例data里面命名了以'$'或者'_'的对象，是不会把这个属性重新定义其get/set的。简单点说，如果你在vue的data里定义一个命名为$data的属性，再在模板里渲染{{$data}}，就会报错的。\n##### 15. promise扩展-finally\n```\n/**\n   * 在一个promise链调用结尾调用finally，传入一个函数，无论最后promise的状态是什么总会执行该函数\n   * @param{function} callback\n   * @example\n   *  server.listen(0).then(function () { // run test }).finally(server.stop);\n   */\nPromise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value).catch(e => {console.error(e)}),\n    reason => P.resolve(callback()).then(() => { throw reason }).catch(e => {console.error(e)})\n  );\n};\n```\n* 参考自[ECMAScript 6 入门](http://es6.ruanyifeng.com/?search=find&x=0&y=0)，对于promise对象的一个扩展方法，不论前面的promise状态是什么总会调用callback函数。\n* 我在原代码的基础上添加了新的catch，用于兼容callback执行时返回了一个状态为reject的promise的情况。\n#### 结语\n* 再次补充，已搬运到[github博客](https://tokenyangforever.github.io/2017/09/12/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/)，上面自带导航~~~","source":"_posts/JavaScript中常用工具函数.md","raw":"title: javascript常用工具函数总结\ntags:\n  - JavaScript\n  - 总结\ncategories:\n  - JavaScript\n  - 总结\nauthor: Token\ndate: 2017-09-12 16:18:00\n---\n#### 前言\n* 以下代码来自：自己写的、工作项目框架上用到的、其他框架源码上的、网上看到的。\n* 主要是作为工具函数，服务于框架业务，自身不依赖于其他框架类库，部分使用到es6/es7的语法使用时要注意转码\n* 虽然尽量在函数中做了错误情况的处理，仍有可能出现报错的情况(不定期完善)\n##### 1. 获取url上的参数\n```\n  /**\n   *获取url上的参数\n   * @return {object}\n   * @example\n   * getRequest()  getRequest().paramA\n   */\nfunction getRequest() {\n    var searchString = window.location.search.substring(1),\n        params = searchString.split(\"&\"),\n        hash = {};\n    if (searchString == \"\") return {};\n    for (var i = 0; i < params.length; i++) {\n        var pos = params[i].indexOf('=');\n        if (pos == -1) { continue; }\n        var paraName = params[i].substring(0, pos),\n            paraValue = params[i].substring(pos + 1);\n        hash[paraName] = paraValue;\n    }\n    return hash;\n}\n```\n* 返回一个对象，将url上的参数以键值对的形式存储在返回结果中，如果url上没参数，则返回空对象\n##### 2. 追加url参数\n```\n  /**\n   * 追加url参数\n   * @param {string} url url参数\n   * @param {string|object} key 名字或者对象\n   * @param {string} value 值\n   * @return {string} 返回新的url\n   * @example\n   * appendQuery('lechebang.com', 'id', 3);\n   * appendQuery('lechebang.com?key=value', { cityId: 2, cityName: '北京'});\n   */\n  function appendQuery (url, key, value) {\n    var options = key;\n    if (typeof options == 'string') {\n      options = {};\n      options[key] = value;\n    }\n    options = $.param(options);\n    if (url.includes('?')) {\n      url += '&' + options\n    } else {\n      url += '?' + options\n    }\n    return url;\n  }\n```\n* 传入一个url和需要添加的参数键值对，需添加的参数可以直接传对象格式。会判断原url上是否有参数，没有的话就加'?'，返回添加参数后的url。\n##### 3. 计算两个日期的时间差\n```\n  /**\n   * 计算两个日期时间的时间差\n   * @param {Date, Date}  date1 date2\n   * @return {object | null} \n   * @example\n   * getDiff(new Date('2017-09-08'), new Date())\n   */\nfunction getDiff(date1, date2) {\n     if (!date1.getTime || !date2.getTime) return null\n     var ms = (date1.getTime() - date2.getTime());\n     var day1 = Math.round(ms / 24 / 3600 / 1000),\n         hh1 = Math.round((ms / 3600 / 1000) % 24),\n         mm1 = Math.round((ms / 1000 / 60) % 60),\n         ss1 = Math.round((ms / 1000) % 60);\n     return {\n         day: day1,\n         hour: hh1,\n         minute: mm1,\n         second: ss1\n      };\n}\n```\n* 传入两个Date日期对象，返回一个对象，其属性值day、hour、minute、second分别表示相差天数、小时、分钟、秒。结果以Math.round()取整，如果结果为负，则表示第一个日期在第二个日期前面\n##### 4. 将canvas转化为image图片格式\n```\n  /**\n   * 将canvas转化为image格式\n   * @param {string}  cId\n   * @return {object HTMLImageElement} \n   * @example\n   * canvasToImg('canvas')  canvasToImg('#canvarsId')\n   */\nfunction canvasToImg(cId){\n    let canvas = document.querySelector(cId)\n    if (!canvas || !canvas.toDataURL) return new Image()\n    let imgData = canvas.toDataURL('image/png'),\n        imgs= new Image();\n        imgs.src=imgData;\n    return imgs\n}\n```\n* 传入一个css选择器，函数根据选择器查询canvas节点，然后返回该canvas的image格式节点，如果查找不到则返回一个空的image。原理是将canvas转化为base64编码，toDataURL方法貌似是canvas节点独有的，然后新建一个src是这个base64编码的图片。\n* ps:什么情况下需要做这种转换呢？目前我知道的一个就是canvas在移动端无法长按保存到手机。\n##### 5. 生成随机guid\n```\n  /**\n   * 生成一个唯一的guid\n   * @return {string}\n   * @example\n   * // 7f603b20-17ff-4f47-aeb9-e7996de04939\n   * util.guid();\n   * @see http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n   */\n  function guid () {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n      var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n      return v.toString(16);\n    });\n  }\n```\n* 这个方法用于生成一个随机[guid](https://baike.baidu.com/item/GUID/3352285?fr=aladdin)，可以将生成的guid视为全局唯一的(生成两个相同id的情况很少)。guid似乎在前端用的比较少，目前项目用到就是在每次请求后端接口时调用此方法，生成一个guid传过去。\n##### 6. 获取一个月份的天数\n```\n  function isLeapYear (year) {\n    if (year % 100 === 0) {\n      if (year % 400 === 0) {\n        return true;\n      }\n    } else if (year % 4 === 0) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * 获取某个月份有多少天\n   * @return {number}\n   * @param {string | number}  year month\n   * @example\n   * getDaysInMonth(2017, 9)\n   */\n  function getDaysInMonth (year, month) {\n    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n  }\n```\n* 传入一个年份和月份，返回该月有多少天，其中也包含了一个isLeapYear方法来判断是否是闰年，应该在实现日历或者日期选择组件时用的到\n##### 7. 过滤对象属性\n```\n  /**\n   * 过滤选出一个对象的某些属性\n   * @param{object, array} obj key\n   * @return{object}\n   * @example\n   * pick(obj, [key1, key2])\n   */\n  function pick (obj, keys) {\n    let result = {}\n    if (!obj || !keys.forEach) {\n      return result\n    }\n    keys.forEach((item) => {\n      if (obj.hasOwnProperty(item)) {\n        result[item] = obj[item]\n      }\n    })\n    return result\n  }\n```\n* 传入一个对象和一个数组，遍历数组，如果传入对象有数组中包含的属性，则提取出来，返回一个过滤提取出来的属性组成的对象。\n* 这个方法用处挺多的，比如从一个接口拿到了结果对象，可能上面很多属性你暂时用不到的，就可以用这个方法进行过滤。比如以前我用vue写项目的时候，就经常把接口返回的一个对象作为vue的data属性去渲染页面，这个时候这个对象是动态绑定在vue实例上面的，但是其中有些属性页面渲染根本用不到，还得去监听这些属性，白白浪费性能，这种时候将接口返回的对象筛选一下再赋给vue的data就显得合理多了。\n##### 8. 判断是否是一个对象\n```\n  /**\n   * 判断传入参数是否是一个合法对象\n   * @param{object} obj \n   * @return{object}\n   * @example\n   * isObject (null) isObject (() => {} )\n   */\nfunction isObject (obj) {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n  }\n```\n* 判断传入参数是否是一个合法对象，function类型均返回true，null返回false(typeof null 返回 object)\n##### 9. 判断一个函数是否是native code\n```\n  /**\n   * 判断传入函数是否在当前环境下得到支持\n   * @param{function} Ctor \n   * @return{boolean}\n   * @example\n   * isNative (window.Symbol)  isNative (window.Promise)\n   */\nfunction isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n```\n* javascript原生自带的方法使用toString转成字符串时会包含‘native code’字段，比如Math.max.toString()就返回\"function max() { [native code] }\"。\n* 这个方法可以判断某些原生特性是否被当前浏览器支持。比如isNative (window.Promise)在chrome中返回true，因为chrome支持原生es6语法，放到ie里面就只能返回false了~\n##### 10. 深度克隆对象\n```\n  /**\n   * 返回传入对象的一个深度克隆的副本对象\n   * @param{object} obj \n   * @return{object}\n   * @example\n   * cloneDeep(obj)\n   */\n  function cloneDeep (obj) {\n    if (!isObject(obj)) return obj;\n    let result\n    if (Array.isArray(obj)) {\n      result = []\n      obj.forEach((item) => {\n        result.push(cloneDeep(item))\n      })\n      return result\n    }\n    result = {}\n    for (let key in obj) {\n      let item = obj[key]\n      if (_.isObject(item)) {\n        result[key] = cloneDeep(item)\n      } else {\n        result[key] = item\n      }\n    }\n\n    return result\n  }\n```\n* 首先对传入参数进行判断，不是合法对象则直接返回其本身。然后再遍历其属性，属性中包含对象的会再次递归调用cloneDeep方法，浅克隆的话可以直接用Object.assign()方法。\n##### 11. 获取两个地点的实际距离\n```\n/**\n   * 获取两个高德坐标的距离, 后一个点，不传，默认为用户坐标\n   * @return {null|number} 距离多少米，没有定位信息，返回null\n   * @example\n   * getDistance(31.282055633974, 121.379623888259)\n   */\n  function getDistance (endLat, endLon, startLat, startLon) {\n    if (!startLat) {\n      let address = Lizard.state.address\n\n      if (address && address.lat) {\n        startLat = address.lat\n        startLon = address.lon\n      }\n    }\n\n    // 没有定位\n    if (!startLat) {\n      return null\n    }\n\n    const PI = Math.PI\n    let lon1 = (PI / 180) * startLon\n    let lon2 = (PI / 180) * endLon \n    let lat1 = (PI / 180) * startLat  \n    let lat2 = (PI / 180) * endLat \n    // 地球半径  \n    let R = 6378.137;  \n\n    // 两点间距离 km，如果想要米的话，结果*1000就可以了  \n    let d = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)) * R;  \n\n    return parseInt(d * 1000, 10)\n  }\n```\n* 依次传入两个点的经纬度，然后计算得出两个点的距离，单位为km。这个方法可能实际应用的比较少，我这里还是写出来，作为一种前端计算距离的方法(在能拿得到定位的情况下)。\n##### 12. 加载图片(promise封装)\n```\n/**\n   * 传入图片url，返回一个promise对象，加载成功时resolve\n   * @return {Promise} \n   * @example\n   * loadImg(url).then(console.log('加载完成')).catch(err => {console.log(err)})\n   */\n  function loadImg (url) {\n    return new Promise((resolve, reject) => {\n      let img = new Image()\n\n      img.addEventListener('load', function() {\n        resolve([img.width, img.height])\n      }, false)\n\n      img.addEventListener('error', reject, false)\n\n      img.src = url\n    })\n  }\n ```\n* 这个函数参考自ECMAScript 6 入门，算是promise的一个很经典的应用实例，加载完成后promise对象resolve，同时返回图片的宽高，以便后面调整样式等等。加载失败则返回reject，所以再调用这个方法后需要用catch方法来捕捉异常。\n##### 13. 重复字符串n次\n```\n/**\n   * 传入字符串，和重复次数，返回结果字符串\n   * @return {string} \n   * @param{string, number} str n \n   * @example\n   * loadImg(url).then(console.log('加载完成')).catch(err => {console.log(err)})\n   */\n  const repeat = (str, n) => {\n    let res = ''\n    while (n) {\n      if (n % 2 === 1) res += str\n      if (n > 1) str += str\n      n >>= 1\n    }\n    return res\n  }\n```\n* 这个函数在vue源码里看到的，用到了位运算符，如果让我来实现的话可能就马上想到重复n次，而上面这个函数执行时的时间复杂度差不多只是n/2。\n##### 14. 变量是否以'$'或者'_'开头\n```\n/**\n   * 传入字符串，判断是否以'$'或者'_'开头\n   * @return {Boolean} \n   * @param{string} str\n   * @example\n   * isReserved (‘$’)  isReserved (‘param’)\n   */\nfunction isReserved (str) {\n  var c = (str + '').charCodeAt(0);\n  return c === 0x24 || c === 0x5F\n}\n```\n* 同样是vue源码里的方法，判断变量是否以'$'或者'_'开头，charCodeAt(index)方法会返回字符串对应index位置的字符的Unicode编码，'$'对应的Unicode编码就是36，这里用的是十六进制表示方法就是0x24。要判断变量名以什么字符开头或结尾，将上面方法略微修改即可实现。\n* ps：vue中哪里用到这个方法了呢，我去看了下就是在初始化vue实例的data对象时会判断，如果你的vue实例data里面命名了以'$'或者'_'的对象，是不会把这个属性重新定义其get/set的。简单点说，如果你在vue的data里定义一个命名为$data的属性，再在模板里渲染{{$data}}，就会报错的。\n##### 15. promise扩展-finally\n```\n/**\n   * 在一个promise链调用结尾调用finally，传入一个函数，无论最后promise的状态是什么总会执行该函数\n   * @param{function} callback\n   * @example\n   *  server.listen(0).then(function () { // run test }).finally(server.stop);\n   */\nPromise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  => P.resolve(callback()).then(() => value).catch(e => {console.error(e)}),\n    reason => P.resolve(callback()).then(() => { throw reason }).catch(e => {console.error(e)})\n  );\n};\n```\n* 参考自[ECMAScript 6 入门](http://es6.ruanyifeng.com/?search=find&x=0&y=0)，对于promise对象的一个扩展方法，不论前面的promise状态是什么总会调用callback函数。\n* 我在原代码的基础上添加了新的catch，用于兼容callback执行时返回了一个状态为reject的promise的情况。\n#### 结语\n* 再次补充，已搬运到[github博客](https://tokenyangforever.github.io/2017/09/12/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/)，上面自带导航~~~","slug":"JavaScript中常用工具函数","published":1,"updated":"2017-10-16T02:19:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9d40000e6vme7z2rw5a","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>以下代码来自：自己写的、工作项目框架上用到的、其他框架源码上的、网上看到的。</li>\n<li>主要是作为工具函数，服务于框架业务，自身不依赖于其他框架类库，部分使用到es6/es7的语法使用时要注意转码</li>\n<li><p>虽然尽量在函数中做了错误情况的处理，仍有可能出现报错的情况(不定期完善)</p>\n<h5 id=\"1-获取url上的参数\"><a href=\"#1-获取url上的参数\" class=\"headerlink\" title=\"1. 获取url上的参数\"></a>1. 获取url上的参数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   *获取url上的参数</div><div class=\"line\">   * @return &#123;object&#125;</div><div class=\"line\">   * @example</div><div class=\"line\">   * getRequest()  getRequest().paramA</div><div class=\"line\">   */</div><div class=\"line\">function getRequest() &#123;</div><div class=\"line\">    var searchString = window.location.search.substring(1),</div><div class=\"line\">        params = searchString.split(&quot;&amp;&quot;),</div><div class=\"line\">        hash = &#123;&#125;;</div><div class=\"line\">    if (searchString == &quot;&quot;) return &#123;&#125;;</div><div class=\"line\">    for (var i = 0; i &lt; params.length; i++) &#123;</div><div class=\"line\">        var pos = params[i].indexOf(&apos;=&apos;);</div><div class=\"line\">        if (pos == -1) &#123; continue; &#125;</div><div class=\"line\">        var paraName = params[i].substring(0, pos),</div><div class=\"line\">            paraValue = params[i].substring(pos + 1);</div><div class=\"line\">        hash[paraName] = paraValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return hash;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>返回一个对象，将url上的参数以键值对的形式存储在返回结果中，如果url上没参数，则返回空对象</p>\n<h5 id=\"2-追加url参数\"><a href=\"#2-追加url参数\" class=\"headerlink\" title=\"2. 追加url参数\"></a>2. 追加url参数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 追加url参数</div><div class=\"line\"> * @param &#123;string&#125; url url参数</div><div class=\"line\"> * @param &#123;string|object&#125; key 名字或者对象</div><div class=\"line\"> * @param &#123;string&#125; value 值</div><div class=\"line\"> * @return &#123;string&#125; 返回新的url</div><div class=\"line\"> * @example</div><div class=\"line\"> * appendQuery(&apos;lechebang.com&apos;, &apos;id&apos;, 3);</div><div class=\"line\"> * appendQuery(&apos;lechebang.com?key=value&apos;, &#123; cityId: 2, cityName: &apos;北京&apos;&#125;);</div><div class=\"line\"> */</div><div class=\"line\">function appendQuery (url, key, value) &#123;</div><div class=\"line\">  var options = key;</div><div class=\"line\">  if (typeof options == &apos;string&apos;) &#123;</div><div class=\"line\">    options = &#123;&#125;;</div><div class=\"line\">    options[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\">  options = $.param(options);</div><div class=\"line\">  if (url.includes(&apos;?&apos;)) &#123;</div><div class=\"line\">    url += &apos;&amp;&apos; + options</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    url += &apos;?&apos; + options</div><div class=\"line\">  &#125;</div><div class=\"line\">  return url;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个url和需要添加的参数键值对，需添加的参数可以直接传对象格式。会判断原url上是否有参数，没有的话就加’?’，返回添加参数后的url。</p>\n<h5 id=\"3-计算两个日期的时间差\"><a href=\"#3-计算两个日期的时间差\" class=\"headerlink\" title=\"3. 计算两个日期的时间差\"></a>3. 计算两个日期的时间差</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 计算两个日期时间的时间差</div><div class=\"line\">   * @param &#123;Date, Date&#125;  date1 date2</div><div class=\"line\">   * @return &#123;object | null&#125; </div><div class=\"line\">   * @example</div><div class=\"line\">   * getDiff(new Date(&apos;2017-09-08&apos;), new Date())</div><div class=\"line\">   */</div><div class=\"line\">function getDiff(date1, date2) &#123;</div><div class=\"line\">     if (!date1.getTime || !date2.getTime) return null</div><div class=\"line\">     var ms = (date1.getTime() - date2.getTime());</div><div class=\"line\">     var day1 = Math.round(ms / 24 / 3600 / 1000),</div><div class=\"line\">         hh1 = Math.round((ms / 3600 / 1000) % 24),</div><div class=\"line\">         mm1 = Math.round((ms / 1000 / 60) % 60),</div><div class=\"line\">         ss1 = Math.round((ms / 1000) % 60);</div><div class=\"line\">     return &#123;</div><div class=\"line\">         day: day1,</div><div class=\"line\">         hour: hh1,</div><div class=\"line\">         minute: mm1,</div><div class=\"line\">         second: ss1</div><div class=\"line\">      &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入两个Date日期对象，返回一个对象，其属性值day、hour、minute、second分别表示相差天数、小时、分钟、秒。结果以Math.round()取整，如果结果为负，则表示第一个日期在第二个日期前面</p>\n<h5 id=\"4-将canvas转化为image图片格式\"><a href=\"#4-将canvas转化为image图片格式\" class=\"headerlink\" title=\"4. 将canvas转化为image图片格式\"></a>4. 将canvas转化为image图片格式</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 将canvas转化为image格式</div><div class=\"line\">   * @param &#123;string&#125;  cId</div><div class=\"line\">   * @return &#123;object HTMLImageElement&#125; </div><div class=\"line\">   * @example</div><div class=\"line\">   * canvasToImg(&apos;canvas&apos;)  canvasToImg(&apos;#canvarsId&apos;)</div><div class=\"line\">   */</div><div class=\"line\">function canvasToImg(cId)&#123;</div><div class=\"line\">    let canvas = document.querySelector(cId)</div><div class=\"line\">    if (!canvas || !canvas.toDataURL) return new Image()</div><div class=\"line\">    let imgData = canvas.toDataURL(&apos;image/png&apos;),</div><div class=\"line\">        imgs= new Image();</div><div class=\"line\">        imgs.src=imgData;</div><div class=\"line\">    return imgs</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个css选择器，函数根据选择器查询canvas节点，然后返回该canvas的image格式节点，如果查找不到则返回一个空的image。原理是将canvas转化为base64编码，toDataURL方法貌似是canvas节点独有的，然后新建一个src是这个base64编码的图片。</p>\n</li>\n<li><p>ps:什么情况下需要做这种转换呢？目前我知道的一个就是canvas在移动端无法长按保存到手机。</p>\n<h5 id=\"5-生成随机guid\"><a href=\"#5-生成随机guid\" class=\"headerlink\" title=\"5. 生成随机guid\"></a>5. 生成随机guid</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 生成一个唯一的guid</div><div class=\"line\"> * @return &#123;string&#125;</div><div class=\"line\"> * @example</div><div class=\"line\"> * // 7f603b20-17ff-4f47-aeb9-e7996de04939</div><div class=\"line\"> * util.guid();</div><div class=\"line\"> * @see http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript</div><div class=\"line\"> */</div><div class=\"line\">function guid () &#123;</div><div class=\"line\">  return &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;.replace(/[xy]/g, function(c) &#123;</div><div class=\"line\">    var r = Math.random()*16|0, v = c == &apos;x&apos; ? r : (r&amp;0x3|0x8);</div><div class=\"line\">    return v.toString(16);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这个方法用于生成一个随机<a href=\"https://baike.baidu.com/item/GUID/3352285?fr=aladdin\" target=\"_blank\" rel=\"external\">guid</a>，可以将生成的guid视为全局唯一的(生成两个相同id的情况很少)。guid似乎在前端用的比较少，目前项目用到就是在每次请求后端接口时调用此方法，生成一个guid传过去。</p>\n<h5 id=\"6-获取一个月份的天数\"><a href=\"#6-获取一个月份的天数\" class=\"headerlink\" title=\"6. 获取一个月份的天数\"></a>6. 获取一个月份的天数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function isLeapYear (year) &#123;</div><div class=\"line\">  if (year % 100 === 0) &#123;</div><div class=\"line\">    if (year % 400 === 0) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (year % 4 === 0) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;</div><div class=\"line\">/**</div><div class=\"line\"> * 获取某个月份有多少天</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> * @param &#123;string | number&#125;  year month</div><div class=\"line\"> * @example</div><div class=\"line\"> * getDaysInMonth(2017, 9)</div><div class=\"line\"> */</div><div class=\"line\">function getDaysInMonth (year, month) &#123;</div><div class=\"line\">  return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个年份和月份，返回该月有多少天，其中也包含了一个isLeapYear方法来判断是否是闰年，应该在实现日历或者日期选择组件时用的到</p>\n<h5 id=\"7-过滤对象属性\"><a href=\"#7-过滤对象属性\" class=\"headerlink\" title=\"7. 过滤对象属性\"></a>7. 过滤对象属性</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 过滤选出一个对象的某些属性</div><div class=\"line\"> * @param&#123;object, array&#125; obj key</div><div class=\"line\"> * @return&#123;object&#125;</div><div class=\"line\"> * @example</div><div class=\"line\"> * pick(obj, [key1, key2])</div><div class=\"line\"> */</div><div class=\"line\">function pick (obj, keys) &#123;</div><div class=\"line\">  let result = &#123;&#125;</div><div class=\"line\">  if (!obj || !keys.forEach) &#123;</div><div class=\"line\">    return result</div><div class=\"line\">  &#125;</div><div class=\"line\">  keys.forEach((item) =&gt; &#123;</div><div class=\"line\">    if (obj.hasOwnProperty(item)) &#123;</div><div class=\"line\">      result[item] = obj[item]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  return result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个对象和一个数组，遍历数组，如果传入对象有数组中包含的属性，则提取出来，返回一个过滤提取出来的属性组成的对象。</p>\n</li>\n<li><p>这个方法用处挺多的，比如从一个接口拿到了结果对象，可能上面很多属性你暂时用不到的，就可以用这个方法进行过滤。比如以前我用vue写项目的时候，就经常把接口返回的一个对象作为vue的data属性去渲染页面，这个时候这个对象是动态绑定在vue实例上面的，但是其中有些属性页面渲染根本用不到，还得去监听这些属性，白白浪费性能，这种时候将接口返回的对象筛选一下再赋给vue的data就显得合理多了。</p>\n<h5 id=\"8-判断是否是一个对象\"><a href=\"#8-判断是否是一个对象\" class=\"headerlink\" title=\"8. 判断是否是一个对象\"></a>8. 判断是否是一个对象</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 判断传入参数是否是一个合法对象</div><div class=\"line\">   * @param&#123;object&#125; obj </div><div class=\"line\">   * @return&#123;object&#125;</div><div class=\"line\">   * @example</div><div class=\"line\">   * isObject (null) isObject (() =&gt; &#123;&#125; )</div><div class=\"line\">   */</div><div class=\"line\">function isObject (obj) &#123;</div><div class=\"line\">    var type = typeof obj;</div><div class=\"line\">    return type === &apos;function&apos; || type === &apos;object&apos; &amp;&amp; !!obj;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>判断传入参数是否是一个合法对象，function类型均返回true，null返回false(typeof null 返回 object)</p>\n<h5 id=\"9-判断一个函数是否是native-code\"><a href=\"#9-判断一个函数是否是native-code\" class=\"headerlink\" title=\"9. 判断一个函数是否是native code\"></a>9. 判断一个函数是否是native code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 判断传入函数是否在当前环境下得到支持</div><div class=\"line\">   * @param&#123;function&#125; Ctor </div><div class=\"line\">   * @return&#123;boolean&#125;</div><div class=\"line\">   * @example</div><div class=\"line\">   * isNative (window.Symbol)  isNative (window.Promise)</div><div class=\"line\">   */</div><div class=\"line\">function isNative (Ctor) &#123;</div><div class=\"line\">  return typeof Ctor === &apos;function&apos; &amp;&amp; /native code/.test(Ctor.toString())</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>javascript原生自带的方法使用toString转成字符串时会包含‘native code’字段，比如Math.max.toString()就返回”function max() { [native code] }”。</p>\n</li>\n<li><p>这个方法可以判断某些原生特性是否被当前浏览器支持。比如isNative (window.Promise)在chrome中返回true，因为chrome支持原生es6语法，放到ie里面就只能返回false了~</p>\n<h5 id=\"10-深度克隆对象\"><a href=\"#10-深度克隆对象\" class=\"headerlink\" title=\"10. 深度克隆对象\"></a>10. 深度克隆对象</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 返回传入对象的一个深度克隆的副本对象</div><div class=\"line\"> * @param&#123;object&#125; obj </div><div class=\"line\"> * @return&#123;object&#125;</div><div class=\"line\"> * @example</div><div class=\"line\"> * cloneDeep(obj)</div><div class=\"line\"> */</div><div class=\"line\">function cloneDeep (obj) &#123;</div><div class=\"line\">  if (!isObject(obj)) return obj;</div><div class=\"line\">  let result</div><div class=\"line\">  if (Array.isArray(obj)) &#123;</div><div class=\"line\">    result = []</div><div class=\"line\">    obj.forEach((item) =&gt; &#123;</div><div class=\"line\">      result.push(cloneDeep(item))</div><div class=\"line\">    &#125;)</div><div class=\"line\">    return result</div><div class=\"line\">  &#125;</div><div class=\"line\">  result = &#123;&#125;</div><div class=\"line\">  for (let key in obj) &#123;</div><div class=\"line\">    let item = obj[key]</div><div class=\"line\">    if (_.isObject(item)) &#123;</div><div class=\"line\">      result[key] = cloneDeep(item)</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      result[key] = item</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>首先对传入参数进行判断，不是合法对象则直接返回其本身。然后再遍历其属性，属性中包含对象的会再次递归调用cloneDeep方法，浅克隆的话可以直接用Object.assign()方法。</p>\n<h5 id=\"11-获取两个地点的实际距离\"><a href=\"#11-获取两个地点的实际距离\" class=\"headerlink\" title=\"11. 获取两个地点的实际距离\"></a>11. 获取两个地点的实际距离</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 获取两个高德坐标的距离, 后一个点，不传，默认为用户坐标</div><div class=\"line\">   * @return &#123;null|number&#125; 距离多少米，没有定位信息，返回null</div><div class=\"line\">   * @example</div><div class=\"line\">   * getDistance(31.282055633974, 121.379623888259)</div><div class=\"line\">   */</div><div class=\"line\">  function getDistance (endLat, endLon, startLat, startLon) &#123;</div><div class=\"line\">    if (!startLat) &#123;</div><div class=\"line\">      let address = Lizard.state.address</div><div class=\"line\"></div><div class=\"line\">      if (address &amp;&amp; address.lat) &#123;</div><div class=\"line\">        startLat = address.lat</div><div class=\"line\">        startLon = address.lon</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 没有定位</div><div class=\"line\">    if (!startLat) &#123;</div><div class=\"line\">      return null</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    const PI = Math.PI</div><div class=\"line\">    let lon1 = (PI / 180) * startLon</div><div class=\"line\">    let lon2 = (PI / 180) * endLon </div><div class=\"line\">    let lat1 = (PI / 180) * startLat  </div><div class=\"line\">    let lat2 = (PI / 180) * endLat </div><div class=\"line\">    // 地球半径  </div><div class=\"line\">    let R = 6378.137;  </div><div class=\"line\"></div><div class=\"line\">    // 两点间距离 km，如果想要米的话，结果*1000就可以了  </div><div class=\"line\">    let d = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)) * R;  </div><div class=\"line\"></div><div class=\"line\">    return parseInt(d * 1000, 10)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>依次传入两个点的经纬度，然后计算得出两个点的距离，单位为km。这个方法可能实际应用的比较少，我这里还是写出来，作为一种前端计算距离的方法(在能拿得到定位的情况下)。</p>\n<h5 id=\"12-加载图片-promise封装\"><a href=\"#12-加载图片-promise封装\" class=\"headerlink\" title=\"12. 加载图片(promise封装)\"></a>12. 加载图片(promise封装)</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 传入图片url，返回一个promise对象，加载成功时resolve</div><div class=\"line\">   * @return &#123;Promise&#125; </div><div class=\"line\">   * @example</div><div class=\"line\">   * loadImg(url).then(console.log(&apos;加载完成&apos;)).catch(err =&gt; &#123;console.log(err)&#125;)</div><div class=\"line\">   */</div><div class=\"line\">  function loadImg (url) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">      let img = new Image()</div><div class=\"line\"></div><div class=\"line\">      img.addEventListener(&apos;load&apos;, function() &#123;</div><div class=\"line\">        resolve([img.width, img.height])</div><div class=\"line\">      &#125;, false)</div><div class=\"line\"></div><div class=\"line\">      img.addEventListener(&apos;error&apos;, reject, false)</div><div class=\"line\"></div><div class=\"line\">      img.src = url</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这个函数参考自ECMAScript 6 入门，算是promise的一个很经典的应用实例，加载完成后promise对象resolve，同时返回图片的宽高，以便后面调整样式等等。加载失败则返回reject，所以再调用这个方法后需要用catch方法来捕捉异常。</p>\n<h5 id=\"13-重复字符串n次\"><a href=\"#13-重复字符串n次\" class=\"headerlink\" title=\"13. 重复字符串n次\"></a>13. 重复字符串n次</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 传入字符串，和重复次数，返回结果字符串</div><div class=\"line\">   * @return &#123;string&#125; </div><div class=\"line\">   * @param&#123;string, number&#125; str n </div><div class=\"line\">   * @example</div><div class=\"line\">   * loadImg(url).then(console.log(&apos;加载完成&apos;)).catch(err =&gt; &#123;console.log(err)&#125;)</div><div class=\"line\">   */</div><div class=\"line\">  const repeat = (str, n) =&gt; &#123;</div><div class=\"line\">    let res = &apos;&apos;</div><div class=\"line\">    while (n) &#123;</div><div class=\"line\">      if (n % 2 === 1) res += str</div><div class=\"line\">      if (n &gt; 1) str += str</div><div class=\"line\">      n &gt;&gt;= 1</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这个函数在vue源码里看到的，用到了位运算符，如果让我来实现的话可能就马上想到重复n次，而上面这个函数执行时的时间复杂度差不多只是n/2。</p>\n<h5 id=\"14-变量是否以’-’或者’-’开头\"><a href=\"#14-变量是否以’-’或者’-’开头\" class=\"headerlink\" title=\"14. 变量是否以’$’或者’_’开头\"></a>14. 变量是否以’$’或者’_’开头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 传入字符串，判断是否以&apos;$&apos;或者&apos;_&apos;开头</div><div class=\"line\">   * @return &#123;Boolean&#125; </div><div class=\"line\">   * @param&#123;string&#125; str</div><div class=\"line\">   * @example</div><div class=\"line\">   * isReserved (‘$’)  isReserved (‘param’)</div><div class=\"line\">   */</div><div class=\"line\">function isReserved (str) &#123;</div><div class=\"line\">  var c = (str + &apos;&apos;).charCodeAt(0);</div><div class=\"line\">  return c === 0x24 || c === 0x5F</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>同样是vue源码里的方法，判断变量是否以’$’或者’_’开头，charCodeAt(index)方法会返回字符串对应index位置的字符的Unicode编码，’$’对应的Unicode编码就是36，这里用的是十六进制表示方法就是0x24。要判断变量名以什么字符开头或结尾，将上面方法略微修改即可实现。</p>\n</li>\n<li><p>ps：vue中哪里用到这个方法了呢，我去看了下就是在初始化vue实例的data对象时会判断，如果你的vue实例data里面命名了以’$’或者’_’的对象，是不会把这个属性重新定义其get/set的。简单点说，如果你在vue的data里定义一个命名为$data的属性，再在模板里渲染，就会报错的。</p>\n<h5 id=\"15-promise扩展-finally\"><a href=\"#15-promise扩展-finally\" class=\"headerlink\" title=\"15. promise扩展-finally\"></a>15. promise扩展-finally</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 在一个promise链调用结尾调用finally，传入一个函数，无论最后promise的状态是什么总会执行该函数</div><div class=\"line\">   * @param&#123;function&#125; callback</div><div class=\"line\">   * @example</div><div class=\"line\">   *  server.listen(0).then(function () &#123; // run test &#125;).finally(server.stop);</div><div class=\"line\">   */</div><div class=\"line\">Promise.prototype.finally = function (callback) &#123;</div><div class=\"line\">  let P = this.constructor;</div><div class=\"line\">  return this.then(</div><div class=\"line\">    value  =&gt; P.resolve(callback()).then(() =&gt; value).catch(e =&gt; &#123;console.error(e)&#125;),</div><div class=\"line\">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;).catch(e =&gt; &#123;console.error(e)&#125;)</div><div class=\"line\">  );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>参考自<a href=\"http://es6.ruanyifeng.com/?search=find&amp;x=0&amp;y=0\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门</a>，对于promise对象的一个扩展方法，不论前面的promise状态是什么总会调用callback函数。</p>\n</li>\n<li>我在原代码的基础上添加了新的catch，用于兼容callback执行时返回了一个状态为reject的promise的情况。<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li>再次补充，已搬运到<a href=\"https://tokenyangforever.github.io/2017/09/12/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"external\">github博客</a>，上面自带导航~~~</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>以下代码来自：自己写的、工作项目框架上用到的、其他框架源码上的、网上看到的。</li>\n<li>主要是作为工具函数，服务于框架业务，自身不依赖于其他框架类库，部分使用到es6/es7的语法使用时要注意转码</li>\n<li><p>虽然尽量在函数中做了错误情况的处理，仍有可能出现报错的情况(不定期完善)</p>\n<h5 id=\"1-获取url上的参数\"><a href=\"#1-获取url上的参数\" class=\"headerlink\" title=\"1. 获取url上的参数\"></a>1. 获取url上的参数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   *获取url上的参数</div><div class=\"line\">   * @return &#123;object&#125;</div><div class=\"line\">   * @example</div><div class=\"line\">   * getRequest()  getRequest().paramA</div><div class=\"line\">   */</div><div class=\"line\">function getRequest() &#123;</div><div class=\"line\">    var searchString = window.location.search.substring(1),</div><div class=\"line\">        params = searchString.split(&quot;&amp;&quot;),</div><div class=\"line\">        hash = &#123;&#125;;</div><div class=\"line\">    if (searchString == &quot;&quot;) return &#123;&#125;;</div><div class=\"line\">    for (var i = 0; i &lt; params.length; i++) &#123;</div><div class=\"line\">        var pos = params[i].indexOf(&apos;=&apos;);</div><div class=\"line\">        if (pos == -1) &#123; continue; &#125;</div><div class=\"line\">        var paraName = params[i].substring(0, pos),</div><div class=\"line\">            paraValue = params[i].substring(pos + 1);</div><div class=\"line\">        hash[paraName] = paraValue;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return hash;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>返回一个对象，将url上的参数以键值对的形式存储在返回结果中，如果url上没参数，则返回空对象</p>\n<h5 id=\"2-追加url参数\"><a href=\"#2-追加url参数\" class=\"headerlink\" title=\"2. 追加url参数\"></a>2. 追加url参数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 追加url参数</div><div class=\"line\"> * @param &#123;string&#125; url url参数</div><div class=\"line\"> * @param &#123;string|object&#125; key 名字或者对象</div><div class=\"line\"> * @param &#123;string&#125; value 值</div><div class=\"line\"> * @return &#123;string&#125; 返回新的url</div><div class=\"line\"> * @example</div><div class=\"line\"> * appendQuery(&apos;lechebang.com&apos;, &apos;id&apos;, 3);</div><div class=\"line\"> * appendQuery(&apos;lechebang.com?key=value&apos;, &#123; cityId: 2, cityName: &apos;北京&apos;&#125;);</div><div class=\"line\"> */</div><div class=\"line\">function appendQuery (url, key, value) &#123;</div><div class=\"line\">  var options = key;</div><div class=\"line\">  if (typeof options == &apos;string&apos;) &#123;</div><div class=\"line\">    options = &#123;&#125;;</div><div class=\"line\">    options[key] = value;</div><div class=\"line\">  &#125;</div><div class=\"line\">  options = $.param(options);</div><div class=\"line\">  if (url.includes(&apos;?&apos;)) &#123;</div><div class=\"line\">    url += &apos;&amp;&apos; + options</div><div class=\"line\">  &#125; else &#123;</div><div class=\"line\">    url += &apos;?&apos; + options</div><div class=\"line\">  &#125;</div><div class=\"line\">  return url;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个url和需要添加的参数键值对，需添加的参数可以直接传对象格式。会判断原url上是否有参数，没有的话就加’?’，返回添加参数后的url。</p>\n<h5 id=\"3-计算两个日期的时间差\"><a href=\"#3-计算两个日期的时间差\" class=\"headerlink\" title=\"3. 计算两个日期的时间差\"></a>3. 计算两个日期的时间差</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 计算两个日期时间的时间差</div><div class=\"line\">   * @param &#123;Date, Date&#125;  date1 date2</div><div class=\"line\">   * @return &#123;object | null&#125; </div><div class=\"line\">   * @example</div><div class=\"line\">   * getDiff(new Date(&apos;2017-09-08&apos;), new Date())</div><div class=\"line\">   */</div><div class=\"line\">function getDiff(date1, date2) &#123;</div><div class=\"line\">     if (!date1.getTime || !date2.getTime) return null</div><div class=\"line\">     var ms = (date1.getTime() - date2.getTime());</div><div class=\"line\">     var day1 = Math.round(ms / 24 / 3600 / 1000),</div><div class=\"line\">         hh1 = Math.round((ms / 3600 / 1000) % 24),</div><div class=\"line\">         mm1 = Math.round((ms / 1000 / 60) % 60),</div><div class=\"line\">         ss1 = Math.round((ms / 1000) % 60);</div><div class=\"line\">     return &#123;</div><div class=\"line\">         day: day1,</div><div class=\"line\">         hour: hh1,</div><div class=\"line\">         minute: mm1,</div><div class=\"line\">         second: ss1</div><div class=\"line\">      &#125;;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入两个Date日期对象，返回一个对象，其属性值day、hour、minute、second分别表示相差天数、小时、分钟、秒。结果以Math.round()取整，如果结果为负，则表示第一个日期在第二个日期前面</p>\n<h5 id=\"4-将canvas转化为image图片格式\"><a href=\"#4-将canvas转化为image图片格式\" class=\"headerlink\" title=\"4. 将canvas转化为image图片格式\"></a>4. 将canvas转化为image图片格式</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 将canvas转化为image格式</div><div class=\"line\">   * @param &#123;string&#125;  cId</div><div class=\"line\">   * @return &#123;object HTMLImageElement&#125; </div><div class=\"line\">   * @example</div><div class=\"line\">   * canvasToImg(&apos;canvas&apos;)  canvasToImg(&apos;#canvarsId&apos;)</div><div class=\"line\">   */</div><div class=\"line\">function canvasToImg(cId)&#123;</div><div class=\"line\">    let canvas = document.querySelector(cId)</div><div class=\"line\">    if (!canvas || !canvas.toDataURL) return new Image()</div><div class=\"line\">    let imgData = canvas.toDataURL(&apos;image/png&apos;),</div><div class=\"line\">        imgs= new Image();</div><div class=\"line\">        imgs.src=imgData;</div><div class=\"line\">    return imgs</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个css选择器，函数根据选择器查询canvas节点，然后返回该canvas的image格式节点，如果查找不到则返回一个空的image。原理是将canvas转化为base64编码，toDataURL方法貌似是canvas节点独有的，然后新建一个src是这个base64编码的图片。</p>\n</li>\n<li><p>ps:什么情况下需要做这种转换呢？目前我知道的一个就是canvas在移动端无法长按保存到手机。</p>\n<h5 id=\"5-生成随机guid\"><a href=\"#5-生成随机guid\" class=\"headerlink\" title=\"5. 生成随机guid\"></a>5. 生成随机guid</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 生成一个唯一的guid</div><div class=\"line\"> * @return &#123;string&#125;</div><div class=\"line\"> * @example</div><div class=\"line\"> * // 7f603b20-17ff-4f47-aeb9-e7996de04939</div><div class=\"line\"> * util.guid();</div><div class=\"line\"> * @see http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript</div><div class=\"line\"> */</div><div class=\"line\">function guid () &#123;</div><div class=\"line\">  return &apos;xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx&apos;.replace(/[xy]/g, function(c) &#123;</div><div class=\"line\">    var r = Math.random()*16|0, v = c == &apos;x&apos; ? r : (r&amp;0x3|0x8);</div><div class=\"line\">    return v.toString(16);</div><div class=\"line\">  &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这个方法用于生成一个随机<a href=\"https://baike.baidu.com/item/GUID/3352285?fr=aladdin\" target=\"_blank\" rel=\"external\">guid</a>，可以将生成的guid视为全局唯一的(生成两个相同id的情况很少)。guid似乎在前端用的比较少，目前项目用到就是在每次请求后端接口时调用此方法，生成一个guid传过去。</p>\n<h5 id=\"6-获取一个月份的天数\"><a href=\"#6-获取一个月份的天数\" class=\"headerlink\" title=\"6. 获取一个月份的天数\"></a>6. 获取一个月份的天数</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">function isLeapYear (year) &#123;</div><div class=\"line\">  if (year % 100 === 0) &#123;</div><div class=\"line\">    if (year % 400 === 0) &#123;</div><div class=\"line\">      return true;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125; else if (year % 4 === 0) &#123;</div><div class=\"line\">    return true;</div><div class=\"line\">  &#125;</div><div class=\"line\">  return false;</div><div class=\"line\">&#125;</div><div class=\"line\">/**</div><div class=\"line\"> * 获取某个月份有多少天</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> * @param &#123;string | number&#125;  year month</div><div class=\"line\"> * @example</div><div class=\"line\"> * getDaysInMonth(2017, 9)</div><div class=\"line\"> */</div><div class=\"line\">function getDaysInMonth (year, month) &#123;</div><div class=\"line\">  return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个年份和月份，返回该月有多少天，其中也包含了一个isLeapYear方法来判断是否是闰年，应该在实现日历或者日期选择组件时用的到</p>\n<h5 id=\"7-过滤对象属性\"><a href=\"#7-过滤对象属性\" class=\"headerlink\" title=\"7. 过滤对象属性\"></a>7. 过滤对象属性</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 过滤选出一个对象的某些属性</div><div class=\"line\"> * @param&#123;object, array&#125; obj key</div><div class=\"line\"> * @return&#123;object&#125;</div><div class=\"line\"> * @example</div><div class=\"line\"> * pick(obj, [key1, key2])</div><div class=\"line\"> */</div><div class=\"line\">function pick (obj, keys) &#123;</div><div class=\"line\">  let result = &#123;&#125;</div><div class=\"line\">  if (!obj || !keys.forEach) &#123;</div><div class=\"line\">    return result</div><div class=\"line\">  &#125;</div><div class=\"line\">  keys.forEach((item) =&gt; &#123;</div><div class=\"line\">    if (obj.hasOwnProperty(item)) &#123;</div><div class=\"line\">      result[item] = obj[item]</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;)</div><div class=\"line\">  return result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>传入一个对象和一个数组，遍历数组，如果传入对象有数组中包含的属性，则提取出来，返回一个过滤提取出来的属性组成的对象。</p>\n</li>\n<li><p>这个方法用处挺多的，比如从一个接口拿到了结果对象，可能上面很多属性你暂时用不到的，就可以用这个方法进行过滤。比如以前我用vue写项目的时候，就经常把接口返回的一个对象作为vue的data属性去渲染页面，这个时候这个对象是动态绑定在vue实例上面的，但是其中有些属性页面渲染根本用不到，还得去监听这些属性，白白浪费性能，这种时候将接口返回的对象筛选一下再赋给vue的data就显得合理多了。</p>\n<h5 id=\"8-判断是否是一个对象\"><a href=\"#8-判断是否是一个对象\" class=\"headerlink\" title=\"8. 判断是否是一个对象\"></a>8. 判断是否是一个对象</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 判断传入参数是否是一个合法对象</div><div class=\"line\">   * @param&#123;object&#125; obj </div><div class=\"line\">   * @return&#123;object&#125;</div><div class=\"line\">   * @example</div><div class=\"line\">   * isObject (null) isObject (() =&gt; &#123;&#125; )</div><div class=\"line\">   */</div><div class=\"line\">function isObject (obj) &#123;</div><div class=\"line\">    var type = typeof obj;</div><div class=\"line\">    return type === &apos;function&apos; || type === &apos;object&apos; &amp;&amp; !!obj;</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>判断传入参数是否是一个合法对象，function类型均返回true，null返回false(typeof null 返回 object)</p>\n<h5 id=\"9-判断一个函数是否是native-code\"><a href=\"#9-判断一个函数是否是native-code\" class=\"headerlink\" title=\"9. 判断一个函数是否是native code\"></a>9. 判断一个函数是否是native code</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">  /**</div><div class=\"line\">   * 判断传入函数是否在当前环境下得到支持</div><div class=\"line\">   * @param&#123;function&#125; Ctor </div><div class=\"line\">   * @return&#123;boolean&#125;</div><div class=\"line\">   * @example</div><div class=\"line\">   * isNative (window.Symbol)  isNative (window.Promise)</div><div class=\"line\">   */</div><div class=\"line\">function isNative (Ctor) &#123;</div><div class=\"line\">  return typeof Ctor === &apos;function&apos; &amp;&amp; /native code/.test(Ctor.toString())</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>javascript原生自带的方法使用toString转成字符串时会包含‘native code’字段，比如Math.max.toString()就返回”function max() { [native code] }”。</p>\n</li>\n<li><p>这个方法可以判断某些原生特性是否被当前浏览器支持。比如isNative (window.Promise)在chrome中返回true，因为chrome支持原生es6语法，放到ie里面就只能返回false了~</p>\n<h5 id=\"10-深度克隆对象\"><a href=\"#10-深度克隆对象\" class=\"headerlink\" title=\"10. 深度克隆对象\"></a>10. 深度克隆对象</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * 返回传入对象的一个深度克隆的副本对象</div><div class=\"line\"> * @param&#123;object&#125; obj </div><div class=\"line\"> * @return&#123;object&#125;</div><div class=\"line\"> * @example</div><div class=\"line\"> * cloneDeep(obj)</div><div class=\"line\"> */</div><div class=\"line\">function cloneDeep (obj) &#123;</div><div class=\"line\">  if (!isObject(obj)) return obj;</div><div class=\"line\">  let result</div><div class=\"line\">  if (Array.isArray(obj)) &#123;</div><div class=\"line\">    result = []</div><div class=\"line\">    obj.forEach((item) =&gt; &#123;</div><div class=\"line\">      result.push(cloneDeep(item))</div><div class=\"line\">    &#125;)</div><div class=\"line\">    return result</div><div class=\"line\">  &#125;</div><div class=\"line\">  result = &#123;&#125;</div><div class=\"line\">  for (let key in obj) &#123;</div><div class=\"line\">    let item = obj[key]</div><div class=\"line\">    if (_.isObject(item)) &#123;</div><div class=\"line\">      result[key] = cloneDeep(item)</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">      result[key] = item</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  return result</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>首先对传入参数进行判断，不是合法对象则直接返回其本身。然后再遍历其属性，属性中包含对象的会再次递归调用cloneDeep方法，浅克隆的话可以直接用Object.assign()方法。</p>\n<h5 id=\"11-获取两个地点的实际距离\"><a href=\"#11-获取两个地点的实际距离\" class=\"headerlink\" title=\"11. 获取两个地点的实际距离\"></a>11. 获取两个地点的实际距离</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 获取两个高德坐标的距离, 后一个点，不传，默认为用户坐标</div><div class=\"line\">   * @return &#123;null|number&#125; 距离多少米，没有定位信息，返回null</div><div class=\"line\">   * @example</div><div class=\"line\">   * getDistance(31.282055633974, 121.379623888259)</div><div class=\"line\">   */</div><div class=\"line\">  function getDistance (endLat, endLon, startLat, startLon) &#123;</div><div class=\"line\">    if (!startLat) &#123;</div><div class=\"line\">      let address = Lizard.state.address</div><div class=\"line\"></div><div class=\"line\">      if (address &amp;&amp; address.lat) &#123;</div><div class=\"line\">        startLat = address.lat</div><div class=\"line\">        startLon = address.lon</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    // 没有定位</div><div class=\"line\">    if (!startLat) &#123;</div><div class=\"line\">      return null</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    const PI = Math.PI</div><div class=\"line\">    let lon1 = (PI / 180) * startLon</div><div class=\"line\">    let lon2 = (PI / 180) * endLon </div><div class=\"line\">    let lat1 = (PI / 180) * startLat  </div><div class=\"line\">    let lat2 = (PI / 180) * endLat </div><div class=\"line\">    // 地球半径  </div><div class=\"line\">    let R = 6378.137;  </div><div class=\"line\"></div><div class=\"line\">    // 两点间距离 km，如果想要米的话，结果*1000就可以了  </div><div class=\"line\">    let d = Math.acos(Math.sin(lat1) * Math.sin(lat2) + Math.cos(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1)) * R;  </div><div class=\"line\"></div><div class=\"line\">    return parseInt(d * 1000, 10)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>依次传入两个点的经纬度，然后计算得出两个点的距离，单位为km。这个方法可能实际应用的比较少，我这里还是写出来，作为一种前端计算距离的方法(在能拿得到定位的情况下)。</p>\n<h5 id=\"12-加载图片-promise封装\"><a href=\"#12-加载图片-promise封装\" class=\"headerlink\" title=\"12. 加载图片(promise封装)\"></a>12. 加载图片(promise封装)</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 传入图片url，返回一个promise对象，加载成功时resolve</div><div class=\"line\">   * @return &#123;Promise&#125; </div><div class=\"line\">   * @example</div><div class=\"line\">   * loadImg(url).then(console.log(&apos;加载完成&apos;)).catch(err =&gt; &#123;console.log(err)&#125;)</div><div class=\"line\">   */</div><div class=\"line\">  function loadImg (url) &#123;</div><div class=\"line\">    return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">      let img = new Image()</div><div class=\"line\"></div><div class=\"line\">      img.addEventListener(&apos;load&apos;, function() &#123;</div><div class=\"line\">        resolve([img.width, img.height])</div><div class=\"line\">      &#125;, false)</div><div class=\"line\"></div><div class=\"line\">      img.addEventListener(&apos;error&apos;, reject, false)</div><div class=\"line\"></div><div class=\"line\">      img.src = url</div><div class=\"line\">    &#125;)</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这个函数参考自ECMAScript 6 入门，算是promise的一个很经典的应用实例，加载完成后promise对象resolve，同时返回图片的宽高，以便后面调整样式等等。加载失败则返回reject，所以再调用这个方法后需要用catch方法来捕捉异常。</p>\n<h5 id=\"13-重复字符串n次\"><a href=\"#13-重复字符串n次\" class=\"headerlink\" title=\"13. 重复字符串n次\"></a>13. 重复字符串n次</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 传入字符串，和重复次数，返回结果字符串</div><div class=\"line\">   * @return &#123;string&#125; </div><div class=\"line\">   * @param&#123;string, number&#125; str n </div><div class=\"line\">   * @example</div><div class=\"line\">   * loadImg(url).then(console.log(&apos;加载完成&apos;)).catch(err =&gt; &#123;console.log(err)&#125;)</div><div class=\"line\">   */</div><div class=\"line\">  const repeat = (str, n) =&gt; &#123;</div><div class=\"line\">    let res = &apos;&apos;</div><div class=\"line\">    while (n) &#123;</div><div class=\"line\">      if (n % 2 === 1) res += str</div><div class=\"line\">      if (n &gt; 1) str += str</div><div class=\"line\">      n &gt;&gt;= 1</div><div class=\"line\">    &#125;</div><div class=\"line\">    return res</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这个函数在vue源码里看到的，用到了位运算符，如果让我来实现的话可能就马上想到重复n次，而上面这个函数执行时的时间复杂度差不多只是n/2。</p>\n<h5 id=\"14-变量是否以’-’或者’-’开头\"><a href=\"#14-变量是否以’-’或者’-’开头\" class=\"headerlink\" title=\"14. 变量是否以’$’或者’_’开头\"></a>14. 变量是否以’$’或者’_’开头</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 传入字符串，判断是否以&apos;$&apos;或者&apos;_&apos;开头</div><div class=\"line\">   * @return &#123;Boolean&#125; </div><div class=\"line\">   * @param&#123;string&#125; str</div><div class=\"line\">   * @example</div><div class=\"line\">   * isReserved (‘$’)  isReserved (‘param’)</div><div class=\"line\">   */</div><div class=\"line\">function isReserved (str) &#123;</div><div class=\"line\">  var c = (str + &apos;&apos;).charCodeAt(0);</div><div class=\"line\">  return c === 0x24 || c === 0x5F</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>同样是vue源码里的方法，判断变量是否以’$’或者’_’开头，charCodeAt(index)方法会返回字符串对应index位置的字符的Unicode编码，’$’对应的Unicode编码就是36，这里用的是十六进制表示方法就是0x24。要判断变量名以什么字符开头或结尾，将上面方法略微修改即可实现。</p>\n</li>\n<li><p>ps：vue中哪里用到这个方法了呢，我去看了下就是在初始化vue实例的data对象时会判断，如果你的vue实例data里面命名了以’$’或者’_’的对象，是不会把这个属性重新定义其get/set的。简单点说，如果你在vue的data里定义一个命名为$data的属性，再在模板里渲染，就会报错的。</p>\n<h5 id=\"15-promise扩展-finally\"><a href=\"#15-promise扩展-finally\" class=\"headerlink\" title=\"15. promise扩展-finally\"></a>15. promise扩展-finally</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\">   * 在一个promise链调用结尾调用finally，传入一个函数，无论最后promise的状态是什么总会执行该函数</div><div class=\"line\">   * @param&#123;function&#125; callback</div><div class=\"line\">   * @example</div><div class=\"line\">   *  server.listen(0).then(function () &#123; // run test &#125;).finally(server.stop);</div><div class=\"line\">   */</div><div class=\"line\">Promise.prototype.finally = function (callback) &#123;</div><div class=\"line\">  let P = this.constructor;</div><div class=\"line\">  return this.then(</div><div class=\"line\">    value  =&gt; P.resolve(callback()).then(() =&gt; value).catch(e =&gt; &#123;console.error(e)&#125;),</div><div class=\"line\">    reason =&gt; P.resolve(callback()).then(() =&gt; &#123; throw reason &#125;).catch(e =&gt; &#123;console.error(e)&#125;)</div><div class=\"line\">  );</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>参考自<a href=\"http://es6.ruanyifeng.com/?search=find&amp;x=0&amp;y=0\" target=\"_blank\" rel=\"external\">ECMAScript 6 入门</a>，对于promise对象的一个扩展方法，不论前面的promise状态是什么总会调用callback函数。</p>\n</li>\n<li>我在原代码的基础上添加了新的catch，用于兼容callback执行时返回了一个状态为reject的promise的情况。<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li>再次补充，已搬运到<a href=\"https://tokenyangforever.github.io/2017/09/12/JavaScript%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/\" target=\"_blank\" rel=\"external\">github博客</a>，上面自带导航~~~</li>\n</ul>\n"},{"title":"Object属性特性详解","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n### 前言\n　Object是javascript中最原始的对象，也是理解面向对象十分重要的一环。最近看vue源码时，发现object这方面的东西非常多，就在这里深入了解一下相关知识。本篇主要介绍object对象的一些方法，以及属性的特性相关概念。首先介绍对象的属性，属性类型其实分为两种：**数据属性**和**访问器属性**，我们平时接触到的一般都是数据属性，下面依次介绍一下。\n### 数据属性\n　数据属性包含一个数据值的位置，可以进行数据的读写。然后数据属性有四个描述其行为的**特性**，这个特性可以理解为属性的属性。\n1.[[configurable]]：表示是否能够修改属性的特性，是否能够使用delete删除属性进而重新定义。\n2.[[Enumberable]]：表示是否可以被枚举，此特性为true时，对应的属性在for-in循环中才返回。\n3.[[Writable]]：是否可写，此特性为true时，才可以定义修改对应属性的数据值\n4.[[Value]]：即属性的数据值。\n上面几个特性，前三个默认值都是true，Value默认值undefined。随便定义一个变量及其属性，然后调用Object.getOwnPropertyDescriptors()即可显示其属性，以及属性的特性。\n![示例.jpg](http://upload-images.jianshu.io/upload_images/6383319-efd2d41b73e40ba6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 访问器属性\n　首先要明白的是访问器属性不包含数据值，包含一对getter和setter函数。读取访问器时调用getter，写入访问器时调用setter。这两个函数默认值都是undefined，只有使用Object.defineProperty()方法对其进行定义。接着介绍一下object的一些方法。\n#### Object.create() \n　参数传入一个原型对象，使用指定的原型对象和其属性创建了一个新的对象。\n#### Object.assign()\n　将所有**可枚举**的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。第一个参数是目标对象，如果有相同键值的属性，源对象的属性会覆盖掉木雕对象属性， 方法只会拷贝源对象**自身的**并且**可枚举**的属性到目标对象身上。\n#### Object.defineProperty() Object.defineProperties()\n　Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Object.defineProperty(obj, prop, descriptor)，第一个参数是目标对象，第二个参数是指定属性，第三个参数是描述符对象指定特性。在指定描述符时，只能选择**数据描述符**和**存取描述符**的其中一种。Object.defineProperties(obj, props)也是用于为一个对象定义属性，但是可以同时指定多个属性。\n#### Object.keys()\n　**Object.keys()** 方法会返回一个由一个给定对象的**自身可枚举属性**组成的数组，数组中属性名的排列顺序和使用for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。\n#### Object.freeze() Object.seal()\n　这两个方法是用于限制对象修改权限的，分别有对应的Object.isFrozen()和Object.isSealed()方法判断是否是冻结(密封)对象，两者唯一的区别是，密封对象仍然可以修改已有属性value的值。\n　Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的特性。也就是说，这个对象**永远是不可变的**。该方法返回被冻结的对象。\n　Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性特性，但可能可以**修改已有属性的值**的对象。\n### 结语\n　暂时总结就这么多，上面的内容大多是从js高程上看的，在线api[查的这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)，后面有遗漏或不准确的地方再进行修改。最后说一点，上述的object的方法很多都不支持ie8，这也是为什么vue不支持ie8，但如果是在现代高版本的浏览器进行开发时就不用顾虑了。\n","source":"_posts/Object属性特性详解.md","raw":"title: Object属性特性详解\ntags:\n  - JavaScript\ncategories:\n  - JavaScript\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n### 前言\n　Object是javascript中最原始的对象，也是理解面向对象十分重要的一环。最近看vue源码时，发现object这方面的东西非常多，就在这里深入了解一下相关知识。本篇主要介绍object对象的一些方法，以及属性的特性相关概念。首先介绍对象的属性，属性类型其实分为两种：**数据属性**和**访问器属性**，我们平时接触到的一般都是数据属性，下面依次介绍一下。\n### 数据属性\n　数据属性包含一个数据值的位置，可以进行数据的读写。然后数据属性有四个描述其行为的**特性**，这个特性可以理解为属性的属性。\n1.[[configurable]]：表示是否能够修改属性的特性，是否能够使用delete删除属性进而重新定义。\n2.[[Enumberable]]：表示是否可以被枚举，此特性为true时，对应的属性在for-in循环中才返回。\n3.[[Writable]]：是否可写，此特性为true时，才可以定义修改对应属性的数据值\n4.[[Value]]：即属性的数据值。\n上面几个特性，前三个默认值都是true，Value默认值undefined。随便定义一个变量及其属性，然后调用Object.getOwnPropertyDescriptors()即可显示其属性，以及属性的特性。\n![示例.jpg](http://upload-images.jianshu.io/upload_images/6383319-efd2d41b73e40ba6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 访问器属性\n　首先要明白的是访问器属性不包含数据值，包含一对getter和setter函数。读取访问器时调用getter，写入访问器时调用setter。这两个函数默认值都是undefined，只有使用Object.defineProperty()方法对其进行定义。接着介绍一下object的一些方法。\n#### Object.create() \n　参数传入一个原型对象，使用指定的原型对象和其属性创建了一个新的对象。\n#### Object.assign()\n　将所有**可枚举**的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。第一个参数是目标对象，如果有相同键值的属性，源对象的属性会覆盖掉木雕对象属性， 方法只会拷贝源对象**自身的**并且**可枚举**的属性到目标对象身上。\n#### Object.defineProperty() Object.defineProperties()\n　Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Object.defineProperty(obj, prop, descriptor)，第一个参数是目标对象，第二个参数是指定属性，第三个参数是描述符对象指定特性。在指定描述符时，只能选择**数据描述符**和**存取描述符**的其中一种。Object.defineProperties(obj, props)也是用于为一个对象定义属性，但是可以同时指定多个属性。\n#### Object.keys()\n　**Object.keys()** 方法会返回一个由一个给定对象的**自身可枚举属性**组成的数组，数组中属性名的排列顺序和使用for...in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。\n#### Object.freeze() Object.seal()\n　这两个方法是用于限制对象修改权限的，分别有对应的Object.isFrozen()和Object.isSealed()方法判断是否是冻结(密封)对象，两者唯一的区别是，密封对象仍然可以修改已有属性value的值。\n　Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的特性。也就是说，这个对象**永远是不可变的**。该方法返回被冻结的对象。\n　Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性特性，但可能可以**修改已有属性的值**的对象。\n### 结语\n　暂时总结就这么多，上面的内容大多是从js高程上看的，在线api[查的这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object)，后面有遗漏或不准确的地方再进行修改。最后说一点，上述的object的方法很多都不支持ie8，这也是为什么vue不支持ie8，但如果是在现代高版本的浏览器进行开发时就不用顾虑了。\n","slug":"Object属性特性详解","published":1,"updated":"2017-09-15T05:54:13.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9df0001e6vmuyy81hqf","content":"<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>　Object是javascript中最原始的对象，也是理解面向对象十分重要的一环。最近看vue源码时，发现object这方面的东西非常多，就在这里深入了解一下相关知识。本篇主要介绍object对象的一些方法，以及属性的特性相关概念。首先介绍对象的属性，属性类型其实分为两种：<strong>数据属性</strong>和<strong>访问器属性</strong>，我们平时接触到的一般都是数据属性，下面依次介绍一下。</p>\n<h3 id=\"数据属性\"><a href=\"#数据属性\" class=\"headerlink\" title=\"数据属性\"></a>数据属性</h3><p>　数据属性包含一个数据值的位置，可以进行数据的读写。然后数据属性有四个描述其行为的<strong>特性</strong>，这个特性可以理解为属性的属性。<br>1.[[configurable]]：表示是否能够修改属性的特性，是否能够使用delete删除属性进而重新定义。<br>2.[[Enumberable]]：表示是否可以被枚举，此特性为true时，对应的属性在for-in循环中才返回。<br>3.[[Writable]]：是否可写，此特性为true时，才可以定义修改对应属性的数据值<br>4.[[Value]]：即属性的数据值。<br>上面几个特性，前三个默认值都是true，Value默认值undefined。随便定义一个变量及其属性，然后调用Object.getOwnPropertyDescriptors()即可显示其属性，以及属性的特性。<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-efd2d41b73e40ba6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示例.jpg\"></p>\n<h3 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h3><p>　首先要明白的是访问器属性不包含数据值，包含一对getter和setter函数。读取访问器时调用getter，写入访问器时调用setter。这两个函数默认值都是undefined，只有使用Object.defineProperty()方法对其进行定义。接着介绍一下object的一些方法。</p>\n<h4 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h4><p>　参数传入一个原型对象，使用指定的原型对象和其属性创建了一个新的对象。</p>\n<h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><p>　将所有<strong>可枚举</strong>的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。第一个参数是目标对象，如果有相同键值的属性，源对象的属性会覆盖掉木雕对象属性， 方法只会拷贝源对象<strong>自身的</strong>并且<strong>可枚举</strong>的属性到目标对象身上。</p>\n<h4 id=\"Object-defineProperty-Object-defineProperties\"><a href=\"#Object-defineProperty-Object-defineProperties\" class=\"headerlink\" title=\"Object.defineProperty() Object.defineProperties()\"></a>Object.defineProperty() Object.defineProperties()</h4><p>　Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Object.defineProperty(obj, prop, descriptor)，第一个参数是目标对象，第二个参数是指定属性，第三个参数是描述符对象指定特性。在指定描述符时，只能选择<strong>数据描述符</strong>和<strong>存取描述符</strong>的其中一种。Object.defineProperties(obj, props)也是用于为一个对象定义属性，但是可以同时指定多个属性。</p>\n<h4 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a>Object.keys()</h4><p>　<strong>Object.keys()</strong> 方法会返回一个由一个给定对象的<strong>自身可枚举属性</strong>组成的数组，数组中属性名的排列顺序和使用for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</p>\n<h4 id=\"Object-freeze-Object-seal\"><a href=\"#Object-freeze-Object-seal\" class=\"headerlink\" title=\"Object.freeze() Object.seal()\"></a>Object.freeze() Object.seal()</h4><p>　这两个方法是用于限制对象修改权限的，分别有对应的Object.isFrozen()和Object.isSealed()方法判断是否是冻结(密封)对象，两者唯一的区别是，密封对象仍然可以修改已有属性value的值。<br>　Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的特性。也就是说，这个对象<strong>永远是不可变的</strong>。该方法返回被冻结的对象。<br>　Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性特性，但可能可以<strong>修改已有属性的值</strong>的对象。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>　暂时总结就这么多，上面的内容大多是从js高程上看的，在线api<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\" target=\"_blank\" rel=\"external\">查的这里</a>，后面有遗漏或不准确的地方再进行修改。最后说一点，上述的object的方法很多都不支持ie8，这也是为什么vue不支持ie8，但如果是在现代高版本的浏览器进行开发时就不用顾虑了。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>　Object是javascript中最原始的对象，也是理解面向对象十分重要的一环。最近看vue源码时，发现object这方面的东西非常多，就在这里深入了解一下相关知识。本篇主要介绍object对象的一些方法，以及属性的特性相关概念。首先介绍对象的属性，属性类型其实分为两种：<strong>数据属性</strong>和<strong>访问器属性</strong>，我们平时接触到的一般都是数据属性，下面依次介绍一下。</p>\n<h3 id=\"数据属性\"><a href=\"#数据属性\" class=\"headerlink\" title=\"数据属性\"></a>数据属性</h3><p>　数据属性包含一个数据值的位置，可以进行数据的读写。然后数据属性有四个描述其行为的<strong>特性</strong>，这个特性可以理解为属性的属性。<br>1.[[configurable]]：表示是否能够修改属性的特性，是否能够使用delete删除属性进而重新定义。<br>2.[[Enumberable]]：表示是否可以被枚举，此特性为true时，对应的属性在for-in循环中才返回。<br>3.[[Writable]]：是否可写，此特性为true时，才可以定义修改对应属性的数据值<br>4.[[Value]]：即属性的数据值。<br>上面几个特性，前三个默认值都是true，Value默认值undefined。随便定义一个变量及其属性，然后调用Object.getOwnPropertyDescriptors()即可显示其属性，以及属性的特性。<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-efd2d41b73e40ba6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示例.jpg\"></p>\n<h3 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h3><p>　首先要明白的是访问器属性不包含数据值，包含一对getter和setter函数。读取访问器时调用getter，写入访问器时调用setter。这两个函数默认值都是undefined，只有使用Object.defineProperty()方法对其进行定义。接着介绍一下object的一些方法。</p>\n<h4 id=\"Object-create\"><a href=\"#Object-create\" class=\"headerlink\" title=\"Object.create()\"></a>Object.create()</h4><p>　参数传入一个原型对象，使用指定的原型对象和其属性创建了一个新的对象。</p>\n<h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><p>　将所有<strong>可枚举</strong>的属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。第一个参数是目标对象，如果有相同键值的属性，源对象的属性会覆盖掉木雕对象属性， 方法只会拷贝源对象<strong>自身的</strong>并且<strong>可枚举</strong>的属性到目标对象身上。</p>\n<h4 id=\"Object-defineProperty-Object-defineProperties\"><a href=\"#Object-defineProperty-Object-defineProperties\" class=\"headerlink\" title=\"Object.defineProperty() Object.defineProperties()\"></a>Object.defineProperty() Object.defineProperties()</h4><p>　Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。Object.defineProperty(obj, prop, descriptor)，第一个参数是目标对象，第二个参数是指定属性，第三个参数是描述符对象指定特性。在指定描述符时，只能选择<strong>数据描述符</strong>和<strong>存取描述符</strong>的其中一种。Object.defineProperties(obj, props)也是用于为一个对象定义属性，但是可以同时指定多个属性。</p>\n<h4 id=\"Object-keys\"><a href=\"#Object-keys\" class=\"headerlink\" title=\"Object.keys()\"></a>Object.keys()</h4><p>　<strong>Object.keys()</strong> 方法会返回一个由一个给定对象的<strong>自身可枚举属性</strong>组成的数组，数组中属性名的排列顺序和使用for…in 循环遍历该对象时返回的顺序一致 （两者的主要区别是 一个 for-in 循环还会枚举其原型链上的属性）。</p>\n<h4 id=\"Object-freeze-Object-seal\"><a href=\"#Object-freeze-Object-seal\" class=\"headerlink\" title=\"Object.freeze() Object.seal()\"></a>Object.freeze() Object.seal()</h4><p>　这两个方法是用于限制对象修改权限的，分别有对应的Object.isFrozen()和Object.isSealed()方法判断是否是冻结(密封)对象，两者唯一的区别是，密封对象仍然可以修改已有属性value的值。<br>　Object.freeze() 方法可以冻结一个对象，冻结指的是不能向这个对象添加新的属性，不能修改其已有属性的值，不能删除已有属性，以及不能修改该对象已有属性的特性。也就是说，这个对象<strong>永远是不可变的</strong>。该方法返回被冻结的对象。<br>　Object.seal() 方法可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性特性，但可能可以<strong>修改已有属性的值</strong>的对象。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>　暂时总结就这么多，上面的内容大多是从js高程上看的，在线api<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\" target=\"_blank\" rel=\"external\">查的这里</a>，后面有遗漏或不准确的地方再进行修改。最后说一点，上述的object的方法很多都不支持ie8，这也是为什么vue不支持ie8，但如果是在现代高版本的浏览器进行开发时就不用顾虑了。</p>\n"},{"title":"apply与call性能分析","date":"2017-09-15T05:53:21.000Z","_content":"\n---\n#### apply call 基本概念\n* 稍有一些javascript基础的人应该对这两个函数都不会陌生，这里简单过一下基本概念。这两个方法一般都是用来调用一个函数时改变其内部this指向，换句话说：**劫持一个对象的方法，继承另外一个对象的属性并调用**。语法上两者唯一的不同就是传参形式：\n* Function.apply(obj,args)方法能接收两个参数：\nobj：这个对象将代替Function类里this对象\nargs：这个是数组，它将作为参数传给Function（args-->arguments）\n* Function.call(obj,[param1[,param2[,…[,paramN]]]]) call方法接收多个参数，比如你调用函数时传入三个参数就得这样写： fun.call(obj,arg1,arg2,arg3)，在不确定传入参数有多少个时用call来执行就很麻烦。\n* 以前我的理解就是这两个函数区别就是上面这些了，最近我才知道，他们执行起来的速度差异还挺大的。\n#### apply与call性能对比\n* 这里有个网站：[https://jsperf.com/call-apply-segu]()，执行测试用例，得出的结果是以Ops/sec（每秒操作数）为单位。根据操作系统和浏览器内核版本等不同，最后的结果也不一样，但总体来说可以得到的结论是：**call方法永远比apply方法执行速度要快**。下面贴两张运算结果的截图：\n![Safari浏览器MacOs系统](http://upload-images.jianshu.io/upload_images/6383319-cf3c9edc35aafe40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Chrome浏览器window系统](http://upload-images.jianshu.io/upload_images/6383319-94db063de6db0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 初步结论是速度和**浏览器内核**有关，但apply肯定是要比call运行速度更慢的，在chrome上甚至可以看见，结果居然差了一个位数。\n* 所以在一些框架中，**为了追求更快的执行速度就是舍弃掉apply方法或者用call来模拟apply方法。**比如我们现在框架上就是这样做的：\n```\nswitch (args.length) {\n        case 0:\n          g = gen.call(ctx);\n          break;\n        case 1:\n          g = gen.call(ctx, args[0]);\n          break;\n        case 2:\n          g = gen.call(ctx, args[0], args[1]);\n          break;\n        default:\n          g = gen.apply(ctx, args);\n      }\n```\n* 这样根据参数的长度，switch/case判断来执行不同的call语句，实在没有case的时候再执行apply方法。虽然这样写看起来代码很累赘，直接用apply就只需要一句话的事，但是如果要追求极致性能还是需要这样做（在angular2的源码中也有类似的部分，其中写了20个case判断参数长度）。\n#### 结语\n* 那是不是说以后都不要用apply方法了呢？当然不是啦~在项目中某些文件，比如启动程序时执行的，用到了apply方法，但理论上这里只执行一次，那这个时候换成call 方法带来的性能提升基本也可以忽略不计了。\n* ES7中有一个关于绑定this的提案：并排的两个冒号（::）组成的函数绑定运算符，它的左边是一个对象，右边是一个函数，通过这个运算符将左边对象作为this绑定到右边函数上面去。这种写法就不用纠结是用call还是apply了，但现在浏览器都不支持，需要用babel转义。\n```\nfoo::bar(...arguments);\n// 等同于：\nbar.apply(foo, arguments);\n```\n* 在不确定参数的情况下，如果不考虑性能，代码层面用apply来写会简洁很多。不过你能确认参数长度的时候，最好都用call方法而不用apply。\n","source":"_posts/apply与call性能分析.md","raw":"title: apply与call性能分析\ntags:\n  - JavaScript\ncategories:\n  - JavaScript\ndate: 2017-09-15 13:53:21\n---\n\n---\n#### apply call 基本概念\n* 稍有一些javascript基础的人应该对这两个函数都不会陌生，这里简单过一下基本概念。这两个方法一般都是用来调用一个函数时改变其内部this指向，换句话说：**劫持一个对象的方法，继承另外一个对象的属性并调用**。语法上两者唯一的不同就是传参形式：\n* Function.apply(obj,args)方法能接收两个参数：\nobj：这个对象将代替Function类里this对象\nargs：这个是数组，它将作为参数传给Function（args-->arguments）\n* Function.call(obj,[param1[,param2[,…[,paramN]]]]) call方法接收多个参数，比如你调用函数时传入三个参数就得这样写： fun.call(obj,arg1,arg2,arg3)，在不确定传入参数有多少个时用call来执行就很麻烦。\n* 以前我的理解就是这两个函数区别就是上面这些了，最近我才知道，他们执行起来的速度差异还挺大的。\n#### apply与call性能对比\n* 这里有个网站：[https://jsperf.com/call-apply-segu]()，执行测试用例，得出的结果是以Ops/sec（每秒操作数）为单位。根据操作系统和浏览器内核版本等不同，最后的结果也不一样，但总体来说可以得到的结论是：**call方法永远比apply方法执行速度要快**。下面贴两张运算结果的截图：\n![Safari浏览器MacOs系统](http://upload-images.jianshu.io/upload_images/6383319-cf3c9edc35aafe40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![Chrome浏览器window系统](http://upload-images.jianshu.io/upload_images/6383319-94db063de6db0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 初步结论是速度和**浏览器内核**有关，但apply肯定是要比call运行速度更慢的，在chrome上甚至可以看见，结果居然差了一个位数。\n* 所以在一些框架中，**为了追求更快的执行速度就是舍弃掉apply方法或者用call来模拟apply方法。**比如我们现在框架上就是这样做的：\n```\nswitch (args.length) {\n        case 0:\n          g = gen.call(ctx);\n          break;\n        case 1:\n          g = gen.call(ctx, args[0]);\n          break;\n        case 2:\n          g = gen.call(ctx, args[0], args[1]);\n          break;\n        default:\n          g = gen.apply(ctx, args);\n      }\n```\n* 这样根据参数的长度，switch/case判断来执行不同的call语句，实在没有case的时候再执行apply方法。虽然这样写看起来代码很累赘，直接用apply就只需要一句话的事，但是如果要追求极致性能还是需要这样做（在angular2的源码中也有类似的部分，其中写了20个case判断参数长度）。\n#### 结语\n* 那是不是说以后都不要用apply方法了呢？当然不是啦~在项目中某些文件，比如启动程序时执行的，用到了apply方法，但理论上这里只执行一次，那这个时候换成call 方法带来的性能提升基本也可以忽略不计了。\n* ES7中有一个关于绑定this的提案：并排的两个冒号（::）组成的函数绑定运算符，它的左边是一个对象，右边是一个函数，通过这个运算符将左边对象作为this绑定到右边函数上面去。这种写法就不用纠结是用call还是apply了，但现在浏览器都不支持，需要用babel转义。\n```\nfoo::bar(...arguments);\n// 等同于：\nbar.apply(foo, arguments);\n```\n* 在不确定参数的情况下，如果不考虑性能，代码层面用apply来写会简洁很多。不过你能确认参数长度的时候，最好都用call方法而不用apply。\n","slug":"apply与call性能分析","published":1,"updated":"2017-10-16T02:18:01.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9es000ee6vm57pktjsk","content":"<hr>\n<h4 id=\"apply-call-基本概念\"><a href=\"#apply-call-基本概念\" class=\"headerlink\" title=\"apply call 基本概念\"></a>apply call 基本概念</h4><ul>\n<li>稍有一些javascript基础的人应该对这两个函数都不会陌生，这里简单过一下基本概念。这两个方法一般都是用来调用一个函数时改变其内部this指向，换句话说：<strong>劫持一个对象的方法，继承另外一个对象的属性并调用</strong>。语法上两者唯一的不同就是传参形式：</li>\n<li>Function.apply(obj,args)方法能接收两个参数：<br>obj：这个对象将代替Function类里this对象<br>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</li>\n<li>Function.call(obj,[param1[,param2[,…[,paramN]]]]) call方法接收多个参数，比如你调用函数时传入三个参数就得这样写： fun.call(obj,arg1,arg2,arg3)，在不确定传入参数有多少个时用call来执行就很麻烦。</li>\n<li>以前我的理解就是这两个函数区别就是上面这些了，最近我才知道，他们执行起来的速度差异还挺大的。<h4 id=\"apply与call性能对比\"><a href=\"#apply与call性能对比\" class=\"headerlink\" title=\"apply与call性能对比\"></a>apply与call性能对比</h4></li>\n<li>这里有个网站：<a href=\"\">https://jsperf.com/call-apply-segu</a>，执行测试用例，得出的结果是以Ops/sec（每秒操作数）为单位。根据操作系统和浏览器内核版本等不同，最后的结果也不一样，但总体来说可以得到的结论是：<strong>call方法永远比apply方法执行速度要快</strong>。下面贴两张运算结果的截图：<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-cf3c9edc35aafe40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Safari浏览器MacOs系统\"></li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-94db063de6db0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Chrome浏览器window系统\"></p>\n<ul>\n<li>初步结论是速度和<strong>浏览器内核</strong>有关，但apply肯定是要比call运行速度更慢的，在chrome上甚至可以看见，结果居然差了一个位数。</li>\n<li><p>所以在一些框架中，<strong>为了追求更快的执行速度就是舍弃掉apply方法或者用call来模拟apply方法。</strong>比如我们现在框架上就是这样做的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">switch (args.length) &#123;</div><div class=\"line\">        case 0:</div><div class=\"line\">          g = gen.call(ctx);</div><div class=\"line\">          break;</div><div class=\"line\">        case 1:</div><div class=\"line\">          g = gen.call(ctx, args[0]);</div><div class=\"line\">          break;</div><div class=\"line\">        case 2:</div><div class=\"line\">          g = gen.call(ctx, args[0], args[1]);</div><div class=\"line\">          break;</div><div class=\"line\">        default:</div><div class=\"line\">          g = gen.apply(ctx, args);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这样根据参数的长度，switch/case判断来执行不同的call语句，实在没有case的时候再执行apply方法。虽然这样写看起来代码很累赘，直接用apply就只需要一句话的事，但是如果要追求极致性能还是需要这样做（在angular2的源码中也有类似的部分，其中写了20个case判断参数长度）。</p>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li>那是不是说以后都不要用apply方法了呢？当然不是啦~在项目中某些文件，比如启动程序时执行的，用到了apply方法，但理论上这里只执行一次，那这个时候换成call 方法带来的性能提升基本也可以忽略不计了。</li>\n<li><p>ES7中有一个关于绑定this的提案：并排的两个冒号（::）组成的函数绑定运算符，它的左边是一个对象，右边是一个函数，通过这个运算符将左边对象作为this绑定到右边函数上面去。这种写法就不用纠结是用call还是apply了，但现在浏览器都不支持，需要用babel转义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo::bar(...arguments);</div><div class=\"line\">// 等同于：</div><div class=\"line\">bar.apply(foo, arguments);</div></pre></td></tr></table></figure>\n</li>\n<li><p>在不确定参数的情况下，如果不考虑性能，代码层面用apply来写会简洁很多。不过你能确认参数长度的时候，最好都用call方法而不用apply。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h4 id=\"apply-call-基本概念\"><a href=\"#apply-call-基本概念\" class=\"headerlink\" title=\"apply call 基本概念\"></a>apply call 基本概念</h4><ul>\n<li>稍有一些javascript基础的人应该对这两个函数都不会陌生，这里简单过一下基本概念。这两个方法一般都是用来调用一个函数时改变其内部this指向，换句话说：<strong>劫持一个对象的方法，继承另外一个对象的属性并调用</strong>。语法上两者唯一的不同就是传参形式：</li>\n<li>Function.apply(obj,args)方法能接收两个参数：<br>obj：这个对象将代替Function类里this对象<br>args：这个是数组，它将作为参数传给Function（args–&gt;arguments）</li>\n<li>Function.call(obj,[param1[,param2[,…[,paramN]]]]) call方法接收多个参数，比如你调用函数时传入三个参数就得这样写： fun.call(obj,arg1,arg2,arg3)，在不确定传入参数有多少个时用call来执行就很麻烦。</li>\n<li>以前我的理解就是这两个函数区别就是上面这些了，最近我才知道，他们执行起来的速度差异还挺大的。<h4 id=\"apply与call性能对比\"><a href=\"#apply与call性能对比\" class=\"headerlink\" title=\"apply与call性能对比\"></a>apply与call性能对比</h4></li>\n<li>这里有个网站：<a href=\"\">https://jsperf.com/call-apply-segu</a>，执行测试用例，得出的结果是以Ops/sec（每秒操作数）为单位。根据操作系统和浏览器内核版本等不同，最后的结果也不一样，但总体来说可以得到的结论是：<strong>call方法永远比apply方法执行速度要快</strong>。下面贴两张运算结果的截图：<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-cf3c9edc35aafe40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Safari浏览器MacOs系统\"></li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-94db063de6db0239.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"Chrome浏览器window系统\"></p>\n<ul>\n<li>初步结论是速度和<strong>浏览器内核</strong>有关，但apply肯定是要比call运行速度更慢的，在chrome上甚至可以看见，结果居然差了一个位数。</li>\n<li><p>所以在一些框架中，<strong>为了追求更快的执行速度就是舍弃掉apply方法或者用call来模拟apply方法。</strong>比如我们现在框架上就是这样做的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">switch (args.length) &#123;</div><div class=\"line\">        case 0:</div><div class=\"line\">          g = gen.call(ctx);</div><div class=\"line\">          break;</div><div class=\"line\">        case 1:</div><div class=\"line\">          g = gen.call(ctx, args[0]);</div><div class=\"line\">          break;</div><div class=\"line\">        case 2:</div><div class=\"line\">          g = gen.call(ctx, args[0], args[1]);</div><div class=\"line\">          break;</div><div class=\"line\">        default:</div><div class=\"line\">          g = gen.apply(ctx, args);</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这样根据参数的长度，switch/case判断来执行不同的call语句，实在没有case的时候再执行apply方法。虽然这样写看起来代码很累赘，直接用apply就只需要一句话的事，但是如果要追求极致性能还是需要这样做（在angular2的源码中也有类似的部分，其中写了20个case判断参数长度）。</p>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li>那是不是说以后都不要用apply方法了呢？当然不是啦~在项目中某些文件，比如启动程序时执行的，用到了apply方法，但理论上这里只执行一次，那这个时候换成call 方法带来的性能提升基本也可以忽略不计了。</li>\n<li><p>ES7中有一个关于绑定this的提案：并排的两个冒号（::）组成的函数绑定运算符，它的左边是一个对象，右边是一个函数，通过这个运算符将左边对象作为this绑定到右边函数上面去。这种写法就不用纠结是用call还是apply了，但现在浏览器都不支持，需要用babel转义。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">foo::bar(...arguments);</div><div class=\"line\">// 等同于：</div><div class=\"line\">bar.apply(foo, arguments);</div></pre></td></tr></table></figure>\n</li>\n<li><p>在不确定参数的情况下，如果不考虑性能，代码层面用apply来写会简洁很多。不过你能确认参数长度的时候，最好都用call方法而不用apply。</p>\n</li>\n</ul>\n"},{"title":"mysql-workbench中PK,NN,UQ,BIN,UN,ZF,AI标识简写说明","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n* 使用mysql workbench建表时，可以设置字段标识：PK,NN,UQ,BIN,UN,ZF,AI。他们的分别表示的意思是：\nPK：primary key 主键\nNN：not null 非空\nUQ：unique 唯一索引\nBIN：binary 二进制数据(比text更大)\nUN：unsigned 无符号（非负数）\nZF：zero fill 填充0 例如字段内容是1 int(4), 则内容显示为0001 \nAI：auto increment 自增\n","source":"_posts/mysql-workbench中PK,NN,UQ,BIN,UN,ZF,AI标识简写说明.md","raw":"title: 'mysql-workbench中PK,NN,UQ,BIN,UN,ZF,AI标识简写说明'\ntags:\n  - mysql\ncategories:\n  - 后端\n  - 备忘录\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n* 使用mysql workbench建表时，可以设置字段标识：PK,NN,UQ,BIN,UN,ZF,AI。他们的分别表示的意思是：\nPK：primary key 主键\nNN：not null 非空\nUQ：unique 唯一索引\nBIN：binary 二进制数据(比text更大)\nUN：unsigned 无符号（非负数）\nZF：zero fill 填充0 例如字段内容是1 int(4), 则内容显示为0001 \nAI：auto increment 自增\n","slug":"mysql-workbench中PK,NN,UQ,BIN,UN,ZF,AI标识简写说明","published":1,"updated":"2017-10-16T02:20:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9ew000ge6vm6ex99ava","content":"<hr>\n<ul>\n<li>使用mysql workbench建表时，可以设置字段标识：PK,NN,UQ,BIN,UN,ZF,AI。他们的分别表示的意思是：<br>PK：primary key 主键<br>NN：not null 非空<br>UQ：unique 唯一索引<br>BIN：binary 二进制数据(比text更大)<br>UN：unsigned 无符号（非负数）<br>ZF：zero fill 填充0 例如字段内容是1 int(4), 则内容显示为0001<br>AI：auto increment 自增</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<ul>\n<li>使用mysql workbench建表时，可以设置字段标识：PK,NN,UQ,BIN,UN,ZF,AI。他们的分别表示的意思是：<br>PK：primary key 主键<br>NN：not null 非空<br>UQ：unique 唯一索引<br>BIN：binary 二进制数据(比text更大)<br>UN：unsigned 无符号（非负数）<br>ZF：zero fill 填充0 例如字段内容是1 int(4), 则内容显示为0001<br>AI：auto increment 自增</li>\n</ul>\n"},{"title":"vue服务端渲染(SSR)初探","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n### 前言\n首先来讲一下服务端渲染，直白的说就是在服务端拿数据进行解析渲染，**直接生成html片段返回给前端**。具体用法也有很多种比如： \n* 传统的服务端模板引擎渲染整个页面\n* 服务渲染生成htmll代码块, 前端 AJAX 获取然后js动态添加\n### 服务端渲染的优劣\n　首先是**seo**问题，前端动态渲染的内容是不能被抓取到的，而使用服务端渲染就可以解决这个问题。还有就是**首屏加载**过慢这种问题，比如在SPA中，打开首页需要初始加载很多资源，这时考虑在首屏使用服务端渲染，也是一种折中的优化方案。但是使用SSR时，势必会增加服务器的压力，还有可能会需要前后端同构，使用同样的模板引擎，这似乎与前后端分离的观点又是矛盾的。废话就说到这里，下面来看一下vue框架中的服务器渲染。\n### vue-server-renderer\n　vue-server-renderer就是vue中处理服务端加载的一个模块了，官方文档：[https://ssr.vuejs.org/en/](https://ssr.vuejs.org/en/)，暂时没有中文版的，我也只是稍微看了一些，然后写了一个简单的demo。首先新建一个test.js文件，并用npm安装依赖express、vue、vue-server-renderer。引入vue-server-renderer之后，然后新建一个temp.html作为渲染的基本模板，用createRenderer方法新建一个render实例，这里我传入temp.html作为renderer的template的参数，在后面渲染时就会以这个temp.html作为基础模板。\n```\nconst renderer = require('vue-server-renderer').createRenderer({\n\ttemplate: require('fs').readFileSync('./temp.html', 'utf-8')\n})\n```\ntemp.html:\n```\n<!DOCTYPE html><br><html lang=\"en\"><br><head><title>{{title}}</title></head>\n  <body>\n    <!--vue-ssr-outlet-->\n  </body>\n</html>\n```\n　接下来随便定义一些渲染用的数据，然后用express新建一个node服务器，再定义一个vue的实例。然后再调用renderer的renderToString方法来渲染生成html，渲染成功后返回给客户端。\n```\nconst Vue = require('vue')\nconst server = require('express')()\nconst context = {\n  title: 'hello'\n}\nconst mocktitle = '我爱吃的水果'\nconst mockdata = ['香蕉', '苹果', '橘子']\nserver.get('*', (req, res) => {\n  const app = new Vue({\n    data: {\n      url: req.url,\n      data: mockdata,\n      title: mocktitle\n    },\n    template: `<div>The visited URL is: {{ url }}\n    <h3>{{title}}</h3>\n    <p v-for='item in data'>{{item}}</p>\n    </div>`\n  })\n  renderer.renderToString(app, context, (err, html) => {\n    if (err) {\n      res.status(500).end('Internal Server Error')\n      return\n    }\n    res.end(html)\n  })\n})\nserver.listen(8080)\n```\n　注意这里渲染的数据有两种，mockdata是作为vue实例的data来渲染在实例模板中的，而context是作为基础模板的data来渲染temp.html的。可以看到在服务端用vue进行渲染的规则和前端渲染时一样，v-for、v-if等都可以正常使用。最后命令行输入node test.js，然后在浏览器打开http://localhost:8080 查看结果如下:\n![示例.png](http://upload-images.jianshu.io/upload_images/6383319-877ce0eda788c464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看到服务端直接返回了一个渲染完成的Doc，示例demo到此结束。\n### 结语\n　服务端渲染还是客户端渲染的问题，个人觉得还是要针对具体业务场景然后再做选择。\n","source":"_posts/vue服务端渲染(SSR)初探.md","raw":"title: vue服务端渲染(SSR)初探\ntags:\n  - JavaScript\n  - 服务端渲染\n  - vue\n  - node\ncategories:\n  - 服务端渲染\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n### 前言\n首先来讲一下服务端渲染，直白的说就是在服务端拿数据进行解析渲染，**直接生成html片段返回给前端**。具体用法也有很多种比如： \n* 传统的服务端模板引擎渲染整个页面\n* 服务渲染生成htmll代码块, 前端 AJAX 获取然后js动态添加\n### 服务端渲染的优劣\n　首先是**seo**问题，前端动态渲染的内容是不能被抓取到的，而使用服务端渲染就可以解决这个问题。还有就是**首屏加载**过慢这种问题，比如在SPA中，打开首页需要初始加载很多资源，这时考虑在首屏使用服务端渲染，也是一种折中的优化方案。但是使用SSR时，势必会增加服务器的压力，还有可能会需要前后端同构，使用同样的模板引擎，这似乎与前后端分离的观点又是矛盾的。废话就说到这里，下面来看一下vue框架中的服务器渲染。\n### vue-server-renderer\n　vue-server-renderer就是vue中处理服务端加载的一个模块了，官方文档：[https://ssr.vuejs.org/en/](https://ssr.vuejs.org/en/)，暂时没有中文版的，我也只是稍微看了一些，然后写了一个简单的demo。首先新建一个test.js文件，并用npm安装依赖express、vue、vue-server-renderer。引入vue-server-renderer之后，然后新建一个temp.html作为渲染的基本模板，用createRenderer方法新建一个render实例，这里我传入temp.html作为renderer的template的参数，在后面渲染时就会以这个temp.html作为基础模板。\n```\nconst renderer = require('vue-server-renderer').createRenderer({\n\ttemplate: require('fs').readFileSync('./temp.html', 'utf-8')\n})\n```\ntemp.html:\n```\n<!DOCTYPE html><br><html lang=\"en\"><br><head><title>{{title}}</title></head>\n  <body>\n    <!--vue-ssr-outlet-->\n  </body>\n</html>\n```\n　接下来随便定义一些渲染用的数据，然后用express新建一个node服务器，再定义一个vue的实例。然后再调用renderer的renderToString方法来渲染生成html，渲染成功后返回给客户端。\n```\nconst Vue = require('vue')\nconst server = require('express')()\nconst context = {\n  title: 'hello'\n}\nconst mocktitle = '我爱吃的水果'\nconst mockdata = ['香蕉', '苹果', '橘子']\nserver.get('*', (req, res) => {\n  const app = new Vue({\n    data: {\n      url: req.url,\n      data: mockdata,\n      title: mocktitle\n    },\n    template: `<div>The visited URL is: {{ url }}\n    <h3>{{title}}</h3>\n    <p v-for='item in data'>{{item}}</p>\n    </div>`\n  })\n  renderer.renderToString(app, context, (err, html) => {\n    if (err) {\n      res.status(500).end('Internal Server Error')\n      return\n    }\n    res.end(html)\n  })\n})\nserver.listen(8080)\n```\n　注意这里渲染的数据有两种，mockdata是作为vue实例的data来渲染在实例模板中的，而context是作为基础模板的data来渲染temp.html的。可以看到在服务端用vue进行渲染的规则和前端渲染时一样，v-for、v-if等都可以正常使用。最后命令行输入node test.js，然后在浏览器打开http://localhost:8080 查看结果如下:\n![示例.png](http://upload-images.jianshu.io/upload_images/6383319-877ce0eda788c464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n可以看到服务端直接返回了一个渲染完成的Doc，示例demo到此结束。\n### 结语\n　服务端渲染还是客户端渲染的问题，个人觉得还是要针对具体业务场景然后再做选择。\n","slug":"vue服务端渲染(SSR)初探","published":1,"updated":"2017-10-16T02:22:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9ex000ie6vmdtkoppwr","content":"<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>首先来讲一下服务端渲染，直白的说就是在服务端拿数据进行解析渲染，<strong>直接生成html片段返回给前端</strong>。具体用法也有很多种比如： </p>\n<ul>\n<li>传统的服务端模板引擎渲染整个页面</li>\n<li>服务渲染生成htmll代码块, 前端 AJAX 获取然后js动态添加<h3 id=\"服务端渲染的优劣\"><a href=\"#服务端渲染的优劣\" class=\"headerlink\" title=\"服务端渲染的优劣\"></a>服务端渲染的优劣</h3>　首先是<strong>seo</strong>问题，前端动态渲染的内容是不能被抓取到的，而使用服务端渲染就可以解决这个问题。还有就是<strong>首屏加载</strong>过慢这种问题，比如在SPA中，打开首页需要初始加载很多资源，这时考虑在首屏使用服务端渲染，也是一种折中的优化方案。但是使用SSR时，势必会增加服务器的压力，还有可能会需要前后端同构，使用同样的模板引擎，这似乎与前后端分离的观点又是矛盾的。废话就说到这里，下面来看一下vue框架中的服务器渲染。<h3 id=\"vue-server-renderer\"><a href=\"#vue-server-renderer\" class=\"headerlink\" title=\"vue-server-renderer\"></a>vue-server-renderer</h3>　vue-server-renderer就是vue中处理服务端加载的一个模块了，官方文档：<a href=\"https://ssr.vuejs.org/en/\" target=\"_blank\" rel=\"external\">https://ssr.vuejs.org/en/</a>，暂时没有中文版的，我也只是稍微看了一些，然后写了一个简单的demo。首先新建一个test.js文件，并用npm安装依赖express、vue、vue-server-renderer。引入vue-server-renderer之后，然后新建一个temp.html作为渲染的基本模板，用createRenderer方法新建一个render实例，这里我传入temp.html作为renderer的template的参数，在后面渲染时就会以这个temp.html作为基础模板。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const renderer = require(&apos;vue-server-renderer&apos;).createRenderer(&#123;</div><div class=\"line\">\ttemplate: require(&apos;fs&apos;).readFileSync(&apos;./temp.html&apos;, &apos;utf-8&apos;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>temp.html:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;&lt;br&gt;&lt;html lang=&quot;en&quot;&gt;&lt;br&gt;&lt;head&gt;&lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;</div><div class=\"line\">  &lt;body&gt;</div><div class=\"line\">    &lt;!--vue-ssr-outlet--&gt;</div><div class=\"line\">  &lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure></p>\n<p>　接下来随便定义一些渲染用的数据，然后用express新建一个node服务器，再定义一个vue的实例。然后再调用renderer的renderToString方法来渲染生成html，渲染成功后返回给客户端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">const Vue = require(&apos;vue&apos;)</div><div class=\"line\">const server = require(&apos;express&apos;)()</div><div class=\"line\">const context = &#123;</div><div class=\"line\">  title: &apos;hello&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">const mocktitle = &apos;我爱吃的水果&apos;</div><div class=\"line\">const mockdata = [&apos;香蕉&apos;, &apos;苹果&apos;, &apos;橘子&apos;]</div><div class=\"line\">server.get(&apos;*&apos;, (req, res) =&gt; &#123;</div><div class=\"line\">  const app = new Vue(&#123;</div><div class=\"line\">    data: &#123;</div><div class=\"line\">      url: req.url,</div><div class=\"line\">      data: mockdata,</div><div class=\"line\">      title: mocktitle</div><div class=\"line\">    &#125;,</div><div class=\"line\">    template: `&lt;div&gt;The visited URL is: &#123;&#123; url &#125;&#125;</div><div class=\"line\">    &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</div><div class=\"line\">    &lt;p v-for=&apos;item in data&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;/div&gt;`</div><div class=\"line\">  &#125;)</div><div class=\"line\">  renderer.renderToString(app, context, (err, html) =&gt; &#123;</div><div class=\"line\">    if (err) &#123;</div><div class=\"line\">      res.status(500).end(&apos;Internal Server Error&apos;)</div><div class=\"line\">      return</div><div class=\"line\">    &#125;</div><div class=\"line\">    res.end(html)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\">server.listen(8080)</div></pre></td></tr></table></figure></p>\n<p>　注意这里渲染的数据有两种，mockdata是作为vue实例的data来渲染在实例模板中的，而context是作为基础模板的data来渲染temp.html的。可以看到在服务端用vue进行渲染的规则和前端渲染时一样，v-for、v-if等都可以正常使用。最后命令行输入node test.js，然后在浏览器打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"external\">http://localhost:8080</a> 查看结果如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-877ce0eda788c464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示例.png\"><br>可以看到服务端直接返回了一个渲染完成的Doc，示例demo到此结束。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>　服务端渲染还是客户端渲染的问题，个人觉得还是要针对具体业务场景然后再做选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>首先来讲一下服务端渲染，直白的说就是在服务端拿数据进行解析渲染，<strong>直接生成html片段返回给前端</strong>。具体用法也有很多种比如： </p>\n<ul>\n<li>传统的服务端模板引擎渲染整个页面</li>\n<li>服务渲染生成htmll代码块, 前端 AJAX 获取然后js动态添加<h3 id=\"服务端渲染的优劣\"><a href=\"#服务端渲染的优劣\" class=\"headerlink\" title=\"服务端渲染的优劣\"></a>服务端渲染的优劣</h3>　首先是<strong>seo</strong>问题，前端动态渲染的内容是不能被抓取到的，而使用服务端渲染就可以解决这个问题。还有就是<strong>首屏加载</strong>过慢这种问题，比如在SPA中，打开首页需要初始加载很多资源，这时考虑在首屏使用服务端渲染，也是一种折中的优化方案。但是使用SSR时，势必会增加服务器的压力，还有可能会需要前后端同构，使用同样的模板引擎，这似乎与前后端分离的观点又是矛盾的。废话就说到这里，下面来看一下vue框架中的服务器渲染。<h3 id=\"vue-server-renderer\"><a href=\"#vue-server-renderer\" class=\"headerlink\" title=\"vue-server-renderer\"></a>vue-server-renderer</h3>　vue-server-renderer就是vue中处理服务端加载的一个模块了，官方文档：<a href=\"https://ssr.vuejs.org/en/\" target=\"_blank\" rel=\"external\">https://ssr.vuejs.org/en/</a>，暂时没有中文版的，我也只是稍微看了一些，然后写了一个简单的demo。首先新建一个test.js文件，并用npm安装依赖express、vue、vue-server-renderer。引入vue-server-renderer之后，然后新建一个temp.html作为渲染的基本模板，用createRenderer方法新建一个render实例，这里我传入temp.html作为renderer的template的参数，在后面渲染时就会以这个temp.html作为基础模板。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">const renderer = require(&apos;vue-server-renderer&apos;).createRenderer(&#123;</div><div class=\"line\">\ttemplate: require(&apos;fs&apos;).readFileSync(&apos;./temp.html&apos;, &apos;utf-8&apos;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>temp.html:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!DOCTYPE html&gt;&lt;br&gt;&lt;html lang=&quot;en&quot;&gt;&lt;br&gt;&lt;head&gt;&lt;title&gt;&#123;&#123;title&#125;&#125;&lt;/title&gt;&lt;/head&gt;</div><div class=\"line\">  &lt;body&gt;</div><div class=\"line\">    &lt;!--vue-ssr-outlet--&gt;</div><div class=\"line\">  &lt;/body&gt;</div><div class=\"line\">&lt;/html&gt;</div></pre></td></tr></table></figure></p>\n<p>　接下来随便定义一些渲染用的数据，然后用express新建一个node服务器，再定义一个vue的实例。然后再调用renderer的renderToString方法来渲染生成html，渲染成功后返回给客户端。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">const Vue = require(&apos;vue&apos;)</div><div class=\"line\">const server = require(&apos;express&apos;)()</div><div class=\"line\">const context = &#123;</div><div class=\"line\">  title: &apos;hello&apos;</div><div class=\"line\">&#125;</div><div class=\"line\">const mocktitle = &apos;我爱吃的水果&apos;</div><div class=\"line\">const mockdata = [&apos;香蕉&apos;, &apos;苹果&apos;, &apos;橘子&apos;]</div><div class=\"line\">server.get(&apos;*&apos;, (req, res) =&gt; &#123;</div><div class=\"line\">  const app = new Vue(&#123;</div><div class=\"line\">    data: &#123;</div><div class=\"line\">      url: req.url,</div><div class=\"line\">      data: mockdata,</div><div class=\"line\">      title: mocktitle</div><div class=\"line\">    &#125;,</div><div class=\"line\">    template: `&lt;div&gt;The visited URL is: &#123;&#123; url &#125;&#125;</div><div class=\"line\">    &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt;</div><div class=\"line\">    &lt;p v-for=&apos;item in data&apos;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;</div><div class=\"line\">    &lt;/div&gt;`</div><div class=\"line\">  &#125;)</div><div class=\"line\">  renderer.renderToString(app, context, (err, html) =&gt; &#123;</div><div class=\"line\">    if (err) &#123;</div><div class=\"line\">      res.status(500).end(&apos;Internal Server Error&apos;)</div><div class=\"line\">      return</div><div class=\"line\">    &#125;</div><div class=\"line\">    res.end(html)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div><div class=\"line\">server.listen(8080)</div></pre></td></tr></table></figure></p>\n<p>　注意这里渲染的数据有两种，mockdata是作为vue实例的data来渲染在实例模板中的，而context是作为基础模板的data来渲染temp.html的。可以看到在服务端用vue进行渲染的规则和前端渲染时一样，v-for、v-if等都可以正常使用。最后命令行输入node test.js，然后在浏览器打开<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"external\">http://localhost:8080</a> 查看结果如下:<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-877ce0eda788c464.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示例.png\"><br>可以看到服务端直接返回了一个渲染完成的Doc，示例demo到此结束。</p>\n<h3 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h3><p>　服务端渲染还是客户端渲染的问题，个人觉得还是要针对具体业务场景然后再做选择。</p>\n"},{"title":"vue源码解析之--核心部分core-util(二)","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n### 前言\n　在vue源码目录中有个core文件夹，其核心功能比如组件、数据绑定、虚拟dom等等都在里面。core下面又分为了components、global-api、instance、obsever、util、vdom六个部分，这次还是先以util开头，里面也封装了一些工具型的函数并且引用了外层share里面的工具函数。 \n#### debug.js error.js\n　debug.js里面主要封装的是用于开发阶段的调试相关的方法，比如一些提示警告。error.js里面只封装了一个handleError方法，用于处理错误，可在config里设置专门的errorHandler函数，没有的时候就只是一个warn警告。debug.js里面有一个repeat方法，将传入字符串重复N次。\n<code>  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };</code>\n这样写的时间复杂度大概是二分之一N，lodash里也有相似的方法，不过是用Math.round(n/2)来代替n>>=1，n>>=1就是把N转换成二进制，然后右移一位再首位补0.\n#### env.js\n　env.js主要是一些环境相关的东西，待会儿重点说的是nextTick方法。\n<code>var inBrowser = typeof window !== 'undefined'</code>\n是否在浏览器中，只要判断window对象是否存在即可。\n<code>var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n</code>\n浏览器中通过userAgent，判断浏览器的版本内核。\n<code>function isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n</code>\nisNative 判断某些方法功能是否原生支持的，比如浏览器支持symbol的话，symbol.tostring就会返回function Symbol() { [native code] }，再用正则表达式判断是否包含native code即可。\n　下面讲一下nextTick方法，这个方法也比较常用，可以在确定数据改变视图改变后再执行某些动作。代码首先定义一个自执行匿名函数的作用域，然后定义了一个nextTickHandler函数用于执行完成异步后需要执行的函数。\n<code>  function nextTickHandler () {\n    pending = false\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }</code>\npending是一个标示符，用于确保timerFunc方法不会被重复调用。接下来是根据浏览器支持情况来定义timeFunc方法：\n<code>if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve()\n    var logError = err => { console.error(err) }\n    timerFunc = () => {\n      p.then(nextTickHandler).catch(logError)\n      if (isIOS) setTimeout(noop)\n    }\n  }</code>\n如果浏览器支持promise,就用promise.then来定义timerFunc,promise的具体用法这里也不多讲了,然后我看源码上的注释是说:promise.then执行的时间可能不稳定,当他被推入一个微任务队列中时,添加一个空的setTimeout可以强制刷新微任务队列(IOS系统中).\n<code>else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1\n    var observer = new MutationObserver(nextTickHandler)\n    var textNode = document.createTextNode(String(counter))\n    observer.observe(textNode, {\n      characterData: true\n    })\n    timerFunc = () => {\n      counter = (counter + 1) % 2\n      textNode.data = String(counter)\n    }\n  }</code>\n当promise不被支持，但浏览器支持MutationObserver时。MutationObserver是html5的一个新特性，用于监测dom节点变化。初始化一个MutationObserver的实例observer ，传入的nextTickHandler是作为监测到发生变化后执行的回调函数，然后这里新建一个文本节点，再使用observer .observe()方法将文本节点绑定监听。最后定义的timerFunc就是改变文本节点的值，从而触发回调，这个回调是在文本节点重新渲染后执行的。当以上两个方法都不支持时，就只好用setTImeout来定义timerFunc了。\n<code>return function queueNextTick (cb?: Function, ctx?: Object) {\n    let _resolve\n    callbacks.push(() => {\n      if (cb) {\n        try {\n          cb.call(ctx)\n        } catch (e) {\n          handleError(e, ctx, 'nextTick')\n        }\n      } else if (_resolve) {\n        _resolve(ctx)\n      }\n    })\n    if (!pending) {\n      pending = true\n      timerFunc()\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise((resolve, reject) => {\n        _resolve = resolve\n      })\n    }\n  }</code>\n最后返回的函数其实就是nextTick自身，传入两个参数，一个是异步回调执行的函数，第二个是一个对象作为执行的环境。将传入的函数以 cb.call(ctx)的形式添加到callback中，然后再执行timerFunc。在global.api中，将这里定义的nextTick放在vue的原型上了。\nenv.js在最后定义了_Set，如果支持set那么就直接用set了，不支持的话，定义了一个_set类，并为其添加has()、add()、clear()方法。其实set的用法也比较简单，浏览器不支持的话自己重新定义一下也不复杂。\n","source":"_posts/vue源码解析之--核心部分core-util(二).md","raw":"title: vue源码解析之--核心部分core-util(二)\ntags:\n  - 框架源码\n  - JavaScript\ncategories:\n  - JavaScript\n  - vue\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n### 前言\n　在vue源码目录中有个core文件夹，其核心功能比如组件、数据绑定、虚拟dom等等都在里面。core下面又分为了components、global-api、instance、obsever、util、vdom六个部分，这次还是先以util开头，里面也封装了一些工具型的函数并且引用了外层share里面的工具函数。 \n#### debug.js error.js\n　debug.js里面主要封装的是用于开发阶段的调试相关的方法，比如一些提示警告。error.js里面只封装了一个handleError方法，用于处理错误，可在config里设置专门的errorHandler函数，没有的时候就只是一个warn警告。debug.js里面有一个repeat方法，将传入字符串重复N次。\n<code>  var repeat = function (str, n) {\n    var res = '';\n    while (n) {\n      if (n % 2 === 1) { res += str; }\n      if (n > 1) { str += str; }\n      n >>= 1;\n    }\n    return res\n  };</code>\n这样写的时间复杂度大概是二分之一N，lodash里也有相似的方法，不过是用Math.round(n/2)来代替n>>=1，n>>=1就是把N转换成二进制，然后右移一位再首位补0.\n#### env.js\n　env.js主要是一些环境相关的东西，待会儿重点说的是nextTick方法。\n<code>var inBrowser = typeof window !== 'undefined'</code>\n是否在浏览器中，只要判断window对象是否存在即可。\n<code>var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n</code>\n浏览器中通过userAgent，判断浏览器的版本内核。\n<code>function isNative (Ctor) {\n  return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n}\n</code>\nisNative 判断某些方法功能是否原生支持的，比如浏览器支持symbol的话，symbol.tostring就会返回function Symbol() { [native code] }，再用正则表达式判断是否包含native code即可。\n　下面讲一下nextTick方法，这个方法也比较常用，可以在确定数据改变视图改变后再执行某些动作。代码首先定义一个自执行匿名函数的作用域，然后定义了一个nextTickHandler函数用于执行完成异步后需要执行的函数。\n<code>  function nextTickHandler () {\n    pending = false\n    const copies = callbacks.slice(0)\n    callbacks.length = 0\n    for (let i = 0; i < copies.length; i++) {\n      copies[i]()\n    }\n  }</code>\npending是一个标示符，用于确保timerFunc方法不会被重复调用。接下来是根据浏览器支持情况来定义timeFunc方法：\n<code>if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve()\n    var logError = err => { console.error(err) }\n    timerFunc = () => {\n      p.then(nextTickHandler).catch(logError)\n      if (isIOS) setTimeout(noop)\n    }\n  }</code>\n如果浏览器支持promise,就用promise.then来定义timerFunc,promise的具体用法这里也不多讲了,然后我看源码上的注释是说:promise.then执行的时间可能不稳定,当他被推入一个微任务队列中时,添加一个空的setTimeout可以强制刷新微任务队列(IOS系统中).\n<code>else if (typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS IE11, iOS7, Android 4.4\n    var counter = 1\n    var observer = new MutationObserver(nextTickHandler)\n    var textNode = document.createTextNode(String(counter))\n    observer.observe(textNode, {\n      characterData: true\n    })\n    timerFunc = () => {\n      counter = (counter + 1) % 2\n      textNode.data = String(counter)\n    }\n  }</code>\n当promise不被支持，但浏览器支持MutationObserver时。MutationObserver是html5的一个新特性，用于监测dom节点变化。初始化一个MutationObserver的实例observer ，传入的nextTickHandler是作为监测到发生变化后执行的回调函数，然后这里新建一个文本节点，再使用observer .observe()方法将文本节点绑定监听。最后定义的timerFunc就是改变文本节点的值，从而触发回调，这个回调是在文本节点重新渲染后执行的。当以上两个方法都不支持时，就只好用setTImeout来定义timerFunc了。\n<code>return function queueNextTick (cb?: Function, ctx?: Object) {\n    let _resolve\n    callbacks.push(() => {\n      if (cb) {\n        try {\n          cb.call(ctx)\n        } catch (e) {\n          handleError(e, ctx, 'nextTick')\n        }\n      } else if (_resolve) {\n        _resolve(ctx)\n      }\n    })\n    if (!pending) {\n      pending = true\n      timerFunc()\n    }\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise((resolve, reject) => {\n        _resolve = resolve\n      })\n    }\n  }</code>\n最后返回的函数其实就是nextTick自身，传入两个参数，一个是异步回调执行的函数，第二个是一个对象作为执行的环境。将传入的函数以 cb.call(ctx)的形式添加到callback中，然后再执行timerFunc。在global.api中，将这里定义的nextTick放在vue的原型上了。\nenv.js在最后定义了_Set，如果支持set那么就直接用set了，不支持的话，定义了一个_set类，并为其添加has()、add()、clear()方法。其实set的用法也比较简单，浏览器不支持的话自己重新定义一下也不复杂。\n","slug":"vue源码解析之--核心部分core-util(二)","published":1,"updated":"2017-10-16T02:23:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9ez000le6vmx0aye7fl","content":"<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>　在vue源码目录中有个core文件夹，其核心功能比如组件、数据绑定、虚拟dom等等都在里面。core下面又分为了components、global-api、instance、obsever、util、vdom六个部分，这次还是先以util开头，里面也封装了一些工具型的函数并且引用了外层share里面的工具函数。 </p>\n<h4 id=\"debug-js-error-js\"><a href=\"#debug-js-error-js\" class=\"headerlink\" title=\"debug.js error.js\"></a>debug.js error.js</h4><p>　debug.js里面主要封装的是用于开发阶段的调试相关的方法，比如一些提示警告。error.js里面只封装了一个handleError方法，用于处理错误，可在config里设置专门的errorHandler函数，没有的时候就只是一个warn警告。debug.js里面有一个repeat方法，将传入字符串重复N次。<br><code>  var repeat = function (str, n) {<br>    var res = ‘’;<br>    while (n) {<br>      if (n % 2 === 1) { res += str; }<br>      if (n &gt; 1) { str += str; }<br>      n &gt;&gt;= 1;<br>    }<br>    return res<br>  };</code><br>这样写的时间复杂度大概是二分之一N，lodash里也有相似的方法，不过是用Math.round(n/2)来代替n&gt;&gt;=1，n&gt;&gt;=1就是把N转换成二进制，然后右移一位再首位补0.</p>\n<h4 id=\"env-js\"><a href=\"#env-js\" class=\"headerlink\" title=\"env.js\"></a>env.js</h4><p>　env.js主要是一些环境相关的东西，待会儿重点说的是nextTick方法。<br><code>var inBrowser = typeof window !== ‘undefined’</code><br>是否在浏览器中，只要判断window对象是否存在即可。<br><code>var UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();<br></code><br>浏览器中通过userAgent，判断浏览器的版本内核。<br><code>function isNative (Ctor) {<br>  return typeof Ctor === ‘function’ &amp;&amp; /native code/.test(Ctor.toString())<br>}<br></code><br>isNative 判断某些方法功能是否原生支持的，比如浏览器支持symbol的话，symbol.tostring就会返回function Symbol() { [native code] }，再用正则表达式判断是否包含native code即可。<br>　下面讲一下nextTick方法，这个方法也比较常用，可以在确定数据改变视图改变后再执行某些动作。代码首先定义一个自执行匿名函数的作用域，然后定义了一个nextTickHandler函数用于执行完成异步后需要执行的函数。<br><code>  function nextTickHandler () {<br>    pending = false<br>    const copies = callbacks.slice(0)<br>    callbacks.length = 0<br>    for (let i = 0; i &lt; copies.length; i++) {<br>      copies<a href=\"\">i</a><br>    }<br>  }</code><br>pending是一个标示符，用于确保timerFunc方法不会被重复调用。接下来是根据浏览器支持情况来定义timeFunc方法：<br><code>if (typeof Promise !== ‘undefined’ &amp;&amp; isNative(Promise)) {<br>    var p = Promise.resolve()<br>    var logError = err =&gt; { console.error(err) }<br>    timerFunc = () =&gt; {<br>      p.then(nextTickHandler).catch(logError)<br>      if (isIOS) setTimeout(noop)<br>    }<br>  }</code><br>如果浏览器支持promise,就用promise.then来定义timerFunc,promise的具体用法这里也不多讲了,然后我看源码上的注释是说:promise.then执行的时间可能不稳定,当他被推入一个微任务队列中时,添加一个空的setTimeout可以强制刷新微任务队列(IOS系统中).<br><code>else if (typeof MutationObserver !== ‘undefined’ &amp;&amp; (<br>    isNative(MutationObserver) ||<br>    // PhantomJS and iOS 7.x<br>    MutationObserver.toString() === ‘[object MutationObserverConstructor]’<br>  )) {<br>    // use MutationObserver where native Promise is not available,<br>    // e.g. PhantomJS IE11, iOS7, Android 4.4<br>    var counter = 1<br>    var observer = new MutationObserver(nextTickHandler)<br>    var textNode = document.createTextNode(String(counter))<br>    observer.observe(textNode, {<br>      characterData: true<br>    })<br>    timerFunc = () =&gt; {<br>      counter = (counter + 1) % 2<br>      textNode.data = String(counter)<br>    }<br>  }</code><br>当promise不被支持，但浏览器支持MutationObserver时。MutationObserver是html5的一个新特性，用于监测dom节点变化。初始化一个MutationObserver的实例observer ，传入的nextTickHandler是作为监测到发生变化后执行的回调函数，然后这里新建一个文本节点，再使用observer .observe()方法将文本节点绑定监听。最后定义的timerFunc就是改变文本节点的值，从而触发回调，这个回调是在文本节点重新渲染后执行的。当以上两个方法都不支持时，就只好用setTImeout来定义timerFunc了。<br><code>return function queueNextTick (cb?: Function, ctx?: Object) {<br>    let _resolve<br>    callbacks.push(() =&gt; {<br>      if (cb) {<br>        try {<br>          cb.call(ctx)<br>        } catch (e) {<br>          handleError(e, ctx, ‘nextTick’)<br>        }<br>      } else if (_resolve) {<br>        _resolve(ctx)<br>      }<br>    })<br>    if (!pending) {<br>      pending = true<br>      timerFunc()<br>    }<br>    if (!cb &amp;&amp; typeof Promise !== ‘undefined’) {<br>      return new Promise((resolve, reject) =&gt; {<br>        _resolve = resolve<br>      })<br>    }<br>  }</code><br>最后返回的函数其实就是nextTick自身，传入两个参数，一个是异步回调执行的函数，第二个是一个对象作为执行的环境。将传入的函数以 cb.call(ctx)的形式添加到callback中，然后再执行timerFunc。在global.api中，将这里定义的nextTick放在vue的原型上了。<br>env.js在最后定义了_Set，如果支持set那么就直接用set了，不支持的话，定义了一个_set类，并为其添加has()、add()、clear()方法。其实set的用法也比较简单，浏览器不支持的话自己重新定义一下也不复杂。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>　在vue源码目录中有个core文件夹，其核心功能比如组件、数据绑定、虚拟dom等等都在里面。core下面又分为了components、global-api、instance、obsever、util、vdom六个部分，这次还是先以util开头，里面也封装了一些工具型的函数并且引用了外层share里面的工具函数。 </p>\n<h4 id=\"debug-js-error-js\"><a href=\"#debug-js-error-js\" class=\"headerlink\" title=\"debug.js error.js\"></a>debug.js error.js</h4><p>　debug.js里面主要封装的是用于开发阶段的调试相关的方法，比如一些提示警告。error.js里面只封装了一个handleError方法，用于处理错误，可在config里设置专门的errorHandler函数，没有的时候就只是一个warn警告。debug.js里面有一个repeat方法，将传入字符串重复N次。<br><code>  var repeat = function (str, n) {<br>    var res = ‘’;<br>    while (n) {<br>      if (n % 2 === 1) { res += str; }<br>      if (n &gt; 1) { str += str; }<br>      n &gt;&gt;= 1;<br>    }<br>    return res<br>  };</code><br>这样写的时间复杂度大概是二分之一N，lodash里也有相似的方法，不过是用Math.round(n/2)来代替n&gt;&gt;=1，n&gt;&gt;=1就是把N转换成二进制，然后右移一位再首位补0.</p>\n<h4 id=\"env-js\"><a href=\"#env-js\" class=\"headerlink\" title=\"env.js\"></a>env.js</h4><p>　env.js主要是一些环境相关的东西，待会儿重点说的是nextTick方法。<br><code>var inBrowser = typeof window !== ‘undefined’</code><br>是否在浏览器中，只要判断window对象是否存在即可。<br><code>var UA = inBrowser &amp;&amp; window.navigator.userAgent.toLowerCase();<br></code><br>浏览器中通过userAgent，判断浏览器的版本内核。<br><code>function isNative (Ctor) {<br>  return typeof Ctor === ‘function’ &amp;&amp; /native code/.test(Ctor.toString())<br>}<br></code><br>isNative 判断某些方法功能是否原生支持的，比如浏览器支持symbol的话，symbol.tostring就会返回function Symbol() { [native code] }，再用正则表达式判断是否包含native code即可。<br>　下面讲一下nextTick方法，这个方法也比较常用，可以在确定数据改变视图改变后再执行某些动作。代码首先定义一个自执行匿名函数的作用域，然后定义了一个nextTickHandler函数用于执行完成异步后需要执行的函数。<br><code>  function nextTickHandler () {<br>    pending = false<br>    const copies = callbacks.slice(0)<br>    callbacks.length = 0<br>    for (let i = 0; i &lt; copies.length; i++) {<br>      copies<a href=\"\">i</a><br>    }<br>  }</code><br>pending是一个标示符，用于确保timerFunc方法不会被重复调用。接下来是根据浏览器支持情况来定义timeFunc方法：<br><code>if (typeof Promise !== ‘undefined’ &amp;&amp; isNative(Promise)) {<br>    var p = Promise.resolve()<br>    var logError = err =&gt; { console.error(err) }<br>    timerFunc = () =&gt; {<br>      p.then(nextTickHandler).catch(logError)<br>      if (isIOS) setTimeout(noop)<br>    }<br>  }</code><br>如果浏览器支持promise,就用promise.then来定义timerFunc,promise的具体用法这里也不多讲了,然后我看源码上的注释是说:promise.then执行的时间可能不稳定,当他被推入一个微任务队列中时,添加一个空的setTimeout可以强制刷新微任务队列(IOS系统中).<br><code>else if (typeof MutationObserver !== ‘undefined’ &amp;&amp; (<br>    isNative(MutationObserver) ||<br>    // PhantomJS and iOS 7.x<br>    MutationObserver.toString() === ‘[object MutationObserverConstructor]’<br>  )) {<br>    // use MutationObserver where native Promise is not available,<br>    // e.g. PhantomJS IE11, iOS7, Android 4.4<br>    var counter = 1<br>    var observer = new MutationObserver(nextTickHandler)<br>    var textNode = document.createTextNode(String(counter))<br>    observer.observe(textNode, {<br>      characterData: true<br>    })<br>    timerFunc = () =&gt; {<br>      counter = (counter + 1) % 2<br>      textNode.data = String(counter)<br>    }<br>  }</code><br>当promise不被支持，但浏览器支持MutationObserver时。MutationObserver是html5的一个新特性，用于监测dom节点变化。初始化一个MutationObserver的实例observer ，传入的nextTickHandler是作为监测到发生变化后执行的回调函数，然后这里新建一个文本节点，再使用observer .observe()方法将文本节点绑定监听。最后定义的timerFunc就是改变文本节点的值，从而触发回调，这个回调是在文本节点重新渲染后执行的。当以上两个方法都不支持时，就只好用setTImeout来定义timerFunc了。<br><code>return function queueNextTick (cb?: Function, ctx?: Object) {<br>    let _resolve<br>    callbacks.push(() =&gt; {<br>      if (cb) {<br>        try {<br>          cb.call(ctx)<br>        } catch (e) {<br>          handleError(e, ctx, ‘nextTick’)<br>        }<br>      } else if (_resolve) {<br>        _resolve(ctx)<br>      }<br>    })<br>    if (!pending) {<br>      pending = true<br>      timerFunc()<br>    }<br>    if (!cb &amp;&amp; typeof Promise !== ‘undefined’) {<br>      return new Promise((resolve, reject) =&gt; {<br>        _resolve = resolve<br>      })<br>    }<br>  }</code><br>最后返回的函数其实就是nextTick自身，传入两个参数，一个是异步回调执行的函数，第二个是一个对象作为执行的环境。将传入的函数以 cb.call(ctx)的形式添加到callback中，然后再执行timerFunc。在global.api中，将这里定义的nextTick放在vue的原型上了。<br>env.js在最后定义了_Set，如果支持set那么就直接用set了，不支持的话，定义了一个_set类，并为其添加has()、add()、clear()方法。其实set的用法也比较简单，浏览器不支持的话自己重新定义一下也不复杂。</p>\n"},{"title":"vue源码解析之--工具函数(一)","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n　工具函数是每个框架类库的基本的组成部分，本篇分析的是/shared/util.js文件，从中挑选的部分方法函数，比较常见基础的方法我就跳过了。值得一说的是，编译合成前的源码都用到了**flow.js**，可以理解为一个javascript的静态类型检查器，有点像typescript，可以对js的变量进行类型定义、检查错误等，然后再通过编译生成正常的js代码，文件开头有/* @flow */注释的都是用到了flow的。\n\n#### 1.makeMap()\n　先来看这个makemap，传入一个字符串和是否区分大小写的标示符，然后在函数内部生成一个map对象，传入字符串分割 ',' 生成的数组的值作为map的属性名，值为true，然后**返回一个函数用来判断一个变量是否包含在传入字符串里**。\n<code>\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}</code>\n 　这里也是个典型的闭包的应用，返回的函数调用了内部的map数组，所以map的作用域会一直存在不会被回收掉。这个方法主要用在检查变量命名是否合法之类的。\n\n#### 2.cached()\n<code>function cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n</code>\n　新建一个cache对象，这个方法传入参数是一个**处理字符串的函数**，返回这个**传入函数的缓存版本**。就是每次调用这个处理字符串函数时，会把被传入的字符串存到cache中，下次再传入相同字符串时就直接用cache缓存了(又是巧用闭包...)。\n#### 3.camelize、capitalize、hyphenateRE\n<code>var camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});</code>\n　这三个函数都是**处理字符串**的，主要是对**正则表达式的应用**，结合上面提到的cache生成的缓存版函数camelize()用于将中划线命名的变成驼峰法命名，camelize('abc-def') = abcDef；capitalize()用于将首字母大写，hyphenateRE()作用与camelize()相反，用于将驼峰法命名转换成中划线。(这里没看懂为什么要用两次replace方法？)\n### 4.bind()\n<code>\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  boundFn._length = fn.length;\n  return boundFn\n}</code>\n　封装了一个简单的bind方法，根据传入的对象(作用域)和函数，返回一个绑定函数，即在传入的对象调用传入的函数。源码解释说比原生绑定更快，这里我也不太明白为什么。。。\n### 5.genStaticKeys()\n<code>\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n</code>\n　这个函数主要是把传入的**编译模块，生成为静态键值组成的字符串**。主要用到了**reduce**这个方法，即把数组每一项重叠生成一个总和，第二个参数[]表示初始值，生成的总数组用逗号分隔转换为字符串。我看了下似乎这个方法只是在定义baseOptions的staticKeys属性时用到了。\n### 6.looseEqual() looseIndexOf()\n<code>\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}</code>\n　looseEqual()用于判断两个传入参数是否相等，同是对象的情况下先用**JSON.stringfiy()**转换，报错的时候直接用全等判断，这里顺便提一下什么时候JSON.stringfiy()会报错呢？**circular structure**的时候，举一个例子<code>var obj = {a:1}; obj.b=obj;</code> 这个时候JSON.stringfiy(obj)就会报错啦~都不是对象的时候转化为string比较，其他情况都是false。\n　looseIndexOf()传入一个数组和一个值，如果传入值在数组里则返回对应的index，不在返回-1，这里也是依次用looseEqual来进行比较.ES6里面数组的扩展方法有一个indexOf也是类似的方法，判断数组是否包含某个值。\n### 7.once()\n<code>function once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}</code>\n　让一个函数只调用一次，也是典型的闭包调用，返回一个由called标示控制的函数，调用此函数时，called标示符改变，下次调用就无效了。\n","source":"_posts/vue源码解析之--工具函数(一).md","raw":"title: vue源码解析之--工具函数(一)\ntags:\n  - JavaScript\n  - 框架源码\ncategories:\n  - JavaScript\n  - vue\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n　工具函数是每个框架类库的基本的组成部分，本篇分析的是/shared/util.js文件，从中挑选的部分方法函数，比较常见基础的方法我就跳过了。值得一说的是，编译合成前的源码都用到了**flow.js**，可以理解为一个javascript的静态类型检查器，有点像typescript，可以对js的变量进行类型定义、检查错误等，然后再通过编译生成正常的js代码，文件开头有/* @flow */注释的都是用到了flow的。\n\n#### 1.makeMap()\n　先来看这个makemap，传入一个字符串和是否区分大小写的标示符，然后在函数内部生成一个map对象，传入字符串分割 ',' 生成的数组的值作为map的属性名，值为true，然后**返回一个函数用来判断一个变量是否包含在传入字符串里**。\n<code>\nfunction makeMap (\n  str,\n  expectsLowerCase\n) {\n  var map = Object.create(null);\n  var list = str.split(',');\n  for (var i = 0; i < list.length; i++) {\n    map[list[i]] = true;\n  }\n  return expectsLowerCase\n    ? function (val) { return map[val.toLowerCase()]; }\n    : function (val) { return map[val]; }\n}</code>\n 　这里也是个典型的闭包的应用，返回的函数调用了内部的map数组，所以map的作用域会一直存在不会被回收掉。这个方法主要用在检查变量命名是否合法之类的。\n\n#### 2.cached()\n<code>function cached (fn) {\n  var cache = Object.create(null);\n  return (function cachedFn (str) {\n    var hit = cache[str];\n    return hit || (cache[str] = fn(str))\n  })\n}\n</code>\n　新建一个cache对象，这个方法传入参数是一个**处理字符串的函数**，返回这个**传入函数的缓存版本**。就是每次调用这个处理字符串函数时，会把被传入的字符串存到cache中，下次再传入相同字符串时就直接用cache缓存了(又是巧用闭包...)。\n#### 3.camelize、capitalize、hyphenateRE\n<code>var camelizeRE = /-(\\w)/g;\nvar camelize = cached(function (str) {\n  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n});\nvar capitalize = cached(function (str) {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n});\nvar hyphenateRE = /([^-])([A-Z])/g;\nvar hyphenate = cached(function (str) {\n  return str\n    .replace(hyphenateRE, '$1-$2')\n    .replace(hyphenateRE, '$1-$2')\n    .toLowerCase()\n});</code>\n　这三个函数都是**处理字符串**的，主要是对**正则表达式的应用**，结合上面提到的cache生成的缓存版函数camelize()用于将中划线命名的变成驼峰法命名，camelize('abc-def') = abcDef；capitalize()用于将首字母大写，hyphenateRE()作用与camelize()相反，用于将驼峰法命名转换成中划线。(这里没看懂为什么要用两次replace方法？)\n### 4.bind()\n<code>\nfunction bind (fn, ctx) {\n  function boundFn (a) {\n    var l = arguments.length;\n    return l\n      ? l > 1\n        ? fn.apply(ctx, arguments)\n        : fn.call(ctx, a)\n      : fn.call(ctx)\n  }\n  boundFn._length = fn.length;\n  return boundFn\n}</code>\n　封装了一个简单的bind方法，根据传入的对象(作用域)和函数，返回一个绑定函数，即在传入的对象调用传入的函数。源码解释说比原生绑定更快，这里我也不太明白为什么。。。\n### 5.genStaticKeys()\n<code>\nfunction genStaticKeys (modules) {\n  return modules.reduce(function (keys, m) {\n    return keys.concat(m.staticKeys || [])\n  }, []).join(',')\n}\n</code>\n　这个函数主要是把传入的**编译模块，生成为静态键值组成的字符串**。主要用到了**reduce**这个方法，即把数组每一项重叠生成一个总和，第二个参数[]表示初始值，生成的总数组用逗号分隔转换为字符串。我看了下似乎这个方法只是在定义baseOptions的staticKeys属性时用到了。\n### 6.looseEqual() looseIndexOf()\n<code>\nfunction looseEqual (a, b) {\n  var isObjectA = isObject(a);\n  var isObjectB = isObject(b);\n  if (isObjectA && isObjectB) {\n    try {\n      return JSON.stringify(a) === JSON.stringify(b)\n    } catch (e) {\n      // possible circular reference\n      return a === b\n    }\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b)\n  } else {\n    return false\n  }\n}\nfunction looseIndexOf (arr, val) {\n  for (var i = 0; i < arr.length; i++) {\n    if (looseEqual(arr[i], val)) { return i }\n  }\n  return -1\n}</code>\n　looseEqual()用于判断两个传入参数是否相等，同是对象的情况下先用**JSON.stringfiy()**转换，报错的时候直接用全等判断，这里顺便提一下什么时候JSON.stringfiy()会报错呢？**circular structure**的时候，举一个例子<code>var obj = {a:1}; obj.b=obj;</code> 这个时候JSON.stringfiy(obj)就会报错啦~都不是对象的时候转化为string比较，其他情况都是false。\n　looseIndexOf()传入一个数组和一个值，如果传入值在数组里则返回对应的index，不在返回-1，这里也是依次用looseEqual来进行比较.ES6里面数组的扩展方法有一个indexOf也是类似的方法，判断数组是否包含某个值。\n### 7.once()\n<code>function once (fn) {\n  var called = false;\n  return function () {\n    if (!called) {\n      called = true;\n      fn.apply(this, arguments);\n    }\n  }\n}</code>\n　让一个函数只调用一次，也是典型的闭包调用，返回一个由called标示控制的函数，调用此函数时，called标示符改变，下次调用就无效了。\n","slug":"vue源码解析之--工具函数(一)","published":1,"updated":"2017-10-16T02:23:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9f0000ne6vmzezcy9gu","content":"<hr>\n<p>　工具函数是每个框架类库的基本的组成部分，本篇分析的是/shared/util.js文件，从中挑选的部分方法函数，比较常见基础的方法我就跳过了。值得一说的是，编译合成前的源码都用到了<strong>flow.js</strong>，可以理解为一个javascript的静态类型检查器，有点像typescript，可以对js的变量进行类型定义、检查错误等，然后再通过编译生成正常的js代码，文件开头有/<em> @flow </em>/注释的都是用到了flow的。</p>\n<h4 id=\"1-makeMap\"><a href=\"#1-makeMap\" class=\"headerlink\" title=\"1.makeMap()\"></a>1.makeMap()</h4><p>　先来看这个makemap，传入一个字符串和是否区分大小写的标示符，然后在函数内部生成一个map对象，传入字符串分割 ‘,’ 生成的数组的值作为map的属性名，值为true，然后<strong>返回一个函数用来判断一个变量是否包含在传入字符串里</strong>。<br><code><br>function makeMap (<br>  str,<br>  expectsLowerCase<br>) {<br>  var map = Object.create(null);<br>  var list = str.split(‘,’);<br>  for (var i = 0; i &lt; list.length; i++) {<br>    map[list[i]] = true;<br>  }<br>  return expectsLowerCase<br>    ? function (val) { return map[val.toLowerCase()]; }<br>    : function (val) { return map[val]; }<br>}</code><br> 　这里也是个典型的闭包的应用，返回的函数调用了内部的map数组，所以map的作用域会一直存在不会被回收掉。这个方法主要用在检查变量命名是否合法之类的。</p>\n<h4 id=\"2-cached\"><a href=\"#2-cached\" class=\"headerlink\" title=\"2.cached()\"></a>2.cached()</h4><p><code>function cached (fn) {<br>  var cache = Object.create(null);<br>  return (function cachedFn (str) {<br>    var hit = cache[str];<br>    return hit || (cache[str] = fn(str))<br>  })<br>}<br></code><br>　新建一个cache对象，这个方法传入参数是一个<strong>处理字符串的函数</strong>，返回这个<strong>传入函数的缓存版本</strong>。就是每次调用这个处理字符串函数时，会把被传入的字符串存到cache中，下次再传入相同字符串时就直接用cache缓存了(又是巧用闭包…)。</p>\n<h4 id=\"3-camelize、capitalize、hyphenateRE\"><a href=\"#3-camelize、capitalize、hyphenateRE\" class=\"headerlink\" title=\"3.camelize、capitalize、hyphenateRE\"></a>3.camelize、capitalize、hyphenateRE</h4><p><code>var camelizeRE = /-(\\w)/g;<br>var camelize = cached(function (str) {<br>  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ‘’; })<br>});<br>var capitalize = cached(function (str) {<br>  return str.charAt(0).toUpperCase() + str.slice(1)<br>});<br>var hyphenateRE = /([^-])([A-Z])/g;<br>var hyphenate = cached(function (str) {<br>  return str<br>    .replace(hyphenateRE, ‘$1-$2’)<br>    .replace(hyphenateRE, ‘$1-$2’)<br>    .toLowerCase()<br>});</code><br>　这三个函数都是<strong>处理字符串</strong>的，主要是对<strong>正则表达式的应用</strong>，结合上面提到的cache生成的缓存版函数camelize()用于将中划线命名的变成驼峰法命名，camelize(‘abc-def’) = abcDef；capitalize()用于将首字母大写，hyphenateRE()作用与camelize()相反，用于将驼峰法命名转换成中划线。(这里没看懂为什么要用两次replace方法？)</p>\n<h3 id=\"4-bind\"><a href=\"#4-bind\" class=\"headerlink\" title=\"4.bind()\"></a>4.bind()</h3><p><code><br>function bind (fn, ctx) {<br>  function boundFn (a) {<br>    var l = arguments.length;<br>    return l<br>      ? l &gt; 1<br>        ? fn.apply(ctx, arguments)<br>        : fn.call(ctx, a)<br>      : fn.call(ctx)<br>  }<br>  boundFn._length = fn.length;<br>  return boundFn<br>}</code><br>　封装了一个简单的bind方法，根据传入的对象(作用域)和函数，返回一个绑定函数，即在传入的对象调用传入的函数。源码解释说比原生绑定更快，这里我也不太明白为什么。。。</p>\n<h3 id=\"5-genStaticKeys\"><a href=\"#5-genStaticKeys\" class=\"headerlink\" title=\"5.genStaticKeys()\"></a>5.genStaticKeys()</h3><p><code><br>function genStaticKeys (modules) {<br>  return modules.reduce(function (keys, m) {<br>    return keys.concat(m.staticKeys || [])<br>  }, []).join(‘,’)<br>}<br></code><br>　这个函数主要是把传入的<strong>编译模块，生成为静态键值组成的字符串</strong>。主要用到了<strong>reduce</strong>这个方法，即把数组每一项重叠生成一个总和，第二个参数[]表示初始值，生成的总数组用逗号分隔转换为字符串。我看了下似乎这个方法只是在定义baseOptions的staticKeys属性时用到了。</p>\n<h3 id=\"6-looseEqual-looseIndexOf\"><a href=\"#6-looseEqual-looseIndexOf\" class=\"headerlink\" title=\"6.looseEqual() looseIndexOf()\"></a>6.looseEqual() looseIndexOf()</h3><p><code><br>function looseEqual (a, b) {<br>  var isObjectA = isObject(a);<br>  var isObjectB = isObject(b);<br>  if (isObjectA &amp;&amp; isObjectB) {<br>    try {<br>      return JSON.stringify(a) === JSON.stringify(b)<br>    } catch (e) {<br>      // possible circular reference<br>      return a === b<br>    }<br>  } else if (!isObjectA &amp;&amp; !isObjectB) {<br>    return String(a) === String(b)<br>  } else {<br>    return false<br>  }<br>}<br>function looseIndexOf (arr, val) {<br>  for (var i = 0; i &lt; arr.length; i++) {<br>    if (looseEqual(arr[i], val)) { return i }<br>  }<br>  return -1<br>}</code><br>　looseEqual()用于判断两个传入参数是否相等，同是对象的情况下先用<strong>JSON.stringfiy()</strong>转换，报错的时候直接用全等判断，这里顺便提一下什么时候JSON.stringfiy()会报错呢？<strong>circular structure</strong>的时候，举一个例子<code>var obj = {a:1}; obj.b=obj;</code> 这个时候JSON.stringfiy(obj)就会报错啦~都不是对象的时候转化为string比较，其他情况都是false。<br>　looseIndexOf()传入一个数组和一个值，如果传入值在数组里则返回对应的index，不在返回-1，这里也是依次用looseEqual来进行比较.ES6里面数组的扩展方法有一个indexOf也是类似的方法，判断数组是否包含某个值。</p>\n<h3 id=\"7-once\"><a href=\"#7-once\" class=\"headerlink\" title=\"7.once()\"></a>7.once()</h3><p><code>function once (fn) {<br>  var called = false;<br>  return function () {<br>    if (!called) {<br>      called = true;<br>      fn.apply(this, arguments);<br>    }<br>  }<br>}</code><br>　让一个函数只调用一次，也是典型的闭包调用，返回一个由called标示控制的函数，调用此函数时，called标示符改变，下次调用就无效了。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<p>　工具函数是每个框架类库的基本的组成部分，本篇分析的是/shared/util.js文件，从中挑选的部分方法函数，比较常见基础的方法我就跳过了。值得一说的是，编译合成前的源码都用到了<strong>flow.js</strong>，可以理解为一个javascript的静态类型检查器，有点像typescript，可以对js的变量进行类型定义、检查错误等，然后再通过编译生成正常的js代码，文件开头有/<em> @flow </em>/注释的都是用到了flow的。</p>\n<h4 id=\"1-makeMap\"><a href=\"#1-makeMap\" class=\"headerlink\" title=\"1.makeMap()\"></a>1.makeMap()</h4><p>　先来看这个makemap，传入一个字符串和是否区分大小写的标示符，然后在函数内部生成一个map对象，传入字符串分割 ‘,’ 生成的数组的值作为map的属性名，值为true，然后<strong>返回一个函数用来判断一个变量是否包含在传入字符串里</strong>。<br><code><br>function makeMap (<br>  str,<br>  expectsLowerCase<br>) {<br>  var map = Object.create(null);<br>  var list = str.split(‘,’);<br>  for (var i = 0; i &lt; list.length; i++) {<br>    map[list[i]] = true;<br>  }<br>  return expectsLowerCase<br>    ? function (val) { return map[val.toLowerCase()]; }<br>    : function (val) { return map[val]; }<br>}</code><br> 　这里也是个典型的闭包的应用，返回的函数调用了内部的map数组，所以map的作用域会一直存在不会被回收掉。这个方法主要用在检查变量命名是否合法之类的。</p>\n<h4 id=\"2-cached\"><a href=\"#2-cached\" class=\"headerlink\" title=\"2.cached()\"></a>2.cached()</h4><p><code>function cached (fn) {<br>  var cache = Object.create(null);<br>  return (function cachedFn (str) {<br>    var hit = cache[str];<br>    return hit || (cache[str] = fn(str))<br>  })<br>}<br></code><br>　新建一个cache对象，这个方法传入参数是一个<strong>处理字符串的函数</strong>，返回这个<strong>传入函数的缓存版本</strong>。就是每次调用这个处理字符串函数时，会把被传入的字符串存到cache中，下次再传入相同字符串时就直接用cache缓存了(又是巧用闭包…)。</p>\n<h4 id=\"3-camelize、capitalize、hyphenateRE\"><a href=\"#3-camelize、capitalize、hyphenateRE\" class=\"headerlink\" title=\"3.camelize、capitalize、hyphenateRE\"></a>3.camelize、capitalize、hyphenateRE</h4><p><code>var camelizeRE = /-(\\w)/g;<br>var camelize = cached(function (str) {<br>  return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ‘’; })<br>});<br>var capitalize = cached(function (str) {<br>  return str.charAt(0).toUpperCase() + str.slice(1)<br>});<br>var hyphenateRE = /([^-])([A-Z])/g;<br>var hyphenate = cached(function (str) {<br>  return str<br>    .replace(hyphenateRE, ‘$1-$2’)<br>    .replace(hyphenateRE, ‘$1-$2’)<br>    .toLowerCase()<br>});</code><br>　这三个函数都是<strong>处理字符串</strong>的，主要是对<strong>正则表达式的应用</strong>，结合上面提到的cache生成的缓存版函数camelize()用于将中划线命名的变成驼峰法命名，camelize(‘abc-def’) = abcDef；capitalize()用于将首字母大写，hyphenateRE()作用与camelize()相反，用于将驼峰法命名转换成中划线。(这里没看懂为什么要用两次replace方法？)</p>\n<h3 id=\"4-bind\"><a href=\"#4-bind\" class=\"headerlink\" title=\"4.bind()\"></a>4.bind()</h3><p><code><br>function bind (fn, ctx) {<br>  function boundFn (a) {<br>    var l = arguments.length;<br>    return l<br>      ? l &gt; 1<br>        ? fn.apply(ctx, arguments)<br>        : fn.call(ctx, a)<br>      : fn.call(ctx)<br>  }<br>  boundFn._length = fn.length;<br>  return boundFn<br>}</code><br>　封装了一个简单的bind方法，根据传入的对象(作用域)和函数，返回一个绑定函数，即在传入的对象调用传入的函数。源码解释说比原生绑定更快，这里我也不太明白为什么。。。</p>\n<h3 id=\"5-genStaticKeys\"><a href=\"#5-genStaticKeys\" class=\"headerlink\" title=\"5.genStaticKeys()\"></a>5.genStaticKeys()</h3><p><code><br>function genStaticKeys (modules) {<br>  return modules.reduce(function (keys, m) {<br>    return keys.concat(m.staticKeys || [])<br>  }, []).join(‘,’)<br>}<br></code><br>　这个函数主要是把传入的<strong>编译模块，生成为静态键值组成的字符串</strong>。主要用到了<strong>reduce</strong>这个方法，即把数组每一项重叠生成一个总和，第二个参数[]表示初始值，生成的总数组用逗号分隔转换为字符串。我看了下似乎这个方法只是在定义baseOptions的staticKeys属性时用到了。</p>\n<h3 id=\"6-looseEqual-looseIndexOf\"><a href=\"#6-looseEqual-looseIndexOf\" class=\"headerlink\" title=\"6.looseEqual() looseIndexOf()\"></a>6.looseEqual() looseIndexOf()</h3><p><code><br>function looseEqual (a, b) {<br>  var isObjectA = isObject(a);<br>  var isObjectB = isObject(b);<br>  if (isObjectA &amp;&amp; isObjectB) {<br>    try {<br>      return JSON.stringify(a) === JSON.stringify(b)<br>    } catch (e) {<br>      // possible circular reference<br>      return a === b<br>    }<br>  } else if (!isObjectA &amp;&amp; !isObjectB) {<br>    return String(a) === String(b)<br>  } else {<br>    return false<br>  }<br>}<br>function looseIndexOf (arr, val) {<br>  for (var i = 0; i &lt; arr.length; i++) {<br>    if (looseEqual(arr[i], val)) { return i }<br>  }<br>  return -1<br>}</code><br>　looseEqual()用于判断两个传入参数是否相等，同是对象的情况下先用<strong>JSON.stringfiy()</strong>转换，报错的时候直接用全等判断，这里顺便提一下什么时候JSON.stringfiy()会报错呢？<strong>circular structure</strong>的时候，举一个例子<code>var obj = {a:1}; obj.b=obj;</code> 这个时候JSON.stringfiy(obj)就会报错啦~都不是对象的时候转化为string比较，其他情况都是false。<br>　looseIndexOf()传入一个数组和一个值，如果传入值在数组里则返回对应的index，不在返回-1，这里也是依次用looseEqual来进行比较.ES6里面数组的扩展方法有一个indexOf也是类似的方法，判断数组是否包含某个值。</p>\n<h3 id=\"7-once\"><a href=\"#7-once\" class=\"headerlink\" title=\"7.once()\"></a>7.once()</h3><p><code>function once (fn) {<br>  var called = false;<br>  return function () {<br>    if (!called) {<br>      called = true;<br>      fn.apply(this, arguments);<br>    }<br>  }<br>}</code><br>　让一个函数只调用一次，也是典型的闭包调用，返回一个由called标示控制的函数，调用此函数时，called标示符改变，下次调用就无效了。</p>\n"},{"title":"使用Javascript做算法题（四）Longest Increasing Path in a Matrix","author":"TokenYangForever","date":"2017-10-23T10:25:00.000Z","_content":"#### 前言\n* 最近在LeetCode上做出了第一道难度为hard的题：) 觉得这题中规中矩挺不错的，mark一下：[题目地址](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/)\n#### 题目描述\n* 给出一个正整数矩阵，找出其中**最长的递增路径的长度**。只能上下左右移动，不能走对角线，不能环绕重复路线，不能超越边距。\n```\n举例：\n输入:\nnums = [\n  [9,9,4],\n  [6,6,8],\n  [2,1,1]\n]\n返回 最长路径为4 路径为：1->2->6->9\n```\n#### 解题思路\n* 基本思路分以下几个点：\n* 0.依次遍历输入的矩阵(二维数组)，找出每个点作为起点时的最长递归路径长度，然后返回其中的最大值\n* 1.使用dfs递归方法去遍历查找各个方向，建立一个表示移动方向的数组，每次dfs查找一个新的节点是遍历这个数组，得出最大值作为这个点为起点的最长路径，保存到dp中\n* 2.新建一个二维数组作为dp数组，每次得到一个坐标点为起点的最大长度时存入dp数组相应位置，以后再查找到这个坐标点时直接返回之前保存的值避免重复运算\n* 上面可能说的有点乱，大概就是dfs遍历和dp数组结合，难度其实并不算大，但是可以优化的细节还是挺多的，下面代码附有具体注释\n#### 具体代码\n```\n/**\n * @param {number[][]} matrix\n * @return {number}\n */\nvar longestIncreasingPath = function(matrix) {\n    if (!matrix || matrix.length === 0) {\n        return 0\n    }\n          \n    var direct = [[0, -1], [0, 1], [-1, 0], [1, 0]] // 方向数组\n    var max = 1 // 全局最大值\n    var dp = new Array() // dp二维数组，保存每个点作为起点的最大路径长度\n    var width = matrix[0].length\n    var deep = matrix.length\n    while (deep) { \n        dp.push(new Array(width).fill(0)) // 每个点初始长度为0，dfs遍历到不为0的情况直接返回她的值(因为是之前已经得到了)\n        deep--\n    }\n    deep = matrix.length\n    \n    var dfs = function (i, j) {\n        if (dp[i][j] > 0) return dp[i][j];\n        var mx = 1\n        for (var k = 0; k < direct.length; k++) {\n            var x = i + direct[k][0]\n            var y = j + direct[k][1]\n            if (x < 0 || x >= deep || y < 0 || y >=width) { // 超过范围跳过\n                continue\n            }\n            if (matrix[x][y] <= matrix[i][j]) {// 不是递增跳过\n                continue\n            }\n            var len = dfs(x, y) + 1\n            mx = Math.max(mx, len)\n        }\n        dp[i][j] = mx\n        return mx\n    }\n\n    for (var i = 0; i < deep; i++) {\n        for (var j = 0; j < width; j++) {\n            max = Math.max(max, dfs(i, j))\n        }\n    }\n    return max\n};\n```","source":"_posts/11.md","raw":"title: 使用Javascript做算法题（四）Longest Increasing Path in a Matrix\nauthor: TokenYangForever\ntags:\n  - JavaScript\n  - 算法\ncategories:\n  - leetcode算法题\ndate: 2017-10-23 18:25:00\n---\n#### 前言\n* 最近在LeetCode上做出了第一道难度为hard的题：) 觉得这题中规中矩挺不错的，mark一下：[题目地址](https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/)\n#### 题目描述\n* 给出一个正整数矩阵，找出其中**最长的递增路径的长度**。只能上下左右移动，不能走对角线，不能环绕重复路线，不能超越边距。\n```\n举例：\n输入:\nnums = [\n  [9,9,4],\n  [6,6,8],\n  [2,1,1]\n]\n返回 最长路径为4 路径为：1->2->6->9\n```\n#### 解题思路\n* 基本思路分以下几个点：\n* 0.依次遍历输入的矩阵(二维数组)，找出每个点作为起点时的最长递归路径长度，然后返回其中的最大值\n* 1.使用dfs递归方法去遍历查找各个方向，建立一个表示移动方向的数组，每次dfs查找一个新的节点是遍历这个数组，得出最大值作为这个点为起点的最长路径，保存到dp中\n* 2.新建一个二维数组作为dp数组，每次得到一个坐标点为起点的最大长度时存入dp数组相应位置，以后再查找到这个坐标点时直接返回之前保存的值避免重复运算\n* 上面可能说的有点乱，大概就是dfs遍历和dp数组结合，难度其实并不算大，但是可以优化的细节还是挺多的，下面代码附有具体注释\n#### 具体代码\n```\n/**\n * @param {number[][]} matrix\n * @return {number}\n */\nvar longestIncreasingPath = function(matrix) {\n    if (!matrix || matrix.length === 0) {\n        return 0\n    }\n          \n    var direct = [[0, -1], [0, 1], [-1, 0], [1, 0]] // 方向数组\n    var max = 1 // 全局最大值\n    var dp = new Array() // dp二维数组，保存每个点作为起点的最大路径长度\n    var width = matrix[0].length\n    var deep = matrix.length\n    while (deep) { \n        dp.push(new Array(width).fill(0)) // 每个点初始长度为0，dfs遍历到不为0的情况直接返回她的值(因为是之前已经得到了)\n        deep--\n    }\n    deep = matrix.length\n    \n    var dfs = function (i, j) {\n        if (dp[i][j] > 0) return dp[i][j];\n        var mx = 1\n        for (var k = 0; k < direct.length; k++) {\n            var x = i + direct[k][0]\n            var y = j + direct[k][1]\n            if (x < 0 || x >= deep || y < 0 || y >=width) { // 超过范围跳过\n                continue\n            }\n            if (matrix[x][y] <= matrix[i][j]) {// 不是递增跳过\n                continue\n            }\n            var len = dfs(x, y) + 1\n            mx = Math.max(mx, len)\n        }\n        dp[i][j] = mx\n        return mx\n    }\n\n    for (var i = 0; i < deep; i++) {\n        for (var j = 0; j < width; j++) {\n            max = Math.max(max, dfs(i, j))\n        }\n    }\n    return max\n};\n```","slug":"11","published":1,"updated":"2017-10-31T01:56:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9f2000oe6vmx5ncw64r","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>最近在LeetCode上做出了第一道难度为hard的题：) 觉得这题中规中矩挺不错的，mark一下：<a href=\"https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/\" target=\"_blank\" rel=\"external\">题目地址</a><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4></li>\n<li>给出一个正整数矩阵，找出其中<strong>最长的递增路径的长度</strong>。只能上下左右移动，不能走对角线，不能环绕重复路线，不能超越边距。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">举例：</div><div class=\"line\">输入:</div><div class=\"line\">nums = [</div><div class=\"line\">  [9,9,4],</div><div class=\"line\">  [6,6,8],</div><div class=\"line\">  [2,1,1]</div><div class=\"line\">]</div><div class=\"line\">返回 最长路径为4 路径为：1-&gt;2-&gt;6-&gt;9</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li>基本思路分以下几个点：</li>\n<li>0.依次遍历输入的矩阵(二维数组)，找出每个点作为起点时的最长递归路径长度，然后返回其中的最大值</li>\n<li>1.使用dfs递归方法去遍历查找各个方向，建立一个表示移动方向的数组，每次dfs查找一个新的节点是遍历这个数组，得出最大值作为这个点为起点的最长路径，保存到dp中</li>\n<li>2.新建一个二维数组作为dp数组，每次得到一个坐标点为起点的最大长度时存入dp数组相应位置，以后再查找到这个坐标点时直接返回之前保存的值避免重复运算</li>\n<li>上面可能说的有点乱，大概就是dfs遍历和dp数组结合，难度其实并不算大，但是可以优化的细节还是挺多的，下面代码附有具体注释<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[][]&#125; matrix</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> */</div><div class=\"line\">var longestIncreasingPath = function(matrix) &#123;</div><div class=\"line\">    if (!matrix || matrix.length === 0) &#123;</div><div class=\"line\">        return 0</div><div class=\"line\">    &#125;</div><div class=\"line\">          </div><div class=\"line\">    var direct = [[0, -1], [0, 1], [-1, 0], [1, 0]] // 方向数组</div><div class=\"line\">    var max = 1 // 全局最大值</div><div class=\"line\">    var dp = new Array() // dp二维数组，保存每个点作为起点的最大路径长度</div><div class=\"line\">    var width = matrix[0].length</div><div class=\"line\">    var deep = matrix.length</div><div class=\"line\">    while (deep) &#123; </div><div class=\"line\">        dp.push(new Array(width).fill(0)) // 每个点初始长度为0，dfs遍历到不为0的情况直接返回她的值(因为是之前已经得到了)</div><div class=\"line\">        deep--</div><div class=\"line\">    &#125;</div><div class=\"line\">    deep = matrix.length</div><div class=\"line\">    </div><div class=\"line\">    var dfs = function (i, j) &#123;</div><div class=\"line\">        if (dp[i][j] &gt; 0) return dp[i][j];</div><div class=\"line\">        var mx = 1</div><div class=\"line\">        for (var k = 0; k &lt; direct.length; k++) &#123;</div><div class=\"line\">            var x = i + direct[k][0]</div><div class=\"line\">            var y = j + direct[k][1]</div><div class=\"line\">            if (x &lt; 0 || x &gt;= deep || y &lt; 0 || y &gt;=width) &#123; // 超过范围跳过</div><div class=\"line\">                continue</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (matrix[x][y] &lt;= matrix[i][j]) &#123;// 不是递增跳过</div><div class=\"line\">                continue</div><div class=\"line\">            &#125;</div><div class=\"line\">            var len = dfs(x, y) + 1</div><div class=\"line\">            mx = Math.max(mx, len)</div><div class=\"line\">        &#125;</div><div class=\"line\">        dp[i][j] = mx</div><div class=\"line\">        return mx</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    for (var i = 0; i &lt; deep; i++) &#123;</div><div class=\"line\">        for (var j = 0; j &lt; width; j++) &#123;</div><div class=\"line\">            max = Math.max(max, dfs(i, j))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return max</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>最近在LeetCode上做出了第一道难度为hard的题：) 觉得这题中规中矩挺不错的，mark一下：<a href=\"https://leetcode.com/problems/longest-increasing-path-in-a-matrix/description/\" target=\"_blank\" rel=\"external\">题目地址</a><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4></li>\n<li>给出一个正整数矩阵，找出其中<strong>最长的递增路径的长度</strong>。只能上下左右移动，不能走对角线，不能环绕重复路线，不能超越边距。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">举例：</div><div class=\"line\">输入:</div><div class=\"line\">nums = [</div><div class=\"line\">  [9,9,4],</div><div class=\"line\">  [6,6,8],</div><div class=\"line\">  [2,1,1]</div><div class=\"line\">]</div><div class=\"line\">返回 最长路径为4 路径为：1-&gt;2-&gt;6-&gt;9</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li>基本思路分以下几个点：</li>\n<li>0.依次遍历输入的矩阵(二维数组)，找出每个点作为起点时的最长递归路径长度，然后返回其中的最大值</li>\n<li>1.使用dfs递归方法去遍历查找各个方向，建立一个表示移动方向的数组，每次dfs查找一个新的节点是遍历这个数组，得出最大值作为这个点为起点的最长路径，保存到dp中</li>\n<li>2.新建一个二维数组作为dp数组，每次得到一个坐标点为起点的最大长度时存入dp数组相应位置，以后再查找到这个坐标点时直接返回之前保存的值避免重复运算</li>\n<li>上面可能说的有点乱，大概就是dfs遍历和dp数组结合，难度其实并不算大，但是可以优化的细节还是挺多的，下面代码附有具体注释<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[][]&#125; matrix</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> */</div><div class=\"line\">var longestIncreasingPath = function(matrix) &#123;</div><div class=\"line\">    if (!matrix || matrix.length === 0) &#123;</div><div class=\"line\">        return 0</div><div class=\"line\">    &#125;</div><div class=\"line\">          </div><div class=\"line\">    var direct = [[0, -1], [0, 1], [-1, 0], [1, 0]] // 方向数组</div><div class=\"line\">    var max = 1 // 全局最大值</div><div class=\"line\">    var dp = new Array() // dp二维数组，保存每个点作为起点的最大路径长度</div><div class=\"line\">    var width = matrix[0].length</div><div class=\"line\">    var deep = matrix.length</div><div class=\"line\">    while (deep) &#123; </div><div class=\"line\">        dp.push(new Array(width).fill(0)) // 每个点初始长度为0，dfs遍历到不为0的情况直接返回她的值(因为是之前已经得到了)</div><div class=\"line\">        deep--</div><div class=\"line\">    &#125;</div><div class=\"line\">    deep = matrix.length</div><div class=\"line\">    </div><div class=\"line\">    var dfs = function (i, j) &#123;</div><div class=\"line\">        if (dp[i][j] &gt; 0) return dp[i][j];</div><div class=\"line\">        var mx = 1</div><div class=\"line\">        for (var k = 0; k &lt; direct.length; k++) &#123;</div><div class=\"line\">            var x = i + direct[k][0]</div><div class=\"line\">            var y = j + direct[k][1]</div><div class=\"line\">            if (x &lt; 0 || x &gt;= deep || y &lt; 0 || y &gt;=width) &#123; // 超过范围跳过</div><div class=\"line\">                continue</div><div class=\"line\">            &#125;</div><div class=\"line\">            if (matrix[x][y] &lt;= matrix[i][j]) &#123;// 不是递增跳过</div><div class=\"line\">                continue</div><div class=\"line\">            &#125;</div><div class=\"line\">            var len = dfs(x, y) + 1</div><div class=\"line\">            mx = Math.max(mx, len)</div><div class=\"line\">        &#125;</div><div class=\"line\">        dp[i][j] = mx</div><div class=\"line\">        return mx</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    for (var i = 0; i &lt; deep; i++) &#123;</div><div class=\"line\">        for (var j = 0; j &lt; width; j++) &#123;</div><div class=\"line\">            max = Math.max(max, dfs(i, j))</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return max</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"javascript事件流、事件代理、target和currentTarget","author":"TokenYangForever","date":"2017-10-31T01:54:00.000Z","_content":"### 前言\n* 这篇讲的内容是非常基础的，关于javascript中的事件相关可能不太全面，只是围绕几个知识点。可能现在mvvm框架用多了也不用多去在意dom和event，但是原生的基础知识还是需要掌握的(万一以后面试问到了呢~~)\n* Javascript与html之间的交互是通过**事件**来实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间，可以用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。\n### 事件流\n* **事件流**描述的是从页面接收到事件的顺序，一些历史发展的内容这里就不提了，直接讲\"DOM2级事件\"，事件流包括三个阶段：**事件捕获阶段、处于目标阶段和事件冒泡阶段**。最先发生的是事件捕获，然后是具体的实际目标收到事件，最后才是冒泡阶段，可以在这个阶段对事件做出响应。\n\n![网上找的示意图.png](http://upload-images.jianshu.io/upload_images/6383319-f8a239bd4cb8b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 添加事件监听\n* 给元素添加事件监听的方法，可以直接在html上添加或者在javascript中指定相关的**事件处理程序**，但是需要注意，这种以'on'开头的事件属于'DOM0'级事件，重复定义时会覆盖掉原事件，而使用addEventListener则不会覆盖之前添加的。\n```\n<input id='btn' value='click me' onclick='alert(this.value)'>\n```\n* 还可以使用**addEventListener/removeEventListener**方法，所有dom节点都包含这方法，传入三个参数:事件名、处理事件的函数、标示在捕获还是在冒泡阶段调用回调函数的布尔值。\n* addEventListener添加的事件处理函数只能用removeEventListener方法移除，传入参数与addEventListener相同，**意味着addEventListener添加的匿名函数无法移除，**所以在用addEventListener添加处理函数时不能使用匿名函数。环境不支持addEventListener的时候，还可以使用attachEvent/detachEvent，这里就不多做介绍了。\n```\nlet btn = document.getElementById('btn')\nlet handler = function () {alert(this.id)}\nbtn.addEventListener('click', handler,false)\nbtn.removeEventListener('click', handler,false)\n```\n### 事件委托\n* 事件委托是什么呢？最简单来说：**在父元素上添加可以处理子元素事件的事件处理函数**。利用了事件冒泡，指定一个事件处理函数，来处理同一种类型的多个事件。这里顺便一起说下target和currenttarget的区别，**target是触发事件的最具体的元素， currenttarget是绑定事件的元素(在函数中一般等于this)**。下面具体代码示例：\n```\n<div id=\"outter\">\n   <div id=\"inner\"></div>\n</div>\n\nvar outter = document.querySelector('#outter')\noutter.addEventListener('click',function(e){\n    console.log(e.target.id)  //inner\n    console.log(e.currentTarget.id)  //outter\n    console.log(this === e.currentTarget)  //true\n},false);\n```","source":"_posts/javascript事件流、事件代理、target和currentTarget.md","raw":"title: javascript事件流、事件代理、target和currentTarget\nauthor: TokenYangForever\ntags:\n  - JavaScript\ncategories:\n  - JavaScript\ndate: 2017-10-31 09:54:00\n---\n### 前言\n* 这篇讲的内容是非常基础的，关于javascript中的事件相关可能不太全面，只是围绕几个知识点。可能现在mvvm框架用多了也不用多去在意dom和event，但是原生的基础知识还是需要掌握的(万一以后面试问到了呢~~)\n* Javascript与html之间的交互是通过**事件**来实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间，可以用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。\n### 事件流\n* **事件流**描述的是从页面接收到事件的顺序，一些历史发展的内容这里就不提了，直接讲\"DOM2级事件\"，事件流包括三个阶段：**事件捕获阶段、处于目标阶段和事件冒泡阶段**。最先发生的是事件捕获，然后是具体的实际目标收到事件，最后才是冒泡阶段，可以在这个阶段对事件做出响应。\n\n![网上找的示意图.png](http://upload-images.jianshu.io/upload_images/6383319-f8a239bd4cb8b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n### 添加事件监听\n* 给元素添加事件监听的方法，可以直接在html上添加或者在javascript中指定相关的**事件处理程序**，但是需要注意，这种以'on'开头的事件属于'DOM0'级事件，重复定义时会覆盖掉原事件，而使用addEventListener则不会覆盖之前添加的。\n```\n<input id='btn' value='click me' onclick='alert(this.value)'>\n```\n* 还可以使用**addEventListener/removeEventListener**方法，所有dom节点都包含这方法，传入三个参数:事件名、处理事件的函数、标示在捕获还是在冒泡阶段调用回调函数的布尔值。\n* addEventListener添加的事件处理函数只能用removeEventListener方法移除，传入参数与addEventListener相同，**意味着addEventListener添加的匿名函数无法移除，**所以在用addEventListener添加处理函数时不能使用匿名函数。环境不支持addEventListener的时候，还可以使用attachEvent/detachEvent，这里就不多做介绍了。\n```\nlet btn = document.getElementById('btn')\nlet handler = function () {alert(this.id)}\nbtn.addEventListener('click', handler,false)\nbtn.removeEventListener('click', handler,false)\n```\n### 事件委托\n* 事件委托是什么呢？最简单来说：**在父元素上添加可以处理子元素事件的事件处理函数**。利用了事件冒泡，指定一个事件处理函数，来处理同一种类型的多个事件。这里顺便一起说下target和currenttarget的区别，**target是触发事件的最具体的元素， currenttarget是绑定事件的元素(在函数中一般等于this)**。下面具体代码示例：\n```\n<div id=\"outter\">\n   <div id=\"inner\"></div>\n</div>\n\nvar outter = document.querySelector('#outter')\noutter.addEventListener('click',function(e){\n    console.log(e.target.id)  //inner\n    console.log(e.currentTarget.id)  //outter\n    console.log(this === e.currentTarget)  //true\n},false);\n```","slug":"javascript事件流、事件代理、target和currentTarget","published":1,"updated":"2017-10-31T01:58:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9f6000se6vmh4i8kj6d","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><ul>\n<li>这篇讲的内容是非常基础的，关于javascript中的事件相关可能不太全面，只是围绕几个知识点。可能现在mvvm框架用多了也不用多去在意dom和event，但是原生的基础知识还是需要掌握的(万一以后面试问到了呢~~)</li>\n<li>Javascript与html之间的交互是通过<strong>事件</strong>来实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间，可以用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。<h3 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h3></li>\n<li><strong>事件流</strong>描述的是从页面接收到事件的顺序，一些历史发展的内容这里就不提了，直接讲”DOM2级事件”，事件流包括三个阶段：<strong>事件捕获阶段、处于目标阶段和事件冒泡阶段</strong>。最先发生的是事件捕获，然后是具体的实际目标收到事件，最后才是冒泡阶段，可以在这个阶段对事件做出响应。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-f8a239bd4cb8b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网上找的示意图.png\"></p>\n<h3 id=\"添加事件监听\"><a href=\"#添加事件监听\" class=\"headerlink\" title=\"添加事件监听\"></a>添加事件监听</h3><ul>\n<li><p>给元素添加事件监听的方法，可以直接在html上添加或者在javascript中指定相关的<strong>事件处理程序</strong>，但是需要注意，这种以’on’开头的事件属于’DOM0’级事件，重复定义时会覆盖掉原事件，而使用addEventListener则不会覆盖之前添加的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input id=&apos;btn&apos; value=&apos;click me&apos; onclick=&apos;alert(this.value)&apos;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>还可以使用<strong>addEventListener/removeEventListener</strong>方法，所有dom节点都包含这方法，传入三个参数:事件名、处理事件的函数、标示在捕获还是在冒泡阶段调用回调函数的布尔值。</p>\n</li>\n<li>addEventListener添加的事件处理函数只能用removeEventListener方法移除，传入参数与addEventListener相同，<strong>意味着addEventListener添加的匿名函数无法移除，</strong>所以在用addEventListener添加处理函数时不能使用匿名函数。环境不支持addEventListener的时候，还可以使用attachEvent/detachEvent，这里就不多做介绍了。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let btn = document.getElementById(&apos;btn&apos;)</div><div class=\"line\">let handler = function () &#123;alert(this.id)&#125;</div><div class=\"line\">btn.addEventListener(&apos;click&apos;, handler,false)</div><div class=\"line\">btn.removeEventListener(&apos;click&apos;, handler,false)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><ul>\n<li>事件委托是什么呢？最简单来说：<strong>在父元素上添加可以处理子元素事件的事件处理函数</strong>。利用了事件冒泡，指定一个事件处理函数，来处理同一种类型的多个事件。这里顺便一起说下target和currenttarget的区别，<strong>target是触发事件的最具体的元素， currenttarget是绑定事件的元素(在函数中一般等于this)</strong>。下面具体代码示例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;outter&quot;&gt;</div><div class=\"line\">   &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">var outter = document.querySelector(&apos;#outter&apos;)</div><div class=\"line\">outter.addEventListener(&apos;click&apos;,function(e)&#123;</div><div class=\"line\">    console.log(e.target.id)  //inner</div><div class=\"line\">    console.log(e.currentTarget.id)  //outter</div><div class=\"line\">    console.log(this === e.currentTarget)  //true</div><div class=\"line\">&#125;,false);</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><ul>\n<li>这篇讲的内容是非常基础的，关于javascript中的事件相关可能不太全面，只是围绕几个知识点。可能现在mvvm框架用多了也不用多去在意dom和event，但是原生的基础知识还是需要掌握的(万一以后面试问到了呢~~)</li>\n<li>Javascript与html之间的交互是通过<strong>事件</strong>来实现的。事件，就是文档或浏览器窗口发生的一些特定的交互瞬间，可以用侦听器(或处理程序)来预定事件，以便事件发生时执行相应的代码。<h3 id=\"事件流\"><a href=\"#事件流\" class=\"headerlink\" title=\"事件流\"></a>事件流</h3></li>\n<li><strong>事件流</strong>描述的是从页面接收到事件的顺序，一些历史发展的内容这里就不提了，直接讲”DOM2级事件”，事件流包括三个阶段：<strong>事件捕获阶段、处于目标阶段和事件冒泡阶段</strong>。最先发生的是事件捕获，然后是具体的实际目标收到事件，最后才是冒泡阶段，可以在这个阶段对事件做出响应。</li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-f8a239bd4cb8b4ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"网上找的示意图.png\"></p>\n<h3 id=\"添加事件监听\"><a href=\"#添加事件监听\" class=\"headerlink\" title=\"添加事件监听\"></a>添加事件监听</h3><ul>\n<li><p>给元素添加事件监听的方法，可以直接在html上添加或者在javascript中指定相关的<strong>事件处理程序</strong>，但是需要注意，这种以’on’开头的事件属于’DOM0’级事件，重复定义时会覆盖掉原事件，而使用addEventListener则不会覆盖之前添加的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;input id=&apos;btn&apos; value=&apos;click me&apos; onclick=&apos;alert(this.value)&apos;&gt;</div></pre></td></tr></table></figure>\n</li>\n<li><p>还可以使用<strong>addEventListener/removeEventListener</strong>方法，所有dom节点都包含这方法，传入三个参数:事件名、处理事件的函数、标示在捕获还是在冒泡阶段调用回调函数的布尔值。</p>\n</li>\n<li>addEventListener添加的事件处理函数只能用removeEventListener方法移除，传入参数与addEventListener相同，<strong>意味着addEventListener添加的匿名函数无法移除，</strong>所以在用addEventListener添加处理函数时不能使用匿名函数。环境不支持addEventListener的时候，还可以使用attachEvent/detachEvent，这里就不多做介绍了。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">let btn = document.getElementById(&apos;btn&apos;)</div><div class=\"line\">let handler = function () &#123;alert(this.id)&#125;</div><div class=\"line\">btn.addEventListener(&apos;click&apos;, handler,false)</div><div class=\"line\">btn.removeEventListener(&apos;click&apos;, handler,false)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"事件委托\"><a href=\"#事件委托\" class=\"headerlink\" title=\"事件委托\"></a>事件委托</h3><ul>\n<li>事件委托是什么呢？最简单来说：<strong>在父元素上添加可以处理子元素事件的事件处理函数</strong>。利用了事件冒泡，指定一个事件处理函数，来处理同一种类型的多个事件。这里顺便一起说下target和currenttarget的区别，<strong>target是触发事件的最具体的元素， currenttarget是绑定事件的元素(在函数中一般等于this)</strong>。下面具体代码示例：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;outter&quot;&gt;</div><div class=\"line\">   &lt;div id=&quot;inner&quot;&gt;&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div><div class=\"line\"></div><div class=\"line\">var outter = document.querySelector(&apos;#outter&apos;)</div><div class=\"line\">outter.addEventListener(&apos;click&apos;,function(e)&#123;</div><div class=\"line\">    console.log(e.target.id)  //inner</div><div class=\"line\">    console.log(e.currentTarget.id)  //outter</div><div class=\"line\">    console.log(this === e.currentTarget)  //true</div><div class=\"line\">&#125;,false);</div></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"使用Javascript做算法题（一）Maximum Subarray","author":"TokenYangForever","date":"2017-09-14T03:35:00.000Z","_content":"#### 前言\n* 最近开始在leetcode上接触算法题，印象中的算法题大都是用cpp或者java解的，而这个网站支持javascript解题提交。因为大学也没学过算法，数据结构也只是稍微了解，所以解题目标也是选简单经典的题。下面开始讲解这道题--53.Maximum Subarray.[题目地址](https://leetcode.com/problems/maximum-subarray/description/)\n#### 题目描述\n* 给出一个由数字组成(含负数)的数组，找出它的一个**每项相加之和最大**的子数组，返回这个最大和数字。举例：给出一个数组``[-2,1,-3,4,-1,2,1,-5,4]``, 每项和最大的子数组为``[4,-1,2,1]``,返回最大和数字6。\n#### 解题思路\n* 首先抛出一个名词[动态规划算法](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/15742703?fr=aladdin)，概念理解起来较为抽象，我个人的理解是求最优解的题基本都可以用动态规划作为解题思路。\n* 首先可以确定解题的复杂度，这里其实只要遍历一次数组即可，**时间复杂度为O(n)**，而需要**维护的状态变量**有两个，**全局最大值和局部最大值**。就是随着从第一项开始往后推进，你需要确定从第一项到第n项时已经出现的元素组成的**最大和**，这个状态变量就是**全局最大值**；而局部最大值是遍历到第n项时，**包含第n项的情况下的最大值**。全局最大值是由局部最大值推导出的，下面是具体代码：\n```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    if(!nums.length)\n        return 0\n    let local = nums[0]\n    let global = nums[0]\n    for (let i = 1; i < nums.length; i++) {\n        local = Math.max(nums[i], local + nums[i]) // 包含第n项的情况下的最大值\n        global = Math.max(local, global)   // 全局最大值\n    }\n    return global\n};\n```","source":"_posts/使用Javascript做算法题（一）Maximum-Subarray.md","raw":"title: 使用Javascript做算法题（一）Maximum Subarray\nauthor: TokenYangForever\ntags:\n  - JavaScript\n  - 算法\ncategories:\n  - leetcode算法题\ndate: 2017-09-14 11:35:00\n---\n#### 前言\n* 最近开始在leetcode上接触算法题，印象中的算法题大都是用cpp或者java解的，而这个网站支持javascript解题提交。因为大学也没学过算法，数据结构也只是稍微了解，所以解题目标也是选简单经典的题。下面开始讲解这道题--53.Maximum Subarray.[题目地址](https://leetcode.com/problems/maximum-subarray/description/)\n#### 题目描述\n* 给出一个由数字组成(含负数)的数组，找出它的一个**每项相加之和最大**的子数组，返回这个最大和数字。举例：给出一个数组``[-2,1,-3,4,-1,2,1,-5,4]``, 每项和最大的子数组为``[4,-1,2,1]``,返回最大和数字6。\n#### 解题思路\n* 首先抛出一个名词[动态规划算法](https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/15742703?fr=aladdin)，概念理解起来较为抽象，我个人的理解是求最优解的题基本都可以用动态规划作为解题思路。\n* 首先可以确定解题的复杂度，这里其实只要遍历一次数组即可，**时间复杂度为O(n)**，而需要**维护的状态变量**有两个，**全局最大值和局部最大值**。就是随着从第一项开始往后推进，你需要确定从第一项到第n项时已经出现的元素组成的**最大和**，这个状态变量就是**全局最大值**；而局部最大值是遍历到第n项时，**包含第n项的情况下的最大值**。全局最大值是由局部最大值推导出的，下面是具体代码：\n```\n/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    if(!nums.length)\n        return 0\n    let local = nums[0]\n    let global = nums[0]\n    for (let i = 1; i < nums.length; i++) {\n        local = Math.max(nums[i], local + nums[i]) // 包含第n项的情况下的最大值\n        global = Math.max(local, global)   // 全局最大值\n    }\n    return global\n};\n```","slug":"使用Javascript做算法题（一）Maximum-Subarray","published":1,"updated":"2017-10-16T02:17:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9g7000te6vmdv4owwbq","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>最近开始在leetcode上接触算法题，印象中的算法题大都是用cpp或者java解的，而这个网站支持javascript解题提交。因为大学也没学过算法，数据结构也只是稍微了解，所以解题目标也是选简单经典的题。下面开始讲解这道题–53.Maximum Subarray.<a href=\"https://leetcode.com/problems/maximum-subarray/description/\" target=\"_blank\" rel=\"external\">题目地址</a><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4></li>\n<li>给出一个由数字组成(含负数)的数组，找出它的一个<strong>每项相加之和最大</strong>的子数组，返回这个最大和数字。举例：给出一个数组<code>[-2,1,-3,4,-1,2,1,-5,4]</code>, 每项和最大的子数组为<code>[4,-1,2,1]</code>,返回最大和数字6。<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4></li>\n<li>首先抛出一个名词<a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/15742703?fr=aladdin\" target=\"_blank\" rel=\"external\">动态规划算法</a>，概念理解起来较为抽象，我个人的理解是求最优解的题基本都可以用动态规划作为解题思路。</li>\n<li>首先可以确定解题的复杂度，这里其实只要遍历一次数组即可，<strong>时间复杂度为O(n)</strong>，而需要<strong>维护的状态变量</strong>有两个，<strong>全局最大值和局部最大值</strong>。就是随着从第一项开始往后推进，你需要确定从第一项到第n项时已经出现的元素组成的<strong>最大和</strong>，这个状态变量就是<strong>全局最大值</strong>；而局部最大值是遍历到第n项时，<strong>包含第n项的情况下的最大值</strong>。全局最大值是由局部最大值推导出的，下面是具体代码：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[]&#125; nums</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> */</div><div class=\"line\">var maxSubArray = function(nums) &#123;</div><div class=\"line\">    if(!nums.length)</div><div class=\"line\">        return 0</div><div class=\"line\">    let local = nums[0]</div><div class=\"line\">    let global = nums[0]</div><div class=\"line\">    for (let i = 1; i &lt; nums.length; i++) &#123;</div><div class=\"line\">        local = Math.max(nums[i], local + nums[i]) // 包含第n项的情况下的最大值</div><div class=\"line\">        global = Math.max(local, global)   // 全局最大值</div><div class=\"line\">    &#125;</div><div class=\"line\">    return global</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>最近开始在leetcode上接触算法题，印象中的算法题大都是用cpp或者java解的，而这个网站支持javascript解题提交。因为大学也没学过算法，数据结构也只是稍微了解，所以解题目标也是选简单经典的题。下面开始讲解这道题–53.Maximum Subarray.<a href=\"https://leetcode.com/problems/maximum-subarray/description/\" target=\"_blank\" rel=\"external\">题目地址</a><h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4></li>\n<li>给出一个由数字组成(含负数)的数组，找出它的一个<strong>每项相加之和最大</strong>的子数组，返回这个最大和数字。举例：给出一个数组<code>[-2,1,-3,4,-1,2,1,-5,4]</code>, 每项和最大的子数组为<code>[4,-1,2,1]</code>,返回最大和数字6。<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4></li>\n<li>首先抛出一个名词<a href=\"https://baike.baidu.com/item/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95/15742703?fr=aladdin\" target=\"_blank\" rel=\"external\">动态规划算法</a>，概念理解起来较为抽象，我个人的理解是求最优解的题基本都可以用动态规划作为解题思路。</li>\n<li>首先可以确定解题的复杂度，这里其实只要遍历一次数组即可，<strong>时间复杂度为O(n)</strong>，而需要<strong>维护的状态变量</strong>有两个，<strong>全局最大值和局部最大值</strong>。就是随着从第一项开始往后推进，你需要确定从第一项到第n项时已经出现的元素组成的<strong>最大和</strong>，这个状态变量就是<strong>全局最大值</strong>；而局部最大值是遍历到第n项时，<strong>包含第n项的情况下的最大值</strong>。全局最大值是由局部最大值推导出的，下面是具体代码：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[]&#125; nums</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> */</div><div class=\"line\">var maxSubArray = function(nums) &#123;</div><div class=\"line\">    if(!nums.length)</div><div class=\"line\">        return 0</div><div class=\"line\">    let local = nums[0]</div><div class=\"line\">    let global = nums[0]</div><div class=\"line\">    for (let i = 1; i &lt; nums.length; i++) &#123;</div><div class=\"line\">        local = Math.max(nums[i], local + nums[i]) // 包含第n项的情况下的最大值</div><div class=\"line\">        global = Math.max(local, global)   // 全局最大值</div><div class=\"line\">    &#125;</div><div class=\"line\">    return global</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></li>\n</ul>\n"},{"title":"使用Javascript做算法题（三）Largest-Number","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n#### 题目描述\n* 给出一串非负整数组成的数组，求用这些数字组成的一个最大数字。举个例子：给出数组[3, 30, 34, 5, 9]，那么组成的最大数字就是9534330。注：返回结果数字一定相当大，所以用字符串表示返回的结果。[题目地址](https://leetcode.com/problems/largest-number/description/)\n#### 解题思路\n* 这道题解法的关键在于**排序数组**，需要将数组以生成最大数的顺序排列。我刚开始想到的是，首位数字大的数字就往前放，但是要考虑多位数他可能后面几位比较小的情况。最后发现解题思路很简单：**设计一个排序函数：比如两个数字为m和n，就比较mn和nm哪个数字更大，然后在数组调用sort()的时候传入它。**\n#### 具体代码\n```\n/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function(nums) {\n    let len = nums.length\n    if (len === 0) {\n        return \"\"\n    }\n    if (len === 1) {\n        return nums[0].toString()\n    }\n    let result = ''\n    let sortBy = function (a, b) {\n        let ab = a.toString() + b \n        let ba = b.toString() + a\n        return Number(ba) - Number(ab)\n    }\n    nums.sort(sortBy)\n    for (let i =0;i<len;i++){\n        result += nums[i]\n    }\n    while (result.startsWith ('0') && result.length > 1) {\n        result = result.substring(1)\n    }\n    return result\n};\n```\n","source":"_posts/使用Javascript做算法题（三）Largest-Number.md","raw":"title: 使用Javascript做算法题（三）Largest-Number\ntags:\n  - JavaScript\n  - 算法\ncategories:\n  - leetcode算法题\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n#### 题目描述\n* 给出一串非负整数组成的数组，求用这些数字组成的一个最大数字。举个例子：给出数组[3, 30, 34, 5, 9]，那么组成的最大数字就是9534330。注：返回结果数字一定相当大，所以用字符串表示返回的结果。[题目地址](https://leetcode.com/problems/largest-number/description/)\n#### 解题思路\n* 这道题解法的关键在于**排序数组**，需要将数组以生成最大数的顺序排列。我刚开始想到的是，首位数字大的数字就往前放，但是要考虑多位数他可能后面几位比较小的情况。最后发现解题思路很简单：**设计一个排序函数：比如两个数字为m和n，就比较mn和nm哪个数字更大，然后在数组调用sort()的时候传入它。**\n#### 具体代码\n```\n/**\n * @param {number[]} nums\n * @return {string}\n */\nvar largestNumber = function(nums) {\n    let len = nums.length\n    if (len === 0) {\n        return \"\"\n    }\n    if (len === 1) {\n        return nums[0].toString()\n    }\n    let result = ''\n    let sortBy = function (a, b) {\n        let ab = a.toString() + b \n        let ba = b.toString() + a\n        return Number(ba) - Number(ab)\n    }\n    nums.sort(sortBy)\n    for (let i =0;i<len;i++){\n        result += nums[i]\n    }\n    while (result.startsWith ('0') && result.length > 1) {\n        result = result.substring(1)\n    }\n    return result\n};\n```\n","slug":"使用Javascript做算法题（三）Largest-Number","published":1,"updated":"2017-10-16T02:17:19.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9g9000xe6vmkebpj8ol","content":"<hr>\n<h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><ul>\n<li>给出一串非负整数组成的数组，求用这些数字组成的一个最大数字。举个例子：给出数组[3, 30, 34, 5, 9]，那么组成的最大数字就是9534330。注：返回结果数字一定相当大，所以用字符串表示返回的结果。<a href=\"https://leetcode.com/problems/largest-number/description/\" target=\"_blank\" rel=\"external\">题目地址</a><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4></li>\n<li>这道题解法的关键在于<strong>排序数组</strong>，需要将数组以生成最大数的顺序排列。我刚开始想到的是，首位数字大的数字就往前放，但是要考虑多位数他可能后面几位比较小的情况。最后发现解题思路很简单：<strong>设计一个排序函数：比如两个数字为m和n，就比较mn和nm哪个数字更大，然后在数组调用sort()的时候传入它。</strong><h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[]&#125; nums</div><div class=\"line\"> * @return &#123;string&#125;</div><div class=\"line\"> */</div><div class=\"line\">var largestNumber = function(nums) &#123;</div><div class=\"line\">    let len = nums.length</div><div class=\"line\">    if (len === 0) &#123;</div><div class=\"line\">        return &quot;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (len === 1) &#123;</div><div class=\"line\">        return nums[0].toString()</div><div class=\"line\">    &#125;</div><div class=\"line\">    let result = &apos;&apos;</div><div class=\"line\">    let sortBy = function (a, b) &#123;</div><div class=\"line\">        let ab = a.toString() + b </div><div class=\"line\">        let ba = b.toString() + a</div><div class=\"line\">        return Number(ba) - Number(ab)</div><div class=\"line\">    &#125;</div><div class=\"line\">    nums.sort(sortBy)</div><div class=\"line\">    for (let i =0;i&lt;len;i++)&#123;</div><div class=\"line\">        result += nums[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">    while (result.startsWith (&apos;0&apos;) &amp;&amp; result.length &gt; 1) &#123;</div><div class=\"line\">        result = result.substring(1)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><ul>\n<li>给出一串非负整数组成的数组，求用这些数字组成的一个最大数字。举个例子：给出数组[3, 30, 34, 5, 9]，那么组成的最大数字就是9534330。注：返回结果数字一定相当大，所以用字符串表示返回的结果。<a href=\"https://leetcode.com/problems/largest-number/description/\" target=\"_blank\" rel=\"external\">题目地址</a><h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4></li>\n<li>这道题解法的关键在于<strong>排序数组</strong>，需要将数组以生成最大数的顺序排列。我刚开始想到的是，首位数字大的数字就往前放，但是要考虑多位数他可能后面几位比较小的情况。最后发现解题思路很简单：<strong>设计一个排序函数：比如两个数字为m和n，就比较mn和nm哪个数字更大，然后在数组调用sort()的时候传入它。</strong><h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number[]&#125; nums</div><div class=\"line\"> * @return &#123;string&#125;</div><div class=\"line\"> */</div><div class=\"line\">var largestNumber = function(nums) &#123;</div><div class=\"line\">    let len = nums.length</div><div class=\"line\">    if (len === 0) &#123;</div><div class=\"line\">        return &quot;&quot;</div><div class=\"line\">    &#125;</div><div class=\"line\">    if (len === 1) &#123;</div><div class=\"line\">        return nums[0].toString()</div><div class=\"line\">    &#125;</div><div class=\"line\">    let result = &apos;&apos;</div><div class=\"line\">    let sortBy = function (a, b) &#123;</div><div class=\"line\">        let ab = a.toString() + b </div><div class=\"line\">        let ba = b.toString() + a</div><div class=\"line\">        return Number(ba) - Number(ab)</div><div class=\"line\">    &#125;</div><div class=\"line\">    nums.sort(sortBy)</div><div class=\"line\">    for (let i =0;i&lt;len;i++)&#123;</div><div class=\"line\">        result += nums[i]</div><div class=\"line\">    &#125;</div><div class=\"line\">    while (result.startsWith (&apos;0&apos;) &amp;&amp; result.length &gt; 1) &#123;</div><div class=\"line\">        result = result.substring(1)</div><div class=\"line\">    &#125;</div><div class=\"line\">    return result</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"使用Javascript做算法题（二）Unique-Paths","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n#### 题目描述\n* 在一个 m*n 个格子大小的地图上，一个机器人位于左上角，它的终点在右下角，机器人的前进路线只能向右或向下走，求一共有多少种不同的路线走到终点。注：m和n不会超过100。[题目地址](https://leetcode.com/problems/unique-paths/description/)\n\n![一个3*7的示例](http://upload-images.jianshu.io/upload_images/6383319-9b976ff4ae8da7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 解题思路\n* 看完这个题目，我首先联想到了另一个类似的题，就是上n阶台阶，可以跨一步可以跨两步，求一共有多少种方法。解题方法就是去考虑最后一步，最后要嘛从**n-1阶**，要嘛从**n-2阶**跨到终点。**假设走到n-1阶有m种不同方案，走到n-2阶有n种不同方案，那么走到n阶就有m+n种不同方案。**\n* 有点扯远了，回到这个题目。首先想到的是**以二维数组来表示这个地图的坐标**，机器人的起点在(0,0)终点在(m,n)，机器人最后一步肯定从(m-1,n)或(m,n-1)走，那走到(m,n)的路线总数就是走到(m-1,n)的路线总数加上走到(m,n-1)的路线总数。至此，解题思路也就很明显了，**首先确定机器人走到最上面的一行和最左边的一列上的任意点，路线数只能为1。**然后再根据这些点的路线数，依次往里推，最后得出(m,n)点的路线数。\n#### 具体代码\n```\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) { \n    if (m == 1 || n == 1) {\n        return 1\n    }\n    var arr = []\n    arr[0] = new Array(n).fill(1)\n    for (var i = 1; i < m; i++) {\n        arr[i] = new Array(n)\n        arr[i][0] = 1\n        for (var j = 1; j < n; j++) {\n            arr[i][j] = arr[i][j-1] + arr[i-1][j]\n        }\n    }\n    return arr[m-1][n-1]\n};\n```\n","source":"_posts/使用Javascript做算法题（二）Unique-Paths.md","raw":"title: 使用Javascript做算法题（二）Unique-Paths\ntags:\n  - JavaScript\n  - 算法\ncategories:\n  - leetcode算法题\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n#### 题目描述\n* 在一个 m*n 个格子大小的地图上，一个机器人位于左上角，它的终点在右下角，机器人的前进路线只能向右或向下走，求一共有多少种不同的路线走到终点。注：m和n不会超过100。[题目地址](https://leetcode.com/problems/unique-paths/description/)\n\n![一个3*7的示例](http://upload-images.jianshu.io/upload_images/6383319-9b976ff4ae8da7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n#### 解题思路\n* 看完这个题目，我首先联想到了另一个类似的题，就是上n阶台阶，可以跨一步可以跨两步，求一共有多少种方法。解题方法就是去考虑最后一步，最后要嘛从**n-1阶**，要嘛从**n-2阶**跨到终点。**假设走到n-1阶有m种不同方案，走到n-2阶有n种不同方案，那么走到n阶就有m+n种不同方案。**\n* 有点扯远了，回到这个题目。首先想到的是**以二维数组来表示这个地图的坐标**，机器人的起点在(0,0)终点在(m,n)，机器人最后一步肯定从(m-1,n)或(m,n-1)走，那走到(m,n)的路线总数就是走到(m-1,n)的路线总数加上走到(m,n-1)的路线总数。至此，解题思路也就很明显了，**首先确定机器人走到最上面的一行和最左边的一列上的任意点，路线数只能为1。**然后再根据这些点的路线数，依次往里推，最后得出(m,n)点的路线数。\n#### 具体代码\n```\n/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) { \n    if (m == 1 || n == 1) {\n        return 1\n    }\n    var arr = []\n    arr[0] = new Array(n).fill(1)\n    for (var i = 1; i < m; i++) {\n        arr[i] = new Array(n)\n        arr[i][0] = 1\n        for (var j = 1; j < n; j++) {\n            arr[i][j] = arr[i][j-1] + arr[i-1][j]\n        }\n    }\n    return arr[m-1][n-1]\n};\n```\n","slug":"使用Javascript做算法题（二）Unique-Paths","published":1,"updated":"2017-10-16T02:17:27.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9gb000ye6vmhp7y42a9","content":"<hr>\n<h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><ul>\n<li>在一个 m*n 个格子大小的地图上，一个机器人位于左上角，它的终点在右下角，机器人的前进路线只能向右或向下走，求一共有多少种不同的路线走到终点。注：m和n不会超过100。<a href=\"https://leetcode.com/problems/unique-paths/description/\" target=\"_blank\" rel=\"external\">题目地址</a></li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-9b976ff4ae8da7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一个3*7的示例\"></p>\n<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li>看完这个题目，我首先联想到了另一个类似的题，就是上n阶台阶，可以跨一步可以跨两步，求一共有多少种方法。解题方法就是去考虑最后一步，最后要嘛从<strong>n-1阶</strong>，要嘛从<strong>n-2阶</strong>跨到终点。<strong>假设走到n-1阶有m种不同方案，走到n-2阶有n种不同方案，那么走到n阶就有m+n种不同方案。</strong></li>\n<li>有点扯远了，回到这个题目。首先想到的是<strong>以二维数组来表示这个地图的坐标</strong>，机器人的起点在(0,0)终点在(m,n)，机器人最后一步肯定从(m-1,n)或(m,n-1)走，那走到(m,n)的路线总数就是走到(m-1,n)的路线总数加上走到(m,n-1)的路线总数。至此，解题思路也就很明显了，<strong>首先确定机器人走到最上面的一行和最左边的一列上的任意点，路线数只能为1。</strong>然后再根据这些点的路线数，依次往里推，最后得出(m,n)点的路线数。<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number&#125; m</div><div class=\"line\"> * @param &#123;number&#125; n</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> */</div><div class=\"line\">var uniquePaths = function(m, n) &#123; </div><div class=\"line\">    if (m == 1 || n == 1) &#123;</div><div class=\"line\">        return 1</div><div class=\"line\">    &#125;</div><div class=\"line\">    var arr = []</div><div class=\"line\">    arr[0] = new Array(n).fill(1)</div><div class=\"line\">    for (var i = 1; i &lt; m; i++) &#123;</div><div class=\"line\">        arr[i] = new Array(n)</div><div class=\"line\">        arr[i][0] = 1</div><div class=\"line\">        for (var j = 1; j &lt; n; j++) &#123;</div><div class=\"line\">            arr[i][j] = arr[i][j-1] + arr[i-1][j]</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return arr[m-1][n-1]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h4 id=\"题目描述\"><a href=\"#题目描述\" class=\"headerlink\" title=\"题目描述\"></a>题目描述</h4><ul>\n<li>在一个 m*n 个格子大小的地图上，一个机器人位于左上角，它的终点在右下角，机器人的前进路线只能向右或向下走，求一共有多少种不同的路线走到终点。注：m和n不会超过100。<a href=\"https://leetcode.com/problems/unique-paths/description/\" target=\"_blank\" rel=\"external\">题目地址</a></li>\n</ul>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-9b976ff4ae8da7eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"一个3*7的示例\"></p>\n<h4 id=\"解题思路\"><a href=\"#解题思路\" class=\"headerlink\" title=\"解题思路\"></a>解题思路</h4><ul>\n<li>看完这个题目，我首先联想到了另一个类似的题，就是上n阶台阶，可以跨一步可以跨两步，求一共有多少种方法。解题方法就是去考虑最后一步，最后要嘛从<strong>n-1阶</strong>，要嘛从<strong>n-2阶</strong>跨到终点。<strong>假设走到n-1阶有m种不同方案，走到n-2阶有n种不同方案，那么走到n阶就有m+n种不同方案。</strong></li>\n<li>有点扯远了，回到这个题目。首先想到的是<strong>以二维数组来表示这个地图的坐标</strong>，机器人的起点在(0,0)终点在(m,n)，机器人最后一步肯定从(m-1,n)或(m,n-1)走，那走到(m,n)的路线总数就是走到(m-1,n)的路线总数加上走到(m,n-1)的路线总数。至此，解题思路也就很明显了，<strong>首先确定机器人走到最上面的一行和最左边的一列上的任意点，路线数只能为1。</strong>然后再根据这些点的路线数，依次往里推，最后得出(m,n)点的路线数。<h4 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/**</div><div class=\"line\"> * @param &#123;number&#125; m</div><div class=\"line\"> * @param &#123;number&#125; n</div><div class=\"line\"> * @return &#123;number&#125;</div><div class=\"line\"> */</div><div class=\"line\">var uniquePaths = function(m, n) &#123; </div><div class=\"line\">    if (m == 1 || n == 1) &#123;</div><div class=\"line\">        return 1</div><div class=\"line\">    &#125;</div><div class=\"line\">    var arr = []</div><div class=\"line\">    arr[0] = new Array(n).fill(1)</div><div class=\"line\">    for (var i = 1; i &lt; m; i++) &#123;</div><div class=\"line\">        arr[i] = new Array(n)</div><div class=\"line\">        arr[i][0] = 1</div><div class=\"line\">        for (var j = 1; j &lt; n; j++) &#123;</div><div class=\"line\">            arr[i][j] = arr[i][j-1] + arr[i-1][j]</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    return arr[m-1][n-1]</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"从几个关键词来理解http缓存","author":"TokenYangForever","date":"2017-09-27T07:19:00.000Z","_content":"#### 前言\n* 我对于http缓存的认知总是停留在略知一二的状态，毕竟实际工作中用的比较少-_-||\n但作为一个严谨的程序员，这仍是必备的一个知识技能。想了想还是写篇博客来总结下相关的一些知识，从一些关键词来理解http的缓存\n##### 强缓存与协商缓存\n* 首先需要知道的是读取http缓存的方式是有两种的：**强缓存(本地缓存)**和**协商缓存(对比缓存)**，下面讲一下这两种工作方式的区别和特点。\n* **强缓存**： 客户端发送请求时，首先访问浏览器的缓存数据库，若得知缓存存在且有效，则直接读取缓存内容返回给客户端，此时返回状态码为**200（from cache）**;而如果发现缓存失效了或不存在，则会去请求**服务器**得到相关内容信息，此时返回状态码为200，操作示意图如下\n![强缓存.png](http://upload-images.jianshu.io/upload_images/6383319-5018186b2e518efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* **协商缓存**： 客户端发送请求时，如果是第一次请求资源，则直接访问服务器，服务器将相关内容和缓存标示返回给客户端；如果是再次请求资源，**客户端将第一次访问时服务器返回的缓存标示发送给服务器，服务器来判断缓存是否可用，**如果缓存可用则告诉客户端可以继续使用缓存的内容，此时**返回码为304**，操作示意图如下\n![协商缓存.png](http://upload-images.jianshu.io/upload_images/6383319-e872781570ae4356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 综上可以直观的看出两种方式的区别，最明显的是**缓存命中时返回码不同**，还有对比缓存的方式：**每一次都会去访问服务器，无论缓存命中与否**。那么对于浏览器和服务器是如何区分强缓存还是对比缓存，以及如何判断缓存是否有效呢，这就需要那些放在**http报文header中**的相关字段了，接下来依次讲解他们。ps：两种缓存方式是可以同时存在的，同时存在时，强缓存的优先级更高。\n#### expires\n* 用于定义强缓存的header字段，这是http1.0时的规范，它的值为一个GMT格式时间字符串，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。但是已经过时了，基本可以忽略。\n#### cache-control\n* http1.1版本出现的header信息，用来定义缓存信息。包括了好几个字段，其中最重要的就是**max-age**：用于表示缓存多少秒后失效。比如max-age = 31536000，表示缓存时间为365天，从第一次请求后的365天内再次请求都会去读取缓存。这个也是用来控制强制缓存的header字段。\n##### 协商缓存相关的header字段\n* 协商缓存的方式总是会去访问服务器来确定缓存是否可用的，所以需要通过某种标识来进行通信，主要包括下面两组header字段(他们都是要成对出现)，即第一次请求的响应头带上某个字段（**Last-Modified/Etag**），则后续请求头则会带上对应的请求字段（**If-Modified-Since/If-None-Match**），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。\n##### Last-Modified  /  If-Modified-Since\n* 这组值都是时间字符串。具体行为如下：第一次请求时服务器返回的response headers带上**Last-Modified字段表示资源最后一次修改的时间**，再次请求时浏览器的request headers带上**If-Modified-Since**这个值和第一次访问返回的Last-Modified值是一样的，然后给到服务器再进行判断缓存是否过期\n##### Etag / If-None-Match\n* 这组字段的值是服务器生成的唯一标示字符串，用法和上面的Last-Modified/If-Modified-Since类似，第一次访问时服务器会返回一个Etag，再次访问浏览器就会带上If-None-Match其值为第一次返回的Etag，给到服务器，服务器进行判断缓存是否可用。ps: Etag和Last-Modified同时使用时，服务器会**优先判断Etag**，好像是etag的精准级别更高。\n#### 结语\n* 大概就这么多了，都是以最基本的概念为主，参考了一些网上的资料，如果有机会的话再深入地研究下~~~\n参考：[彻底弄懂HTTP缓存机制及原理](http://www.cnblogs.com/chenqf/p/6386163.html)","source":"_posts/从几个关键词来理解http缓存.md","raw":"title: 从几个关键词来理解http缓存\nauthor: TokenYangForever\ntags:\n  - http缓存\n  - html\ncategories:\n  - http\ndate: 2017-09-27 15:19:00\n---\n#### 前言\n* 我对于http缓存的认知总是停留在略知一二的状态，毕竟实际工作中用的比较少-_-||\n但作为一个严谨的程序员，这仍是必备的一个知识技能。想了想还是写篇博客来总结下相关的一些知识，从一些关键词来理解http的缓存\n##### 强缓存与协商缓存\n* 首先需要知道的是读取http缓存的方式是有两种的：**强缓存(本地缓存)**和**协商缓存(对比缓存)**，下面讲一下这两种工作方式的区别和特点。\n* **强缓存**： 客户端发送请求时，首先访问浏览器的缓存数据库，若得知缓存存在且有效，则直接读取缓存内容返回给客户端，此时返回状态码为**200（from cache）**;而如果发现缓存失效了或不存在，则会去请求**服务器**得到相关内容信息，此时返回状态码为200，操作示意图如下\n![强缓存.png](http://upload-images.jianshu.io/upload_images/6383319-5018186b2e518efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* **协商缓存**： 客户端发送请求时，如果是第一次请求资源，则直接访问服务器，服务器将相关内容和缓存标示返回给客户端；如果是再次请求资源，**客户端将第一次访问时服务器返回的缓存标示发送给服务器，服务器来判断缓存是否可用，**如果缓存可用则告诉客户端可以继续使用缓存的内容，此时**返回码为304**，操作示意图如下\n![协商缓存.png](http://upload-images.jianshu.io/upload_images/6383319-e872781570ae4356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 综上可以直观的看出两种方式的区别，最明显的是**缓存命中时返回码不同**，还有对比缓存的方式：**每一次都会去访问服务器，无论缓存命中与否**。那么对于浏览器和服务器是如何区分强缓存还是对比缓存，以及如何判断缓存是否有效呢，这就需要那些放在**http报文header中**的相关字段了，接下来依次讲解他们。ps：两种缓存方式是可以同时存在的，同时存在时，强缓存的优先级更高。\n#### expires\n* 用于定义强缓存的header字段，这是http1.0时的规范，它的值为一个GMT格式时间字符串，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。但是已经过时了，基本可以忽略。\n#### cache-control\n* http1.1版本出现的header信息，用来定义缓存信息。包括了好几个字段，其中最重要的就是**max-age**：用于表示缓存多少秒后失效。比如max-age = 31536000，表示缓存时间为365天，从第一次请求后的365天内再次请求都会去读取缓存。这个也是用来控制强制缓存的header字段。\n##### 协商缓存相关的header字段\n* 协商缓存的方式总是会去访问服务器来确定缓存是否可用的，所以需要通过某种标识来进行通信，主要包括下面两组header字段(他们都是要成对出现)，即第一次请求的响应头带上某个字段（**Last-Modified/Etag**），则后续请求头则会带上对应的请求字段（**If-Modified-Since/If-None-Match**），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。\n##### Last-Modified  /  If-Modified-Since\n* 这组值都是时间字符串。具体行为如下：第一次请求时服务器返回的response headers带上**Last-Modified字段表示资源最后一次修改的时间**，再次请求时浏览器的request headers带上**If-Modified-Since**这个值和第一次访问返回的Last-Modified值是一样的，然后给到服务器再进行判断缓存是否过期\n##### Etag / If-None-Match\n* 这组字段的值是服务器生成的唯一标示字符串，用法和上面的Last-Modified/If-Modified-Since类似，第一次访问时服务器会返回一个Etag，再次访问浏览器就会带上If-None-Match其值为第一次返回的Etag，给到服务器，服务器进行判断缓存是否可用。ps: Etag和Last-Modified同时使用时，服务器会**优先判断Etag**，好像是etag的精准级别更高。\n#### 结语\n* 大概就这么多了，都是以最基本的概念为主，参考了一些网上的资料，如果有机会的话再深入地研究下~~~\n参考：[彻底弄懂HTTP缓存机制及原理](http://www.cnblogs.com/chenqf/p/6386163.html)","slug":"从几个关键词来理解http缓存","published":1,"updated":"2017-10-16T02:22:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9gd0012e6vmp1d6djac","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>我对于http缓存的认知总是停留在略知一二的状态，毕竟实际工作中用的比较少-_-||<br>但作为一个严谨的程序员，这仍是必备的一个知识技能。想了想还是写篇博客来总结下相关的一些知识，从一些关键词来理解http的缓存<h5 id=\"强缓存与协商缓存\"><a href=\"#强缓存与协商缓存\" class=\"headerlink\" title=\"强缓存与协商缓存\"></a>强缓存与协商缓存</h5></li>\n<li>首先需要知道的是读取http缓存的方式是有两种的：<strong>强缓存(本地缓存)</strong>和<strong>协商缓存(对比缓存)</strong>，下面讲一下这两种工作方式的区别和特点。</li>\n<li><p><strong>强缓存</strong>： 客户端发送请求时，首先访问浏览器的缓存数据库，若得知缓存存在且有效，则直接读取缓存内容返回给客户端，此时返回状态码为<strong>200（from cache）</strong>;而如果发现缓存失效了或不存在，则会去请求<strong>服务器</strong>得到相关内容信息，此时返回状态码为200，操作示意图如下<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-5018186b2e518efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"强缓存.png\"></p>\n</li>\n<li><p><strong>协商缓存</strong>： 客户端发送请求时，如果是第一次请求资源，则直接访问服务器，服务器将相关内容和缓存标示返回给客户端；如果是再次请求资源，<strong>客户端将第一次访问时服务器返回的缓存标示发送给服务器，服务器来判断缓存是否可用，</strong>如果缓存可用则告诉客户端可以继续使用缓存的内容，此时<strong>返回码为304</strong>，操作示意图如下<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-e872781570ae4356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"协商缓存.png\"></p>\n</li>\n<li>综上可以直观的看出两种方式的区别，最明显的是<strong>缓存命中时返回码不同</strong>，还有对比缓存的方式：<strong>每一次都会去访问服务器，无论缓存命中与否</strong>。那么对于浏览器和服务器是如何区分强缓存还是对比缓存，以及如何判断缓存是否有效呢，这就需要那些放在<strong>http报文header中</strong>的相关字段了，接下来依次讲解他们。ps：两种缓存方式是可以同时存在的，同时存在时，强缓存的优先级更高。<h4 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h4></li>\n<li>用于定义强缓存的header字段，这是http1.0时的规范，它的值为一个GMT格式时间字符串，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。但是已经过时了，基本可以忽略。<h4 id=\"cache-control\"><a href=\"#cache-control\" class=\"headerlink\" title=\"cache-control\"></a>cache-control</h4></li>\n<li>http1.1版本出现的header信息，用来定义缓存信息。包括了好几个字段，其中最重要的就是<strong>max-age</strong>：用于表示缓存多少秒后失效。比如max-age = 31536000，表示缓存时间为365天，从第一次请求后的365天内再次请求都会去读取缓存。这个也是用来控制强制缓存的header字段。<h5 id=\"协商缓存相关的header字段\"><a href=\"#协商缓存相关的header字段\" class=\"headerlink\" title=\"协商缓存相关的header字段\"></a>协商缓存相关的header字段</h5></li>\n<li>协商缓存的方式总是会去访问服务器来确定缓存是否可用的，所以需要通过某种标识来进行通信，主要包括下面两组header字段(他们都是要成对出现)，即第一次请求的响应头带上某个字段（<strong>Last-Modified/Etag</strong>），则后续请求头则会带上对应的请求字段（<strong>If-Modified-Since/If-None-Match</strong>），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。<h5 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified  /  If-Modified-Since\"></a>Last-Modified  /  If-Modified-Since</h5></li>\n<li>这组值都是时间字符串。具体行为如下：第一次请求时服务器返回的response headers带上<strong>Last-Modified字段表示资源最后一次修改的时间</strong>，再次请求时浏览器的request headers带上<strong>If-Modified-Since</strong>这个值和第一次访问返回的Last-Modified值是一样的，然后给到服务器再进行判断缓存是否过期<h5 id=\"Etag-If-None-Match\"><a href=\"#Etag-If-None-Match\" class=\"headerlink\" title=\"Etag / If-None-Match\"></a>Etag / If-None-Match</h5></li>\n<li>这组字段的值是服务器生成的唯一标示字符串，用法和上面的Last-Modified/If-Modified-Since类似，第一次访问时服务器会返回一个Etag，再次访问浏览器就会带上If-None-Match其值为第一次返回的Etag，给到服务器，服务器进行判断缓存是否可用。ps: Etag和Last-Modified同时使用时，服务器会<strong>优先判断Etag</strong>，好像是etag的精准级别更高。<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li>大概就这么多了，都是以最基本的概念为主，参考了一些网上的资料，如果有机会的话再深入地研究下~~~<br>参考：<a href=\"http://www.cnblogs.com/chenqf/p/6386163.html\" target=\"_blank\" rel=\"external\">彻底弄懂HTTP缓存机制及原理</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>我对于http缓存的认知总是停留在略知一二的状态，毕竟实际工作中用的比较少-_-||<br>但作为一个严谨的程序员，这仍是必备的一个知识技能。想了想还是写篇博客来总结下相关的一些知识，从一些关键词来理解http的缓存<h5 id=\"强缓存与协商缓存\"><a href=\"#强缓存与协商缓存\" class=\"headerlink\" title=\"强缓存与协商缓存\"></a>强缓存与协商缓存</h5></li>\n<li>首先需要知道的是读取http缓存的方式是有两种的：<strong>强缓存(本地缓存)</strong>和<strong>协商缓存(对比缓存)</strong>，下面讲一下这两种工作方式的区别和特点。</li>\n<li><p><strong>强缓存</strong>： 客户端发送请求时，首先访问浏览器的缓存数据库，若得知缓存存在且有效，则直接读取缓存内容返回给客户端，此时返回状态码为<strong>200（from cache）</strong>;而如果发现缓存失效了或不存在，则会去请求<strong>服务器</strong>得到相关内容信息，此时返回状态码为200，操作示意图如下<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-5018186b2e518efc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"强缓存.png\"></p>\n</li>\n<li><p><strong>协商缓存</strong>： 客户端发送请求时，如果是第一次请求资源，则直接访问服务器，服务器将相关内容和缓存标示返回给客户端；如果是再次请求资源，<strong>客户端将第一次访问时服务器返回的缓存标示发送给服务器，服务器来判断缓存是否可用，</strong>如果缓存可用则告诉客户端可以继续使用缓存的内容，此时<strong>返回码为304</strong>，操作示意图如下<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-e872781570ae4356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"协商缓存.png\"></p>\n</li>\n<li>综上可以直观的看出两种方式的区别，最明显的是<strong>缓存命中时返回码不同</strong>，还有对比缓存的方式：<strong>每一次都会去访问服务器，无论缓存命中与否</strong>。那么对于浏览器和服务器是如何区分强缓存还是对比缓存，以及如何判断缓存是否有效呢，这就需要那些放在<strong>http报文header中</strong>的相关字段了，接下来依次讲解他们。ps：两种缓存方式是可以同时存在的，同时存在时，强缓存的优先级更高。<h4 id=\"expires\"><a href=\"#expires\" class=\"headerlink\" title=\"expires\"></a>expires</h4></li>\n<li>用于定义强缓存的header字段，这是http1.0时的规范，它的值为一个GMT格式时间字符串，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源。但是已经过时了，基本可以忽略。<h4 id=\"cache-control\"><a href=\"#cache-control\" class=\"headerlink\" title=\"cache-control\"></a>cache-control</h4></li>\n<li>http1.1版本出现的header信息，用来定义缓存信息。包括了好几个字段，其中最重要的就是<strong>max-age</strong>：用于表示缓存多少秒后失效。比如max-age = 31536000，表示缓存时间为365天，从第一次请求后的365天内再次请求都会去读取缓存。这个也是用来控制强制缓存的header字段。<h5 id=\"协商缓存相关的header字段\"><a href=\"#协商缓存相关的header字段\" class=\"headerlink\" title=\"协商缓存相关的header字段\"></a>协商缓存相关的header字段</h5></li>\n<li>协商缓存的方式总是会去访问服务器来确定缓存是否可用的，所以需要通过某种标识来进行通信，主要包括下面两组header字段(他们都是要成对出现)，即第一次请求的响应头带上某个字段（<strong>Last-Modified/Etag</strong>），则后续请求头则会带上对应的请求字段（<strong>If-Modified-Since/If-None-Match</strong>），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。<h5 id=\"Last-Modified-If-Modified-Since\"><a href=\"#Last-Modified-If-Modified-Since\" class=\"headerlink\" title=\"Last-Modified  /  If-Modified-Since\"></a>Last-Modified  /  If-Modified-Since</h5></li>\n<li>这组值都是时间字符串。具体行为如下：第一次请求时服务器返回的response headers带上<strong>Last-Modified字段表示资源最后一次修改的时间</strong>，再次请求时浏览器的request headers带上<strong>If-Modified-Since</strong>这个值和第一次访问返回的Last-Modified值是一样的，然后给到服务器再进行判断缓存是否过期<h5 id=\"Etag-If-None-Match\"><a href=\"#Etag-If-None-Match\" class=\"headerlink\" title=\"Etag / If-None-Match\"></a>Etag / If-None-Match</h5></li>\n<li>这组字段的值是服务器生成的唯一标示字符串，用法和上面的Last-Modified/If-Modified-Since类似，第一次访问时服务器会返回一个Etag，再次访问浏览器就会带上If-None-Match其值为第一次返回的Etag，给到服务器，服务器进行判断缓存是否可用。ps: Etag和Last-Modified同时使用时，服务器会<strong>优先判断Etag</strong>，好像是etag的精准级别更高。<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li>大概就这么多了，都是以最基本的概念为主，参考了一些网上的资料，如果有机会的话再深入地研究下~~~<br>参考：<a href=\"http://www.cnblogs.com/chenqf/p/6386163.html\" target=\"_blank\" rel=\"external\">彻底弄懂HTTP缓存机制及原理</a></li>\n</ul>\n"},{"title":"使用eslint检查JS代码","author":"TokenYangForever","date":"2017-10-11T08:13:00.000Z","_content":"#### 前言 ####\n* 代码规范一直是开发过程中比较重要的一环，包括命名规范、统一缩进等等，规范整洁的代码可读性高，也便于后期代码维护以及其他开发人员快速熟悉；本篇就讲一下eslint的具体用法。\n\n#### 介绍 ####\n* eslint早在2013年就有了，而我个人第一次接触还是在使用vue-cli搭建项目的时候，默认配置的eslint会根据规则直接报错，刚开始用的时候满屏报错、特别酸爽~~ 但只要习惯就好，使用eslint检查代码会使你的js文件更加健壮好看。\n\n#### 安装配置 ####\n* 首先安装eslint，直接 **npm install eslint**即可，注意如果你是全局安装的eslint，后面一些eslint相关依赖包也要全局安装。\n* 然后输入 **eslint init** 开始初始化一个配置文件，过程中会给你很多选项，比如是否使用es6、是否使用jsx语法、配置文件的文件格式等等。我选择的生成js配置文件，所有选项都选好后，生成一个**.eslintrc.js**配置文件内容大概长这样：\n```module.exports = {\n    \"env\": {\n        \"browser\": true,\n        \"es6\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"parserOptions\": {\n        \"sourceType\": \"module\"\n    },\n    \"rules\": {\n        \"indent\": [\n            \"error\",\n            \"tab\"\n        ],\n        \"linebreak-style\": [\n            \"error\",\n            \"windows\"\n        ],\n        \"quotes\": [\n            \"error\",\n            \"double\"\n        ],\n        \"semi\": [\n            \"error\",\n            \"never\"\n        ],\n        \"no-console\": 0 \n    }\n};\n```\n\n* 其中最重要的就是**rules**里面配置的规则，eslint会根据这里是配置的rule规则对代码进行检验，键值分别对应规则名和状态，比如”no-console“是规则名，后面对应的0表示不执行这条规则。extends表示继承自哪个共享的配置文件，env表示检查代码时所属的环境。\n* 具体状态码规则是这样：  **0**或者“**off**”表示关闭规则； **1**或者**warn**表示开启规则，使用警告级别的错误； **2**或者**error**表示开启规则，使用错误级别的错误：error (当被触发的时候，程序会报错)\n* 配置完成后，在当前目录新建一个index.js文件，随便输入几行代码，**然后在命令行输入eslint index.js**。就会对js文件进行代码检查，如果代码报错，命令行会提示你多少行触发了哪条规则的错误，你就可以对代码进行改正，或者修改配置文件中的rule规则。\n* 配置eslint的方法还有其他的，比如写在package.json中：新增一个eslintConfig，将上述配置文件的内容放在下面。但我个人还是喜欢用单独的配置文件，来控制eslint。\n#### 集成到webpack ####\n* 接下来介绍一下如何把eslint集成到webpack中。首先确保webpack已经安装好，然后依次安装eslint-loader、eslint-config-standard、eslint-plugin-html、eslint-plugin-promise、eslint-plugin-standard、eslint-friendly-formatter。注意如果eslint是全局安装的，这些依赖包也需要全局安装，否则报错找不到对应的包。\n* **然后新建一个webpack的配置文件webpack.config.js**，我这里只是做尽量最少的配置，具体如下：\n```\nmodule.exports = {\n    entry: {\n        index: \"./src/index.js\",\n    },\n    output: {\n        path: __dirname + \"/dist/\",\n        filename: \"[name].js\"\n    },\n    resolve: {\n        extensions: ['.js', '.vue', '.json']\n    },\n    module: {\n         rules: [\n                {\n                    test: /\\.js$/,\n                    exclude: /node_modules/,\n                    loaders: [\n                        'eslint-loader'\n                    ]\n                },\n                {\n                    test: /\\.vue|\\.js$/,\n                    enforce: 'pre',  // 在babel-loader对源码进行编译前进行lint的检查\n                    include: /src/,  // src文件夹下的文件需要被lint\n                    use: [{\n                        loader: 'eslint-loader',\n                        options: {\n                            formatter: require('eslint-friendly-formatter')   // 编译后错误报告格式\n                        }\n                    }]\n                }\n            ]\n    }\n}\n```\n* 这时候文件目录结构如下图\n![文件结构](http://upload-images.jianshu.io/upload_images/6383319-f6ea3f19ed2c3380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 这时在src文件夹下新建index.js文件，命令行输入webpack进行代码打包的过程会使用eslint进行检查，如果无误就在dist/js文件夹下生产打包后的代码，如果检查报错则在命令行中打印出错误位置和触犯的规则。","source":"_posts/使用eslint检查JS代码.md","raw":"title: 使用eslint检查JS代码\nauthor: TokenYangForever\ntags:\n  - JavaScript\n  - 工具\ncategories:\n  - JavaScript\ndate: 2017-10-11 16:13:00\n---\n#### 前言 ####\n* 代码规范一直是开发过程中比较重要的一环，包括命名规范、统一缩进等等，规范整洁的代码可读性高，也便于后期代码维护以及其他开发人员快速熟悉；本篇就讲一下eslint的具体用法。\n\n#### 介绍 ####\n* eslint早在2013年就有了，而我个人第一次接触还是在使用vue-cli搭建项目的时候，默认配置的eslint会根据规则直接报错，刚开始用的时候满屏报错、特别酸爽~~ 但只要习惯就好，使用eslint检查代码会使你的js文件更加健壮好看。\n\n#### 安装配置 ####\n* 首先安装eslint，直接 **npm install eslint**即可，注意如果你是全局安装的eslint，后面一些eslint相关依赖包也要全局安装。\n* 然后输入 **eslint init** 开始初始化一个配置文件，过程中会给你很多选项，比如是否使用es6、是否使用jsx语法、配置文件的文件格式等等。我选择的生成js配置文件，所有选项都选好后，生成一个**.eslintrc.js**配置文件内容大概长这样：\n```module.exports = {\n    \"env\": {\n        \"browser\": true,\n        \"es6\": true\n    },\n    \"extends\": \"eslint:recommended\",\n    \"parserOptions\": {\n        \"sourceType\": \"module\"\n    },\n    \"rules\": {\n        \"indent\": [\n            \"error\",\n            \"tab\"\n        ],\n        \"linebreak-style\": [\n            \"error\",\n            \"windows\"\n        ],\n        \"quotes\": [\n            \"error\",\n            \"double\"\n        ],\n        \"semi\": [\n            \"error\",\n            \"never\"\n        ],\n        \"no-console\": 0 \n    }\n};\n```\n\n* 其中最重要的就是**rules**里面配置的规则，eslint会根据这里是配置的rule规则对代码进行检验，键值分别对应规则名和状态，比如”no-console“是规则名，后面对应的0表示不执行这条规则。extends表示继承自哪个共享的配置文件，env表示检查代码时所属的环境。\n* 具体状态码规则是这样：  **0**或者“**off**”表示关闭规则； **1**或者**warn**表示开启规则，使用警告级别的错误； **2**或者**error**表示开启规则，使用错误级别的错误：error (当被触发的时候，程序会报错)\n* 配置完成后，在当前目录新建一个index.js文件，随便输入几行代码，**然后在命令行输入eslint index.js**。就会对js文件进行代码检查，如果代码报错，命令行会提示你多少行触发了哪条规则的错误，你就可以对代码进行改正，或者修改配置文件中的rule规则。\n* 配置eslint的方法还有其他的，比如写在package.json中：新增一个eslintConfig，将上述配置文件的内容放在下面。但我个人还是喜欢用单独的配置文件，来控制eslint。\n#### 集成到webpack ####\n* 接下来介绍一下如何把eslint集成到webpack中。首先确保webpack已经安装好，然后依次安装eslint-loader、eslint-config-standard、eslint-plugin-html、eslint-plugin-promise、eslint-plugin-standard、eslint-friendly-formatter。注意如果eslint是全局安装的，这些依赖包也需要全局安装，否则报错找不到对应的包。\n* **然后新建一个webpack的配置文件webpack.config.js**，我这里只是做尽量最少的配置，具体如下：\n```\nmodule.exports = {\n    entry: {\n        index: \"./src/index.js\",\n    },\n    output: {\n        path: __dirname + \"/dist/\",\n        filename: \"[name].js\"\n    },\n    resolve: {\n        extensions: ['.js', '.vue', '.json']\n    },\n    module: {\n         rules: [\n                {\n                    test: /\\.js$/,\n                    exclude: /node_modules/,\n                    loaders: [\n                        'eslint-loader'\n                    ]\n                },\n                {\n                    test: /\\.vue|\\.js$/,\n                    enforce: 'pre',  // 在babel-loader对源码进行编译前进行lint的检查\n                    include: /src/,  // src文件夹下的文件需要被lint\n                    use: [{\n                        loader: 'eslint-loader',\n                        options: {\n                            formatter: require('eslint-friendly-formatter')   // 编译后错误报告格式\n                        }\n                    }]\n                }\n            ]\n    }\n}\n```\n* 这时候文件目录结构如下图\n![文件结构](http://upload-images.jianshu.io/upload_images/6383319-f6ea3f19ed2c3380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n* 这时在src文件夹下新建index.js文件，命令行输入webpack进行代码打包的过程会使用eslint进行检查，如果无误就在dist/js文件夹下生产打包后的代码，如果检查报错则在命令行中打印出错误位置和触犯的规则。","slug":"使用eslint检查JS代码","published":1,"updated":"2017-10-11T08:15:21.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9gf0014e6vmnu2krtl3","content":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>代码规范一直是开发过程中比较重要的一环，包括命名规范、统一缩进等等，规范整洁的代码可读性高，也便于后期代码维护以及其他开发人员快速熟悉；本篇就讲一下eslint的具体用法。</li>\n</ul>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>eslint早在2013年就有了，而我个人第一次接触还是在使用vue-cli搭建项目的时候，默认配置的eslint会根据规则直接报错，刚开始用的时候满屏报错、特别酸爽~~ 但只要习惯就好，使用eslint检查代码会使你的js文件更加健壮好看。</li>\n</ul>\n<h4 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h4><ul>\n<li>首先安装eslint，直接 <strong>npm install eslint</strong>即可，注意如果你是全局安装的eslint，后面一些eslint相关依赖包也要全局安装。</li>\n<li><p>然后输入 <strong>eslint init</strong> 开始初始化一个配置文件，过程中会给你很多选项，比如是否使用es6、是否使用jsx语法、配置文件的文件格式等等。我选择的生成js配置文件，所有选项都选好后，生成一个<strong>.eslintrc.js</strong>配置文件内容大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">    &quot;env&quot;: &#123;</div><div class=\"line\">        &quot;browser&quot;: true,</div><div class=\"line\">        &quot;es6&quot;: true</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</div><div class=\"line\">    &quot;parserOptions&quot;: &#123;</div><div class=\"line\">        &quot;sourceType&quot;: &quot;module&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;rules&quot;: &#123;</div><div class=\"line\">        &quot;indent&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;tab&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;linebreak-style&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;windows&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;quotes&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;double&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;semi&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;never&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;no-console&quot;: 0 </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>其中最重要的就是<strong>rules</strong>里面配置的规则，eslint会根据这里是配置的rule规则对代码进行检验，键值分别对应规则名和状态，比如”no-console“是规则名，后面对应的0表示不执行这条规则。extends表示继承自哪个共享的配置文件，env表示检查代码时所属的环境。</p>\n</li>\n<li>具体状态码规则是这样：  <strong>0</strong>或者“<strong>off</strong>”表示关闭规则； <strong>1</strong>或者<strong>warn</strong>表示开启规则，使用警告级别的错误； <strong>2</strong>或者<strong>error</strong>表示开启规则，使用错误级别的错误：error (当被触发的时候，程序会报错)</li>\n<li>配置完成后，在当前目录新建一个index.js文件，随便输入几行代码，<strong>然后在命令行输入eslint index.js</strong>。就会对js文件进行代码检查，如果代码报错，命令行会提示你多少行触发了哪条规则的错误，你就可以对代码进行改正，或者修改配置文件中的rule规则。</li>\n<li>配置eslint的方法还有其他的，比如写在package.json中：新增一个eslintConfig，将上述配置文件的内容放在下面。但我个人还是喜欢用单独的配置文件，来控制eslint。<h4 id=\"集成到webpack\"><a href=\"#集成到webpack\" class=\"headerlink\" title=\"集成到webpack\"></a>集成到webpack</h4></li>\n<li>接下来介绍一下如何把eslint集成到webpack中。首先确保webpack已经安装好，然后依次安装eslint-loader、eslint-config-standard、eslint-plugin-html、eslint-plugin-promise、eslint-plugin-standard、eslint-friendly-formatter。注意如果eslint是全局安装的，这些依赖包也需要全局安装，否则报错找不到对应的包。</li>\n<li><p><strong>然后新建一个webpack的配置文件webpack.config.js</strong>，我这里只是做尽量最少的配置，具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        index: &quot;./src/index.js&quot;,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    output: &#123;</div><div class=\"line\">        path: __dirname + &quot;/dist/&quot;,</div><div class=\"line\">        filename: &quot;[name].js&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    resolve: &#123;</div><div class=\"line\">        extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    module: &#123;</div><div class=\"line\">         rules: [</div><div class=\"line\">                &#123;</div><div class=\"line\">                    test: /\\.js$/,</div><div class=\"line\">                    exclude: /node_modules/,</div><div class=\"line\">                    loaders: [</div><div class=\"line\">                        &apos;eslint-loader&apos;</div><div class=\"line\">                    ]</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &#123;</div><div class=\"line\">                    test: /\\.vue|\\.js$/,</div><div class=\"line\">                    enforce: &apos;pre&apos;,  // 在babel-loader对源码进行编译前进行lint的检查</div><div class=\"line\">                    include: /src/,  // src文件夹下的文件需要被lint</div><div class=\"line\">                    use: [&#123;</div><div class=\"line\">                        loader: &apos;eslint-loader&apos;,</div><div class=\"line\">                        options: &#123;</div><div class=\"line\">                            formatter: require(&apos;eslint-friendly-formatter&apos;)   // 编译后错误报告格式</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;]</div><div class=\"line\">                &#125;</div><div class=\"line\">            ]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这时候文件目录结构如下图<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-f6ea3f19ed2c3380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件结构\"></p>\n</li>\n<li>这时在src文件夹下新建index.js文件，命令行输入webpack进行代码打包的过程会使用eslint进行检查，如果无误就在dist/js文件夹下生产打包后的代码，如果检查报错则在命令行中打印出错误位置和触犯的规则。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>代码规范一直是开发过程中比较重要的一环，包括命名规范、统一缩进等等，规范整洁的代码可读性高，也便于后期代码维护以及其他开发人员快速熟悉；本篇就讲一下eslint的具体用法。</li>\n</ul>\n<h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><ul>\n<li>eslint早在2013年就有了，而我个人第一次接触还是在使用vue-cli搭建项目的时候，默认配置的eslint会根据规则直接报错，刚开始用的时候满屏报错、特别酸爽~~ 但只要习惯就好，使用eslint检查代码会使你的js文件更加健壮好看。</li>\n</ul>\n<h4 id=\"安装配置\"><a href=\"#安装配置\" class=\"headerlink\" title=\"安装配置\"></a>安装配置</h4><ul>\n<li>首先安装eslint，直接 <strong>npm install eslint</strong>即可，注意如果你是全局安装的eslint，后面一些eslint相关依赖包也要全局安装。</li>\n<li><p>然后输入 <strong>eslint init</strong> 开始初始化一个配置文件，过程中会给你很多选项，比如是否使用es6、是否使用jsx语法、配置文件的文件格式等等。我选择的生成js配置文件，所有选项都选好后，生成一个<strong>.eslintrc.js</strong>配置文件内容大概长这样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">    &quot;env&quot;: &#123;</div><div class=\"line\">        &quot;browser&quot;: true,</div><div class=\"line\">        &quot;es6&quot;: true</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;extends&quot;: &quot;eslint:recommended&quot;,</div><div class=\"line\">    &quot;parserOptions&quot;: &#123;</div><div class=\"line\">        &quot;sourceType&quot;: &quot;module&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    &quot;rules&quot;: &#123;</div><div class=\"line\">        &quot;indent&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;tab&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;linebreak-style&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;windows&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;quotes&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;double&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;semi&quot;: [</div><div class=\"line\">            &quot;error&quot;,</div><div class=\"line\">            &quot;never&quot;</div><div class=\"line\">        ],</div><div class=\"line\">        &quot;no-console&quot;: 0 </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n<li><p>其中最重要的就是<strong>rules</strong>里面配置的规则，eslint会根据这里是配置的rule规则对代码进行检验，键值分别对应规则名和状态，比如”no-console“是规则名，后面对应的0表示不执行这条规则。extends表示继承自哪个共享的配置文件，env表示检查代码时所属的环境。</p>\n</li>\n<li>具体状态码规则是这样：  <strong>0</strong>或者“<strong>off</strong>”表示关闭规则； <strong>1</strong>或者<strong>warn</strong>表示开启规则，使用警告级别的错误； <strong>2</strong>或者<strong>error</strong>表示开启规则，使用错误级别的错误：error (当被触发的时候，程序会报错)</li>\n<li>配置完成后，在当前目录新建一个index.js文件，随便输入几行代码，<strong>然后在命令行输入eslint index.js</strong>。就会对js文件进行代码检查，如果代码报错，命令行会提示你多少行触发了哪条规则的错误，你就可以对代码进行改正，或者修改配置文件中的rule规则。</li>\n<li>配置eslint的方法还有其他的，比如写在package.json中：新增一个eslintConfig，将上述配置文件的内容放在下面。但我个人还是喜欢用单独的配置文件，来控制eslint。<h4 id=\"集成到webpack\"><a href=\"#集成到webpack\" class=\"headerlink\" title=\"集成到webpack\"></a>集成到webpack</h4></li>\n<li>接下来介绍一下如何把eslint集成到webpack中。首先确保webpack已经安装好，然后依次安装eslint-loader、eslint-config-standard、eslint-plugin-html、eslint-plugin-promise、eslint-plugin-standard、eslint-friendly-formatter。注意如果eslint是全局安装的，这些依赖包也需要全局安装，否则报错找不到对应的包。</li>\n<li><p><strong>然后新建一个webpack的配置文件webpack.config.js</strong>，我这里只是做尽量最少的配置，具体如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\">module.exports = &#123;</div><div class=\"line\">    entry: &#123;</div><div class=\"line\">        index: &quot;./src/index.js&quot;,</div><div class=\"line\">    &#125;,</div><div class=\"line\">    output: &#123;</div><div class=\"line\">        path: __dirname + &quot;/dist/&quot;,</div><div class=\"line\">        filename: &quot;[name].js&quot;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    resolve: &#123;</div><div class=\"line\">        extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;]</div><div class=\"line\">    &#125;,</div><div class=\"line\">    module: &#123;</div><div class=\"line\">         rules: [</div><div class=\"line\">                &#123;</div><div class=\"line\">                    test: /\\.js$/,</div><div class=\"line\">                    exclude: /node_modules/,</div><div class=\"line\">                    loaders: [</div><div class=\"line\">                        &apos;eslint-loader&apos;</div><div class=\"line\">                    ]</div><div class=\"line\">                &#125;,</div><div class=\"line\">                &#123;</div><div class=\"line\">                    test: /\\.vue|\\.js$/,</div><div class=\"line\">                    enforce: &apos;pre&apos;,  // 在babel-loader对源码进行编译前进行lint的检查</div><div class=\"line\">                    include: /src/,  // src文件夹下的文件需要被lint</div><div class=\"line\">                    use: [&#123;</div><div class=\"line\">                        loader: &apos;eslint-loader&apos;,</div><div class=\"line\">                        options: &#123;</div><div class=\"line\">                            formatter: require(&apos;eslint-friendly-formatter&apos;)   // 编译后错误报告格式</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;]</div><div class=\"line\">                &#125;</div><div class=\"line\">            ]</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>这时候文件目录结构如下图<br><img src=\"http://upload-images.jianshu.io/upload_images/6383319-f6ea3f19ed2c3380.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"文件结构\"></p>\n</li>\n<li>这时在src文件夹下新建index.js文件，命令行输入webpack进行代码打包的过程会使用eslint进行检查，如果无误就在dist/js文件夹下生产打包后的代码，如果检查报错则在命令行中打印出错误位置和触犯的规则。</li>\n</ul>\n"},{"title":"原生JS实现图片懒加载(lazyload)","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n## 前言\n 图片懒加载也是比较常见的一种性能优化的方法，最近在用vue做一个新闻列表的客户端时也用到了，这里就简单介绍下实现原理和部分代码。\n*****\n## 实现原理\n 加载页面的时候，图片一直都是流量大头，针对图片的性能方法也挺多的比如base64、雪碧图等；懒加载也是其中一种，主要原理是将非首屏的图片src设为一个默认值，然后监听窗口滚动，当图片出现在视窗中时再给他赋予真实的图片地址，这样可以保证首屏的加载速度然后按需加载图片。\n\n![示例.png](http://upload-images.jianshu.io/upload_images/6383319-ba10ad7a53809f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 具体代码\n 首先在渲染时，图片引用默认图片，然后把真实地址放在data-*属性上面。\n<code><image src='./../assets/default.png' :data-src='item.allPics' class='lazyloadimg'></code></br>\n 然后是监听滚动，直接用window.onscroll就可以了，但是要注意一点的是类似于window的scroll和resize，还有mousemove这类触发很频繁的事件，最好用节流(throttle)或防抖函数(debounce)来控制一下触发频率。underscore和lodash里面都有封装这两个方法，这里先不多做介绍了。<br>\n 接着要判断图片是否出现在了视窗里面，主要是三个高度：1，当前body从顶部滚动了多少距离。2，视窗的高度。3，当前图片距离顶部的距离。offsetTop相关属性可以[参考这里](http://www.jianshu.com/p/135731ec13f1)，具体代码如下：\n<code>\nwindow.onscroll =_.throttle(this.watchscroll, 200);\nwatchscroll () { \n      var bodyScrollHeight =  document.body.scrollTop;// body滚动高度\n      var windowHeight = window.innerHeight;// 视窗高度\n      var imgs = document.getElementsByClassName('lazyloadimg');\n      for (var i =0; i < imgs.length; i++) {\n        var imgHeight = imgs[i].offsetTop;// 图片距离顶部高度  \n        if (imgHeight  < windowHeight  + bodyScrollHeight) {\n           imgs[i].src = imgs[i].getAttribute('data-src');\n           img[i].className = img[i].className.replace('lazyloadimg','')\n        }\n      }\n    }\n</code>\n*****\n## 结语\n 大概内容就这么多了，下次可能会补充一下防抖节流源码的实现。最后再补充两个常见的滚动判断：<br>1.页面滚动离开首屏(这时可显示回到顶部的按钮):<code>document.body.scrollTop > window.innerHeight</code>\n2.页面滚动到底部了(这时可去调接口获取更多内容)：<code>window.scrollY + window.innerHeight > document.body.offsetHeight</code>\n","source":"_posts/原生JS实现图片懒加载(lazyload).md","raw":"title: 原生JS实现图片懒加载(lazyload)\ntags:\n  - JavaScript\n  - HTML\ncategories:\n  - JavaScript\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n## 前言\n 图片懒加载也是比较常见的一种性能优化的方法，最近在用vue做一个新闻列表的客户端时也用到了，这里就简单介绍下实现原理和部分代码。\n*****\n## 实现原理\n 加载页面的时候，图片一直都是流量大头，针对图片的性能方法也挺多的比如base64、雪碧图等；懒加载也是其中一种，主要原理是将非首屏的图片src设为一个默认值，然后监听窗口滚动，当图片出现在视窗中时再给他赋予真实的图片地址，这样可以保证首屏的加载速度然后按需加载图片。\n\n![示例.png](http://upload-images.jianshu.io/upload_images/6383319-ba10ad7a53809f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n## 具体代码\n 首先在渲染时，图片引用默认图片，然后把真实地址放在data-*属性上面。\n<code><image src='./../assets/default.png' :data-src='item.allPics' class='lazyloadimg'></code></br>\n 然后是监听滚动，直接用window.onscroll就可以了，但是要注意一点的是类似于window的scroll和resize，还有mousemove这类触发很频繁的事件，最好用节流(throttle)或防抖函数(debounce)来控制一下触发频率。underscore和lodash里面都有封装这两个方法，这里先不多做介绍了。<br>\n 接着要判断图片是否出现在了视窗里面，主要是三个高度：1，当前body从顶部滚动了多少距离。2，视窗的高度。3，当前图片距离顶部的距离。offsetTop相关属性可以[参考这里](http://www.jianshu.com/p/135731ec13f1)，具体代码如下：\n<code>\nwindow.onscroll =_.throttle(this.watchscroll, 200);\nwatchscroll () { \n      var bodyScrollHeight =  document.body.scrollTop;// body滚动高度\n      var windowHeight = window.innerHeight;// 视窗高度\n      var imgs = document.getElementsByClassName('lazyloadimg');\n      for (var i =0; i < imgs.length; i++) {\n        var imgHeight = imgs[i].offsetTop;// 图片距离顶部高度  \n        if (imgHeight  < windowHeight  + bodyScrollHeight) {\n           imgs[i].src = imgs[i].getAttribute('data-src');\n           img[i].className = img[i].className.replace('lazyloadimg','')\n        }\n      }\n    }\n</code>\n*****\n## 结语\n 大概内容就这么多了，下次可能会补充一下防抖节流源码的实现。最后再补充两个常见的滚动判断：<br>1.页面滚动离开首屏(这时可显示回到顶部的按钮):<code>document.body.scrollTop > window.innerHeight</code>\n2.页面滚动到底部了(这时可去调接口获取更多内容)：<code>window.scrollY + window.innerHeight > document.body.offsetHeight</code>\n","slug":"原生JS实现图片懒加载(lazyload)","published":1,"updated":"2017-09-15T05:53:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9gh0018e6vmsrb1t8uo","content":"<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p> 图片懒加载也是比较常见的一种性能优化的方法，最近在用vue做一个新闻列表的客户端时也用到了，这里就简单介绍下实现原理和部分代码。</p>\n<hr>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p> 加载页面的时候，图片一直都是流量大头，针对图片的性能方法也挺多的比如base64、雪碧图等；懒加载也是其中一种，主要原理是将非首屏的图片src设为一个默认值，然后监听窗口滚动，当图片出现在视窗中时再给他赋予真实的图片地址，这样可以保证首屏的加载速度然后按需加载图片。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-ba10ad7a53809f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示例.png\"></p>\n<h2 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h2><p> 首先在渲染时，图片引用默认图片，然后把真实地址放在data-*属性上面。<br><code><image src=\"./../assets/default.png\" :data-src=\"item.allPics\" class=\"lazyloadimg\"></image></code><br><br> 然后是监听滚动，直接用window.onscroll就可以了，但是要注意一点的是类似于window的scroll和resize，还有mousemove这类触发很频繁的事件，最好用节流(throttle)或防抖函数(debounce)来控制一下触发频率。underscore和lodash里面都有封装这两个方法，这里先不多做介绍了。<br><br> 接着要判断图片是否出现在了视窗里面，主要是三个高度：1，当前body从顶部滚动了多少距离。2，视窗的高度。3，当前图片距离顶部的距离。offsetTop相关属性可以<a href=\"http://www.jianshu.com/p/135731ec13f1\" target=\"_blank\" rel=\"external\">参考这里</a>，具体代码如下：<br><code><br>window.onscroll =_.throttle(this.watchscroll, 200);<br>watchscroll () {<br>      var bodyScrollHeight =  document.body.scrollTop;// body滚动高度<br>      var windowHeight = window.innerHeight;// 视窗高度<br>      var imgs = document.getElementsByClassName(‘lazyloadimg’);<br>      for (var i =0; i &lt; imgs.length; i++) {<br>        var imgHeight = imgs[i].offsetTop;// 图片距离顶部高度<br>        if (imgHeight  &lt; windowHeight  + bodyScrollHeight) {<br>           imgs[i].src = imgs[i].getAttribute(‘data-src’);<br>           img[i].className = img[i].className.replace(‘lazyloadimg’,’’)<br>        }<br>      }<br>    }<br></code></p>\n<hr>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p> 大概内容就这么多了，下次可能会补充一下防抖节流源码的实现。最后再补充两个常见的滚动判断：<br>1.页面滚动离开首屏(这时可显示回到顶部的按钮):<code>document.body.scrollTop &gt; window.innerHeight</code><br>2.页面滚动到底部了(这时可去调接口获取更多内容)：<code>window.scrollY + window.innerHeight &gt; document.body.offsetHeight</code></p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p> 图片懒加载也是比较常见的一种性能优化的方法，最近在用vue做一个新闻列表的客户端时也用到了，这里就简单介绍下实现原理和部分代码。</p>\n<hr>\n<h2 id=\"实现原理\"><a href=\"#实现原理\" class=\"headerlink\" title=\"实现原理\"></a>实现原理</h2><p> 加载页面的时候，图片一直都是流量大头，针对图片的性能方法也挺多的比如base64、雪碧图等；懒加载也是其中一种，主要原理是将非首屏的图片src设为一个默认值，然后监听窗口滚动，当图片出现在视窗中时再给他赋予真实的图片地址，这样可以保证首屏的加载速度然后按需加载图片。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/6383319-ba10ad7a53809f30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"示例.png\"></p>\n<h2 id=\"具体代码\"><a href=\"#具体代码\" class=\"headerlink\" title=\"具体代码\"></a>具体代码</h2><p> 首先在渲染时，图片引用默认图片，然后把真实地址放在data-*属性上面。<br><code><image src=\"./../assets/default.png\" :data-src=\"item.allPics\" class=\"lazyloadimg\"></image></code><br><br> 然后是监听滚动，直接用window.onscroll就可以了，但是要注意一点的是类似于window的scroll和resize，还有mousemove这类触发很频繁的事件，最好用节流(throttle)或防抖函数(debounce)来控制一下触发频率。underscore和lodash里面都有封装这两个方法，这里先不多做介绍了。<br><br> 接着要判断图片是否出现在了视窗里面，主要是三个高度：1，当前body从顶部滚动了多少距离。2，视窗的高度。3，当前图片距离顶部的距离。offsetTop相关属性可以<a href=\"http://www.jianshu.com/p/135731ec13f1\" target=\"_blank\" rel=\"external\">参考这里</a>，具体代码如下：<br><code><br>window.onscroll =_.throttle(this.watchscroll, 200);<br>watchscroll () {<br>      var bodyScrollHeight =  document.body.scrollTop;// body滚动高度<br>      var windowHeight = window.innerHeight;// 视窗高度<br>      var imgs = document.getElementsByClassName(‘lazyloadimg’);<br>      for (var i =0; i &lt; imgs.length; i++) {<br>        var imgHeight = imgs[i].offsetTop;// 图片距离顶部高度<br>        if (imgHeight  &lt; windowHeight  + bodyScrollHeight) {<br>           imgs[i].src = imgs[i].getAttribute(‘data-src’);<br>           img[i].className = img[i].className.replace(‘lazyloadimg’,’’)<br>        }<br>      }<br>    }<br></code></p>\n<hr>\n<h2 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h2><p> 大概内容就这么多了，下次可能会补充一下防抖节流源码的实现。最后再补充两个常见的滚动判断：<br>1.页面滚动离开首屏(这时可显示回到顶部的按钮):<code>document.body.scrollTop &gt; window.innerHeight</code><br>2.页面滚动到底部了(这时可去调接口获取更多内容)：<code>window.scrollY + window.innerHeight &gt; document.body.offsetHeight</code></p>\n"},{"title":"为什么parseInt(0.0000008)===8？","author":"Token","date":"2017-09-15T05:36:00.000Z","_content":"\n---\n#### 前言\n* 最近看到一篇博客： [这些JavaScript编程黑科技，装逼指南，高逼格代码，让你惊叹不已。](https://github.com/jawil/blog/issues/24)上面介绍了挺多让人大开眼界，逼格满满的代码。其中有一句就是parseInt(0.0000008) === 8，结果返回的是true，这里我就详细解释下为什么parseInt(0.0000008)的结果等于8。\n#### 从函数本身出发\n* 这个出乎意料的结果似乎和[IEEE 754](https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin)浮点数标准并没有关系，而是parseInt函数本身的原因，先来看几个用parseInt方法将字符串转换为数字的例子：\n```\nparseInt('   1   2323') // 1\nparseInt('  abc1abc2323') // NaN\nparseInt('  **1abc2323') // NaN\nparseInt('    1abc2323') // 1\nparseInt(' 12.9999') // 12\nparseInt(\"  0x11\")  // 17\n```\n* 从中可以看出几条规则：\n1.字符串**左边的空格**会被忽略掉\n2.从左到右依次取数字字符串，如果最左边**以非数字开头则返回NaN**\n3.取到第一个数字字符后继续，**直到取到一个非数字的字符截止（包括小数点），**将这个时候得到的数字字符串转换为数字\n4.以'0x'开头的字符串会做特殊处理表示将后续的数字转换为16进制的整数\n\n* 到这里可能有人问，代码上传入的是数字类型0.0000008，为什么要分析如何转换字符串类型的参数。那是因为调用parseInt方法时，会隐式地将传入的数字类型用**toString方法**转换为字符串！而将0.0000008调用toString的**结果会是\"8e-7\"**，在javascript中，**小于0.000001的浮点数会以科学计数法来表示**，而这样的字符串参照上面的规则，自然得到的结果就是8了。\n#### 结语\n* 综上所述用parseInt转换数字的时候坑还是有的，使用时要多加注意。而如果用Math的floor或者round方法则可以得到正常的结果0。\n\n* 参考资料: \n  [parseInt() doesn’t always correctly convert to integer](http://www.2ality.com/2013/01/parseint.html)\n","source":"_posts/为什么parseInt(0-0000008)-===-8？.md","raw":"title: 为什么parseInt(0.0000008)===8？\ntags:\n  - JavaScript\ncategories:\n  - JavaScript\n  - 冷门\nauthor: Token\ndate: 2017-09-15 13:36:00\n---\n\n---\n#### 前言\n* 最近看到一篇博客： [这些JavaScript编程黑科技，装逼指南，高逼格代码，让你惊叹不已。](https://github.com/jawil/blog/issues/24)上面介绍了挺多让人大开眼界，逼格满满的代码。其中有一句就是parseInt(0.0000008) === 8，结果返回的是true，这里我就详细解释下为什么parseInt(0.0000008)的结果等于8。\n#### 从函数本身出发\n* 这个出乎意料的结果似乎和[IEEE 754](https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin)浮点数标准并没有关系，而是parseInt函数本身的原因，先来看几个用parseInt方法将字符串转换为数字的例子：\n```\nparseInt('   1   2323') // 1\nparseInt('  abc1abc2323') // NaN\nparseInt('  **1abc2323') // NaN\nparseInt('    1abc2323') // 1\nparseInt(' 12.9999') // 12\nparseInt(\"  0x11\")  // 17\n```\n* 从中可以看出几条规则：\n1.字符串**左边的空格**会被忽略掉\n2.从左到右依次取数字字符串，如果最左边**以非数字开头则返回NaN**\n3.取到第一个数字字符后继续，**直到取到一个非数字的字符截止（包括小数点），**将这个时候得到的数字字符串转换为数字\n4.以'0x'开头的字符串会做特殊处理表示将后续的数字转换为16进制的整数\n\n* 到这里可能有人问，代码上传入的是数字类型0.0000008，为什么要分析如何转换字符串类型的参数。那是因为调用parseInt方法时，会隐式地将传入的数字类型用**toString方法**转换为字符串！而将0.0000008调用toString的**结果会是\"8e-7\"**，在javascript中，**小于0.000001的浮点数会以科学计数法来表示**，而这样的字符串参照上面的规则，自然得到的结果就是8了。\n#### 结语\n* 综上所述用parseInt转换数字的时候坑还是有的，使用时要多加注意。而如果用Math的floor或者round方法则可以得到正常的结果0。\n\n* 参考资料: \n  [parseInt() doesn’t always correctly convert to integer](http://www.2ality.com/2013/01/parseint.html)\n","slug":"为什么parseInt(0-0000008)-===-8？","published":1,"updated":"2017-09-15T05:52:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9gj001be6vmcy2yst01","content":"<hr>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>最近看到一篇博客： <a href=\"https://github.com/jawil/blog/issues/24\" target=\"_blank\" rel=\"external\">这些JavaScript编程黑科技，装逼指南，高逼格代码，让你惊叹不已。</a>上面介绍了挺多让人大开眼界，逼格满满的代码。其中有一句就是parseInt(0.0000008) === 8，结果返回的是true，这里我就详细解释下为什么parseInt(0.0000008)的结果等于8。<h4 id=\"从函数本身出发\"><a href=\"#从函数本身出发\" class=\"headerlink\" title=\"从函数本身出发\"></a>从函数本身出发</h4></li>\n<li><p>这个出乎意料的结果似乎和<a href=\"https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin\" target=\"_blank\" rel=\"external\">IEEE 754</a>浮点数标准并没有关系，而是parseInt函数本身的原因，先来看几个用parseInt方法将字符串转换为数字的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">parseInt(&apos;   1   2323&apos;) // 1</div><div class=\"line\">parseInt(&apos;  abc1abc2323&apos;) // NaN</div><div class=\"line\">parseInt(&apos;  **1abc2323&apos;) // NaN</div><div class=\"line\">parseInt(&apos;    1abc2323&apos;) // 1</div><div class=\"line\">parseInt(&apos; 12.9999&apos;) // 12</div><div class=\"line\">parseInt(&quot;  0x11&quot;)  // 17</div></pre></td></tr></table></figure>\n</li>\n<li><p>从中可以看出几条规则：<br>1.字符串<strong>左边的空格</strong>会被忽略掉<br>2.从左到右依次取数字字符串，如果最左边<strong>以非数字开头则返回NaN</strong><br>3.取到第一个数字字符后继续，<strong>直到取到一个非数字的字符截止（包括小数点），</strong>将这个时候得到的数字字符串转换为数字<br>4.以’0x’开头的字符串会做特殊处理表示将后续的数字转换为16进制的整数</p>\n</li>\n<li><p>到这里可能有人问，代码上传入的是数字类型0.0000008，为什么要分析如何转换字符串类型的参数。那是因为调用parseInt方法时，会隐式地将传入的数字类型用<strong>toString方法</strong>转换为字符串！而将0.0000008调用toString的<strong>结果会是”8e-7”</strong>，在javascript中，<strong>小于0.000001的浮点数会以科学计数法来表示</strong>，而这样的字符串参照上面的规则，自然得到的结果就是8了。</p>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li><p>综上所述用parseInt转换数字的时候坑还是有的，使用时要多加注意。而如果用Math的floor或者round方法则可以得到正常的结果0。</p>\n</li>\n<li><p>参考资料:<br><a href=\"http://www.2ality.com/2013/01/parseint.html\" target=\"_blank\" rel=\"external\">parseInt() doesn’t always correctly convert to integer</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h4 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h4><ul>\n<li>最近看到一篇博客： <a href=\"https://github.com/jawil/blog/issues/24\" target=\"_blank\" rel=\"external\">这些JavaScript编程黑科技，装逼指南，高逼格代码，让你惊叹不已。</a>上面介绍了挺多让人大开眼界，逼格满满的代码。其中有一句就是parseInt(0.0000008) === 8，结果返回的是true，这里我就详细解释下为什么parseInt(0.0000008)的结果等于8。<h4 id=\"从函数本身出发\"><a href=\"#从函数本身出发\" class=\"headerlink\" title=\"从函数本身出发\"></a>从函数本身出发</h4></li>\n<li><p>这个出乎意料的结果似乎和<a href=\"https://baike.baidu.com/item/IEEE%20754/3869922?fr=aladdin\" target=\"_blank\" rel=\"external\">IEEE 754</a>浮点数标准并没有关系，而是parseInt函数本身的原因，先来看几个用parseInt方法将字符串转换为数字的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">parseInt(&apos;   1   2323&apos;) // 1</div><div class=\"line\">parseInt(&apos;  abc1abc2323&apos;) // NaN</div><div class=\"line\">parseInt(&apos;  **1abc2323&apos;) // NaN</div><div class=\"line\">parseInt(&apos;    1abc2323&apos;) // 1</div><div class=\"line\">parseInt(&apos; 12.9999&apos;) // 12</div><div class=\"line\">parseInt(&quot;  0x11&quot;)  // 17</div></pre></td></tr></table></figure>\n</li>\n<li><p>从中可以看出几条规则：<br>1.字符串<strong>左边的空格</strong>会被忽略掉<br>2.从左到右依次取数字字符串，如果最左边<strong>以非数字开头则返回NaN</strong><br>3.取到第一个数字字符后继续，<strong>直到取到一个非数字的字符截止（包括小数点），</strong>将这个时候得到的数字字符串转换为数字<br>4.以’0x’开头的字符串会做特殊处理表示将后续的数字转换为16进制的整数</p>\n</li>\n<li><p>到这里可能有人问，代码上传入的是数字类型0.0000008，为什么要分析如何转换字符串类型的参数。那是因为调用parseInt方法时，会隐式地将传入的数字类型用<strong>toString方法</strong>转换为字符串！而将0.0000008调用toString的<strong>结果会是”8e-7”</strong>，在javascript中，<strong>小于0.000001的浮点数会以科学计数法来表示</strong>，而这样的字符串参照上面的规则，自然得到的结果就是8了。</p>\n<h4 id=\"结语\"><a href=\"#结语\" class=\"headerlink\" title=\"结语\"></a>结语</h4></li>\n<li><p>综上所述用parseInt转换数字的时候坑还是有的，使用时要多加注意。而如果用Math的floor或者round方法则可以得到正常的结果0。</p>\n</li>\n<li><p>参考资料:<br><a href=\"http://www.2ality.com/2013/01/parseint.html\" target=\"_blank\" rel=\"external\">parseInt() doesn’t always correctly convert to integer</a></p>\n</li>\n</ul>\n"},{"title":"手写JSONP(promise封装)","author":"TokenYangForever","date":"2017-10-14T07:41:00.000Z","_content":"### 前言\n* JSONP以前研究过，最近又有点忘了，写篇本文mark一下，旨在理解记住JSONP的原理及其实现。代码实现用到es6语法，使用promise来封装JSONP方法，本地测试用的自己node搭的服务器,具体代码就不贴了。\n* 一句话阐述下JSONP原理：***动态生成一个JavaScript标签，其src由接口url、请求参数、callback函数名拼接而成，利用js标签没有跨域限制的特性实现跨域请求。***\n* 有几点需要注意：1.callback函数要绑定在window对象上 \n2.服务端返回数据有特定格式要求：callback函数名+'('+JSON.stringify(返回数据) +')'\n3.不支持post，因为js标签本身就是一个get请求\n* 具体代码如下，最后一段是调用函数的示例，这个函数将返回一个promise对象，获取到数据时状态为resolve\n```\n    const jsonp = function (url, data) {\n      return new Promise((resolve, reject) => {\n        // 初始化url\n        let dataString = url.indexOf('?') === -1 ? '?' : '&'\n        let callbackName = `jsonpCB_${Date.now()}`\n        url += `${dataString}callback=${callbackName}`\n        if (data) {\n         // 有请求参数，依次添加到url\n          for (let k in data) {\n            url += `&${k}=${data[k]}`\n          }\n        }\n        let jsNode = document.createElement('script')\n        jsNode.src = url\n        // 触发callback，触发后删除js标签和绑定在window上的callback\n        window[callbackName] = result => {\n          delete window[callbackName]\n          document.body.removeChild(jsNode)\n          if (result) {\n            resolve(result)\n          } else {\n            reject('没有返回数据')\n          }\n        }\n        // js加载异常的情况\n        jsNode.addEventListener('error', () => {\n          delete window[callbackName]\n          document.body.removeChild(jsNode)\n          reject('JavaScript资源加载失败')\n        }, false)\n        // 添加js节点到document上时，开始请求\n        document.body.appendChild(jsNode)\n      })\n    }\n    jsonp('http://192.168.0.103:8081/jsonp', {a: 1, b: 'heiheihei'})\n      .then(result => { console.log(result) })\n      .catch(err => { console.error(err) })\n```\n### 总结\n* 个人感觉JSONP用的情况还是比较少吧，如果已经是需要服务端配合来进行跨域的情况，为什么不直接用CORS呢","source":"_posts/手写JSONP-promise封装.md","raw":"title: 手写JSONP(promise封装)\nauthor: TokenYangForever\ntags:\n  - JavaScript\ncategories:\n  - JavaScript\ndate: 2017-10-14 15:41:00\n---\n### 前言\n* JSONP以前研究过，最近又有点忘了，写篇本文mark一下，旨在理解记住JSONP的原理及其实现。代码实现用到es6语法，使用promise来封装JSONP方法，本地测试用的自己node搭的服务器,具体代码就不贴了。\n* 一句话阐述下JSONP原理：***动态生成一个JavaScript标签，其src由接口url、请求参数、callback函数名拼接而成，利用js标签没有跨域限制的特性实现跨域请求。***\n* 有几点需要注意：1.callback函数要绑定在window对象上 \n2.服务端返回数据有特定格式要求：callback函数名+'('+JSON.stringify(返回数据) +')'\n3.不支持post，因为js标签本身就是一个get请求\n* 具体代码如下，最后一段是调用函数的示例，这个函数将返回一个promise对象，获取到数据时状态为resolve\n```\n    const jsonp = function (url, data) {\n      return new Promise((resolve, reject) => {\n        // 初始化url\n        let dataString = url.indexOf('?') === -1 ? '?' : '&'\n        let callbackName = `jsonpCB_${Date.now()}`\n        url += `${dataString}callback=${callbackName}`\n        if (data) {\n         // 有请求参数，依次添加到url\n          for (let k in data) {\n            url += `&${k}=${data[k]}`\n          }\n        }\n        let jsNode = document.createElement('script')\n        jsNode.src = url\n        // 触发callback，触发后删除js标签和绑定在window上的callback\n        window[callbackName] = result => {\n          delete window[callbackName]\n          document.body.removeChild(jsNode)\n          if (result) {\n            resolve(result)\n          } else {\n            reject('没有返回数据')\n          }\n        }\n        // js加载异常的情况\n        jsNode.addEventListener('error', () => {\n          delete window[callbackName]\n          document.body.removeChild(jsNode)\n          reject('JavaScript资源加载失败')\n        }, false)\n        // 添加js节点到document上时，开始请求\n        document.body.appendChild(jsNode)\n      })\n    }\n    jsonp('http://192.168.0.103:8081/jsonp', {a: 1, b: 'heiheihei'})\n      .then(result => { console.log(result) })\n      .catch(err => { console.error(err) })\n```\n### 总结\n* 个人感觉JSONP用的情况还是比较少吧，如果已经是需要服务端配合来进行跨域的情况，为什么不直接用CORS呢","slug":"手写JSONP-promise封装","published":1,"updated":"2017-10-14T07:42:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9thw9mo002qe6vm9rqx8ahs","content":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><ul>\n<li>JSONP以前研究过，最近又有点忘了，写篇本文mark一下，旨在理解记住JSONP的原理及其实现。代码实现用到es6语法，使用promise来封装JSONP方法，本地测试用的自己node搭的服务器,具体代码就不贴了。</li>\n<li>一句话阐述下JSONP原理：<strong><em>动态生成一个JavaScript标签，其src由接口url、请求参数、callback函数名拼接而成，利用js标签没有跨域限制的特性实现跨域请求。</em></strong></li>\n<li>有几点需要注意：1.callback函数要绑定在window对象上<br>2.服务端返回数据有特定格式要求：callback函数名+’(‘+JSON.stringify(返回数据) +’)’<br>3.不支持post，因为js标签本身就是一个get请求</li>\n<li>具体代码如下，最后一段是调用函数的示例，这个函数将返回一个promise对象，获取到数据时状态为resolve<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">const jsonp = function (url, data) &#123;</div><div class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">    // 初始化url</div><div class=\"line\">    let dataString = url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;</div><div class=\"line\">    let callbackName = `jsonpCB_$&#123;Date.now()&#125;`</div><div class=\"line\">    url += `$&#123;dataString&#125;callback=$&#123;callbackName&#125;`</div><div class=\"line\">    if (data) &#123;</div><div class=\"line\">     // 有请求参数，依次添加到url</div><div class=\"line\">      for (let k in data) &#123;</div><div class=\"line\">        url += `&amp;$&#123;k&#125;=$&#123;data[k]&#125;`</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    let jsNode = document.createElement(&apos;script&apos;)</div><div class=\"line\">    jsNode.src = url</div><div class=\"line\">    // 触发callback，触发后删除js标签和绑定在window上的callback</div><div class=\"line\">    window[callbackName] = result =&gt; &#123;</div><div class=\"line\">      delete window[callbackName]</div><div class=\"line\">      document.body.removeChild(jsNode)</div><div class=\"line\">      if (result) &#123;</div><div class=\"line\">        resolve(result)</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        reject(&apos;没有返回数据&apos;)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // js加载异常的情况</div><div class=\"line\">    jsNode.addEventListener(&apos;error&apos;, () =&gt; &#123;</div><div class=\"line\">      delete window[callbackName]</div><div class=\"line\">      document.body.removeChild(jsNode)</div><div class=\"line\">      reject(&apos;JavaScript资源加载失败&apos;)</div><div class=\"line\">    &#125;, false)</div><div class=\"line\">    // 添加js节点到document上时，开始请求</div><div class=\"line\">    document.body.appendChild(jsNode)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">jsonp(&apos;http://192.168.0.103:8081/jsonp&apos;, &#123;a: 1, b: &apos;heiheihei&apos;&#125;)</div><div class=\"line\">  .then(result =&gt; &#123; console.log(result) &#125;)</div><div class=\"line\">  .catch(err =&gt; &#123; console.error(err) &#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>个人感觉JSONP用的情况还是比较少吧，如果已经是需要服务端配合来进行跨域的情况，为什么不直接用CORS呢</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><ul>\n<li>JSONP以前研究过，最近又有点忘了，写篇本文mark一下，旨在理解记住JSONP的原理及其实现。代码实现用到es6语法，使用promise来封装JSONP方法，本地测试用的自己node搭的服务器,具体代码就不贴了。</li>\n<li>一句话阐述下JSONP原理：<strong><em>动态生成一个JavaScript标签，其src由接口url、请求参数、callback函数名拼接而成，利用js标签没有跨域限制的特性实现跨域请求。</em></strong></li>\n<li>有几点需要注意：1.callback函数要绑定在window对象上<br>2.服务端返回数据有特定格式要求：callback函数名+’(‘+JSON.stringify(返回数据) +’)’<br>3.不支持post，因为js标签本身就是一个get请求</li>\n<li>具体代码如下，最后一段是调用函数的示例，这个函数将返回一个promise对象，获取到数据时状态为resolve<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\">const jsonp = function (url, data) &#123;</div><div class=\"line\">  return new Promise((resolve, reject) =&gt; &#123;</div><div class=\"line\">    // 初始化url</div><div class=\"line\">    let dataString = url.indexOf(&apos;?&apos;) === -1 ? &apos;?&apos; : &apos;&amp;&apos;</div><div class=\"line\">    let callbackName = `jsonpCB_$&#123;Date.now()&#125;`</div><div class=\"line\">    url += `$&#123;dataString&#125;callback=$&#123;callbackName&#125;`</div><div class=\"line\">    if (data) &#123;</div><div class=\"line\">     // 有请求参数，依次添加到url</div><div class=\"line\">      for (let k in data) &#123;</div><div class=\"line\">        url += `&amp;$&#123;k&#125;=$&#123;data[k]&#125;`</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    let jsNode = document.createElement(&apos;script&apos;)</div><div class=\"line\">    jsNode.src = url</div><div class=\"line\">    // 触发callback，触发后删除js标签和绑定在window上的callback</div><div class=\"line\">    window[callbackName] = result =&gt; &#123;</div><div class=\"line\">      delete window[callbackName]</div><div class=\"line\">      document.body.removeChild(jsNode)</div><div class=\"line\">      if (result) &#123;</div><div class=\"line\">        resolve(result)</div><div class=\"line\">      &#125; else &#123;</div><div class=\"line\">        reject(&apos;没有返回数据&apos;)</div><div class=\"line\">      &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    // js加载异常的情况</div><div class=\"line\">    jsNode.addEventListener(&apos;error&apos;, () =&gt; &#123;</div><div class=\"line\">      delete window[callbackName]</div><div class=\"line\">      document.body.removeChild(jsNode)</div><div class=\"line\">      reject(&apos;JavaScript资源加载失败&apos;)</div><div class=\"line\">    &#125;, false)</div><div class=\"line\">    // 添加js节点到document上时，开始请求</div><div class=\"line\">    document.body.appendChild(jsNode)</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;</div><div class=\"line\">jsonp(&apos;http://192.168.0.103:8081/jsonp&apos;, &#123;a: 1, b: &apos;heiheihei&apos;&#125;)</div><div class=\"line\">  .then(result =&gt; &#123; console.log(result) &#125;)</div><div class=\"line\">  .catch(err =&gt; &#123; console.error(err) &#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li>个人感觉JSONP用的情况还是比较少吧，如果已经是需要服务端配合来进行跨域的情况，为什么不直接用CORS呢</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cj9thw9df0001e6vmuyy81hqf","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9dq0009e6vmpzrqqfy7"},{"post_id":"cj9thw9d40000e6vme7z2rw5a","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9dt000ce6vmfkqfv69s"},{"post_id":"cj9thw9d40000e6vme7z2rw5a","category_id":"cj9thw9dn0006e6vmk7fzwjzu","_id":"cj9thw9dt000de6vmvoqwaleh"},{"post_id":"cj9thw9es000ee6vm57pktjsk","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9f0000me6vmjb3h15z9"},{"post_id":"cj9thw9f6000se6vmh4i8kj6d","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9gc000ze6vm35umezjc"},{"post_id":"cj9thw9ex000ie6vmdtkoppwr","category_id":"cj9thw9f5000pe6vmhv6406v2","_id":"cj9thw9ge0013e6vmu28yf3ih"},{"post_id":"cj9thw9ez000le6vmx0aye7fl","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9gg0016e6vmbfqv1n9z"},{"post_id":"cj9thw9ez000le6vmx0aye7fl","category_id":"cj9thw9g8000ue6vm2gv8eitm","_id":"cj9thw9gj0019e6vm8kv6y0fu"},{"post_id":"cj9thw9f0000ne6vmzezcy9gu","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9gk001ce6vmui0waohu"},{"post_id":"cj9thw9f0000ne6vmzezcy9gu","category_id":"cj9thw9g8000ue6vm2gv8eitm","_id":"cj9thw9gm001ge6vmd0megf89"},{"post_id":"cj9thw9gf0014e6vmnu2krtl3","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9gn001ie6vm2fjqqyv0"},{"post_id":"cj9thw9gh0018e6vmsrb1t8uo","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9go001me6vmq4zhhcbj"},{"post_id":"cj9thw9ew000ge6vm6ex99ava","category_id":"cj9thw9ey000je6vm3l3oyowd","_id":"cj9thw9gp001oe6vmngaawg7w"},{"post_id":"cj9thw9ew000ge6vm6ex99ava","category_id":"cj9thw9gg0015e6vmi3zriddi","_id":"cj9thw9gq001se6vm8ckgdbyq"},{"post_id":"cj9thw9f2000oe6vmx5ncw64r","category_id":"cj9thw9gl001ee6vmr9kxk9eq","_id":"cj9thw9gq001ue6vmyfchb9ry"},{"post_id":"cj9thw9g7000te6vmdv4owwbq","category_id":"cj9thw9gl001ee6vmr9kxk9eq","_id":"cj9thw9gs001ye6vmmmzn2z71"},{"post_id":"cj9thw9g9000xe6vmkebpj8ol","category_id":"cj9thw9gl001ee6vmr9kxk9eq","_id":"cj9thw9gu0022e6vmvz6hvkws"},{"post_id":"cj9thw9gb000ye6vmhp7y42a9","category_id":"cj9thw9gl001ee6vmr9kxk9eq","_id":"cj9thw9gv0026e6vmhxqeagbl"},{"post_id":"cj9thw9gd0012e6vmp1d6djac","category_id":"cj9thw9gu0021e6vmnaao5ngv","_id":"cj9thw9gw002be6vmrcxy9aty"},{"post_id":"cj9thw9gj001be6vmcy2yst01","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9gx002fe6vmkpq3xje4"},{"post_id":"cj9thw9gj001be6vmcy2yst01","category_id":"cj9thw9gv0027e6vmh6ce7fzz","_id":"cj9thw9gy002ie6vm0c939odp"},{"post_id":"cj9thw9mo002qe6vm9rqx8ahs","category_id":"cj9thw9di0002e6vmv69wtdcf","_id":"cj9thw9mw002se6vm19znbuh8"}],"PostTag":[{"post_id":"cj9thw9d40000e6vme7z2rw5a","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9dp0008e6vmorgcsqcr"},{"post_id":"cj9thw9d40000e6vme7z2rw5a","tag_id":"cj9thw9dm0005e6vmeeqir8xr","_id":"cj9thw9dr000ae6vmz243h8tq"},{"post_id":"cj9thw9df0001e6vmuyy81hqf","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9dt000be6vm9t3iz0nq"},{"post_id":"cj9thw9es000ee6vm57pktjsk","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9ex000he6vmuimo4nms"},{"post_id":"cj9thw9ew000ge6vm6ex99ava","tag_id":"cj9thw9ey000ke6vmddd53aqi","_id":"cj9thw9f6000re6vmcby8mmpv"},{"post_id":"cj9thw9f6000se6vmh4i8kj6d","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9g9000we6vm2vegqjdw"},{"post_id":"cj9thw9ex000ie6vmdtkoppwr","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gj001ae6vmmq7424xl"},{"post_id":"cj9thw9ex000ie6vmdtkoppwr","tag_id":"cj9thw9f5000qe6vmaj86b6v3","_id":"cj9thw9gk001de6vm7fosye9g"},{"post_id":"cj9thw9ex000ie6vmdtkoppwr","tag_id":"cj9thw9g9000ve6vmvimx71uk","_id":"cj9thw9gm001he6vmz0tkmydg"},{"post_id":"cj9thw9ex000ie6vmdtkoppwr","tag_id":"cj9thw9gc0011e6vmpnyiasye","_id":"cj9thw9gn001je6vmq4o2nrhz"},{"post_id":"cj9thw9gj001be6vmcy2yst01","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9go001ne6vm27ir7e8i"},{"post_id":"cj9thw9ez000le6vmx0aye7fl","tag_id":"cj9thw9gg0017e6vmb1madztl","_id":"cj9thw9gp001pe6vmp9e55cz5"},{"post_id":"cj9thw9ez000le6vmx0aye7fl","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gq001te6vm2ge212ih"},{"post_id":"cj9thw9f0000ne6vmzezcy9gu","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gr001ve6vmunia6vvd"},{"post_id":"cj9thw9f0000ne6vmzezcy9gu","tag_id":"cj9thw9gg0017e6vmb1madztl","_id":"cj9thw9gt001ze6vm03ofokd7"},{"post_id":"cj9thw9f2000oe6vmx5ncw64r","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gu0020e6vm24tful30"},{"post_id":"cj9thw9f2000oe6vmx5ncw64r","tag_id":"cj9thw9gn001le6vm8yhkc7uv","_id":"cj9thw9gv0024e6vmfbq6qyrp"},{"post_id":"cj9thw9g7000te6vmdv4owwbq","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gv0025e6vmqibt1zpl"},{"post_id":"cj9thw9g7000te6vmdv4owwbq","tag_id":"cj9thw9gn001le6vm8yhkc7uv","_id":"cj9thw9gw0029e6vm3yhenfpx"},{"post_id":"cj9thw9g9000xe6vmkebpj8ol","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gw002ae6vmmd2xmiwe"},{"post_id":"cj9thw9g9000xe6vmkebpj8ol","tag_id":"cj9thw9gn001le6vm8yhkc7uv","_id":"cj9thw9gx002de6vmyewsjt1f"},{"post_id":"cj9thw9gb000ye6vmhp7y42a9","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gx002ee6vmj6132ulz"},{"post_id":"cj9thw9gb000ye6vmhp7y42a9","tag_id":"cj9thw9gn001le6vm8yhkc7uv","_id":"cj9thw9gx002ge6vmq18bgus1"},{"post_id":"cj9thw9gd0012e6vmp1d6djac","tag_id":"cj9thw9gw0028e6vmri0h0z29","_id":"cj9thw9gy002je6vmjx60v0jw"},{"post_id":"cj9thw9gd0012e6vmp1d6djac","tag_id":"cj9thw9gx002ce6vmfa9hh76l","_id":"cj9thw9gy002ke6vmlbkzib32"},{"post_id":"cj9thw9gf0014e6vmnu2krtl3","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9gz002me6vm0dm8k3a7"},{"post_id":"cj9thw9gf0014e6vmnu2krtl3","tag_id":"cj9thw9gy002he6vmuz9rugij","_id":"cj9thw9h0002ne6vmpl8qx3wq"},{"post_id":"cj9thw9gh0018e6vmsrb1t8uo","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9h0002oe6vmqhdriarm"},{"post_id":"cj9thw9gh0018e6vmsrb1t8uo","tag_id":"cj9thw9gz002le6vmfjivremk","_id":"cj9thw9h0002pe6vm1jrizwc6"},{"post_id":"cj9thw9mo002qe6vm9rqx8ahs","tag_id":"cj9thw9dl0003e6vm5ghw197k","_id":"cj9thw9mv002re6vmsetsissj"}],"Tag":[{"name":"JavaScript","_id":"cj9thw9dl0003e6vm5ghw197k"},{"name":"总结","_id":"cj9thw9dm0005e6vmeeqir8xr"},{"name":"mysql","_id":"cj9thw9ey000ke6vmddd53aqi"},{"name":"服务端渲染","_id":"cj9thw9f5000qe6vmaj86b6v3"},{"name":"vue","_id":"cj9thw9g9000ve6vmvimx71uk"},{"name":"node","_id":"cj9thw9gc0011e6vmpnyiasye"},{"name":"框架源码","_id":"cj9thw9gg0017e6vmb1madztl"},{"name":"算法","_id":"cj9thw9gn001le6vm8yhkc7uv"},{"name":"http缓存","_id":"cj9thw9gw0028e6vmri0h0z29"},{"name":"html","_id":"cj9thw9gx002ce6vmfa9hh76l"},{"name":"工具","_id":"cj9thw9gy002he6vmuz9rugij"},{"name":"HTML","_id":"cj9thw9gz002le6vmfjivremk"}]}}